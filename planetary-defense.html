<!DOCTYPE html>
<html>
<head>
<title>Planetary Defense</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
  body {
    margin: 0;
    overflow: hidden;
    background-color: black;
    font-family: 'Inter', sans-serif; /* Using Inter font */
    -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none;   /* Safari */
    -khtml-user-select: none;    /* Konqueror HTML */
    -moz-user-select: none;      /* Old versions of Firefox */
    -ms-user-select: none;       /* Internet Explorer/Edge */
    user-select: none;           /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
  }
  #spaceCanvas {
    display: block;
    position: absolute; /* Needed for z-index to work */
    top: 0;
    left: 0;
    width: 100%; /* Ensure SVG takes full width */
    height: 100%; /* Ensure SVG takes full height */
    background-color: black; /* Pure black space background */
    border-radius: 10px; /* Rounded corners for the canvas area */
    z-index: 1; /* Place above stars (z-index: 0) */
  }
  #dateTimeDisplay {
    position: absolute;
    top: 0; /* Set initial top */
    left: 0; /* Set initial left */
    display: none; /* Hide initially until positioned by JS */
    color: #00ff00; /* Bright green for techy feel */
    font-family: 'Space Mono', monospace; /* Cool techy font */
    font-size: 48px; /* Much larger font size */
    text-shadow: 0 0 10px rgba(0, 255, 0, 0.9), 0 0 20px rgba(0, 255, 0, 0.7); /* More intense glow for larger text */
    /* Removed background, padding, border-radius, and box-shadow for a transparent look */
    pointer-events: none; /* Allow clicks to pass through */
    z-index: 100; /* Ensure it's on top */
  }
  #perfStats {
    position: absolute;
    top: 15px;
    left: 15px;
    color: #e0e0e0; /* Light grey for stats */
    font-size: 14px;
    background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
    padding: 8px 12px;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    z-index: 100; /* Ensure stats are on top */
    display: none; /* Hidden by default */
  }
  /* Laser beams are now SVG elements, so these CSS rules are less relevant for their shape,
     but might still apply for opacity transitions if the element itself is a div/g. */
  .laser-beam {
    position: absolute; /* Still needed for positioning the SVG group */
    pointer-events: none; /* Allow clicks to pass through */
    opacity: 1;
    z-index: 50; /* Lasers should be above stars/background */
  }
  /* Removed .explosion-particle CSS as particles are now SVG elements */
  #controls {
    position: absolute;
    bottom: 16px; /* 4 units from bottom */
    left: 16px;  /* 4 units from left */
    z-index: 9999; /* Very high z-index to ensure visibility */
    background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent dark background */
    padding: 10px;
    border-radius: 10px;
    display: flex; /* From Tailwind */
    gap: 8px; /* space-x-2 in Tailwind */
    align-items: center; /* To vertically align buttons */
  }
  #controls button {
    /* Basic button styling to ensure they are visible */
    padding: 8px 16px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #e0e0e0;
    background-color: rgba(50, 50, 50, 0.7);
    cursor: pointer;
    transition: background-color 0.2s, border-color 0.2s;
  }
  #controls button:hover {
    background-color: rgba(70, 70, 70, 0.9);
    border-color: rgba(255, 255, 255, 0.5);
  }

  /* Styles for the square nuke button */
  .nuke-button {
    position: absolute;
    bottom: 20px; /* Adjust as needed */
    right: 20px; /* Adjust as needed */
    width: 80px; /* Width of the square */
    height: 80px; /* Height of the square */
    border-radius: 8px; /* Slightly rounded corners for a modern look */
    background-color: rgba(255, 0, 0, 0.4); /* More transparent red background */
    color: white;
    font-size: 1.2em;
    font-weight: bold;
    border: 2px solid rgba(255, 255, 255, 0.5);
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    line-height: 1.2; /* Adjust line height for vertical centering of text */
    box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); /* Initial subtle glow */
    transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
    z-index: 9999; /* Ensure it's on top */
  }

  .nuke-button:hover {
    background-color: rgba(255, 0, 0, 0.6); /* Slightly less transparent on hover */
    border-color: rgba(255, 255, 255, 0.8);
    box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
  }

  .nuke-button:disabled {
    background-color: rgba(50, 50, 50, 0.3); /* More transparent dark background when disabled */
    border-color: rgba(255, 255, 255, 0.3);
    color: #a0a0a0;
    cursor: not-allowed;
    box-shadow: none;
    animation: none; /* Stop pulsation when disabled */
  }

  @keyframes pulse-red {
    0% {
      box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
    }
    70% {
      box-shadow: 0 0 0 15px rgba(255, 0, 0, 0);
    }
    100% {
      box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
    }
  }

  .nuke-ready-pulse {
    animation: pulse-red 2s infinite;
  }
</style>
</head>
<body>
  <svg id="spaceCanvas" width="100%" height="100%">
    <defs>
      <linearGradient id="userLaserGradient" x1="0%" y1="50%" x2="100%" y2="50%">
        <stop offset="0%" stop-color="rgba(0, 255, 0, 0.1)"/>
        <stop offset="70%" stop-color="rgba(100, 255, 100, 0.8)"/>
        <stop offset="100%" stop-color="rgba(0, 255, 0, 1)"/>
      </linearGradient>
      <linearGradient id="satelliteLaserGradient" x1="0%" y1="50%" x2="100%" y2="50%">
        <stop offset="0%" stop-color="rgba(255, 0, 0, 0.5)"/>
        <stop offset="50%" stop-color="rgba(255, 100, 100, 1)"/>
        <stop offset="100%" stop-color="rgba(255, 0, 0, 0.5)"/>
      </linearGradient>
      <filter id="laserGlow" x="-50%" y="-50%" width="200%" height="200%">
          <!-- Simplified for performance, especially for particles -->
          <feDropShadow dx="0" dy="0" stdDeviation="8" flood-color="rgba(0, 255, 0, 0.6)"/>
      </filter>
      <!-- Generic glow filter for cracks -->
      <filter id="crackGlowFilter" x="-50%" y="-50%" width="200%" height="200%">
          <feDropShadow dx="0" dy="0" stdDeviation="15" flood-color="rgba(255, 0, 0, 0.8)"/>
      </filter>
      <!-- Asteroid Gradients for varied appearance -->
      <radialGradient id="asteroidGradientGrey" cx="50%" cy="50%" r="50%" fx="60%" fy="40%">
        <stop offset="0%" stop-color="#a0a0a0"/>
        <stop offset="50%" stop-color="#606060"/>
        <stop offset="100%" stop-color="#303030"/>
      </radialGradient>
      <radialGradient id="asteroidGradientBrown" cx="50%" cy="50%" r="50%" fx="60%" fy="40%">
        <stop offset="0%" stop-color="#b09070"/>
        <stop offset="50%" stop-color="#806040"/>
        <stop offset="100%" stop-color="#503010"/>
      </radialGradient>
      <radialGradient id="asteroidGradientRed" cx="50%" cy="50%" r="50%" fx="60%" fy="40%">
        <stop offset="0%" stop-color="#c08080"/>
        <stop offset="50%" stop-color="#905050"/>
        <stop offset="100%" stop-color="#602020"/>
      </radialGradient>
      <!-- Nuke Projectile Gradient -->
      <radialGradient id="nukeGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="rgba(255, 255, 0, 1)"/>
        <stop offset="30%" stop-color="rgba(255, 165, 0, 0.8)"/>
        <stop offset="100%" stop-color="rgba(255, 0, 0, 0.1)"/>
      </radialGradient>
      <!-- Nuke Fireball Gradient (More Transparent) -->
      <radialGradient id="fireballGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="rgba(255, 255, 200, 0.6)"/> <!-- Reduced opacity -->
        <stop offset="20%" stop-color="rgba(255, 200, 0, 0.5)"/>  <!-- Reduced opacity -->
        <stop offset="50%" stop-color="rgba(255, 100, 0, 0.3)"/>  <!-- Reduced opacity -->
        <stop offset="80%" stop-color="rgba(200, 50, 0, 0.1)"/>   <!-- Reduced opacity -->
        <stop offset="100%" stop-color="rgba(100, 0, 0, 0)"/>
      </radialGradient>
      <!-- Crack Gradient (Bright Yellow center, Red edges) -->
      <radialGradient id="crackGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="rgba(255, 255, 0, 1)"/>    <!-- Bright Yellow -->
        <stop offset="50%" stop-color="rgba(255, 165, 0, 0.8)"/> <!-- Orange -->
        <stop offset="100%" stop-color="rgba(255, 0, 0, 0.6)"/>  <!-- Red -->
      </radialGradient>
      <!-- Defender Gradient (Purple-Blue - More Pronounced) -->
      <radialGradient id="defenderGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#E6E6FA"/> <!-- Lavender (brighter highlight) -->
        <stop offset="40%" stop-color="#9370DB"/> <!-- MediumPurple -->
        <stop offset="80%" stop-color="#6A5ACD"/> <!-- SlateBlue -->
        <stop offset="100%" stop-color="#362F6B"/> <!-- Darker SlateBlue (deeper shadow) -->
      </radialGradient>
      <!-- Main Thruster Fire Gradient (Yellow to Red) -->
      <radialGradient id="mainThrusterFireGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="rgba(255, 255, 0, 1)"/>    <!-- Bright Yellow -->
        <stop offset="50%" stop-color="rgba(255, 165, 0, 0.8)"/> <!-- Orange -->
        <stop offset="100%" stop-color="rgba(255, 0, 0, 0)"/>    <!-- Transparent Red -->
      </radialGradient>
      <!-- Defender Thruster Pod Gradient (Blue to Black) -->
      <radialGradient id="defenderThrusterPodGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#00BFFF"/> <!-- Deep Sky Blue -->
        <stop offset="100%" stop-color="#000000"/> <!-- Black -->
      </radialGradient>
      <!-- RCS Thruster Fire Gradient (Light Blue to Transparent) -->
      <radialGradient id="rcsThrusterFireGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="rgba(173, 216, 230, 0.8)"/> <!-- Light Blue -->
        <stop offset="100%" stop-color="rgba(173, 216, 230, 0)"/> <!-- Transparent Light Blue -->
      </radialGradient>
    </defs>
    <g id="starsLayer"></g>
    <g id="gameplayLayer"></g>
    <g id="effectsLayer"></g>
  </svg>
  <div id="dateTimeDisplay"></div> <!-- New div for date and time -->
  <div id="perfStats"></div> <!-- New div for performance stats -->
  <div id="controls" class="absolute bottom-4 left-4 z-100 flex space-x-2">
    <button id="qualityToggle" class="px-4 py-2 bg-gray-900/50 text-gray-300 rounded-lg shadow-none hover:bg-gray-800/70 transition-colors duration-200">Quality: High</button>
    <button id="muteToggle" class="px-4 py-2 bg-gray-900/50 text-gray-300 rounded-lg shadow-none hover:bg-gray-800/70 transition-colors duration-200">Mute: Off</button>
    <button id="pauseToggle" class="px-4 py-2 bg-gray-900/50 text-gray-300 rounded-lg shadow-none hover:bg-gray-800/70 transition-colors duration-200">Pause: Off</button>
    <button id="dateTimeToggleBtn" class="px-4 py-2 bg-gray-900/50 text-gray-300 rounded-lg shadow-none hover:bg-gray-800/70 transition-colors duration-200">Date/Time: On</button> <!-- New button -->
    <button id="perfStatsToggleBtn" class="px-4 py-2 bg-gray-900/50 text-gray-300 rounded-lg shadow-none hover:bg-gray-800/70 transition-colors duration-200">Perf Stats: Off</button> <!-- New button -->
  </div>

  <button id="nukeButton" class="nuke-button" disabled>Nuke</button>

  <script>
    const canvas = document.getElementById('spaceCanvas');
    const dateTimeDisplay = document.getElementById('dateTimeDisplay'); // New: Get date/time display div
    const perfStatsDiv = document.getElementById('perfStats'); // New: Get performance stats div
    const qualityToggleBtn = document.getElementById('qualityToggle');
    const dateTimeToggleBtn = document.getElementById('dateTimeToggleBtn'); // New: Get date/time toggle button
    const muteToggleBtn = document.getElementById('muteToggle'); // Get the new mute button
    const pauseToggleBtn = document.getElementById('pauseToggle'); // Get the new pause button
    const nukeButton = document.getElementById('nukeButton'); // Get the new nuke button
    const perfStatsToggleBtn = document.getElementById('perfStatsToggleBtn'); // New: Get perf stats toggle button

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.setAttribute('viewBox', `0 0 ${width} ${height}`);

    // Define SVG layers
    let starsLayer; // Reference to the SVG group for stars
    let gameplayLayer; // Reference to the SVG group for gameplay elements
    let effectsLayer; // Reference to the SVG group for effects

    // The 'stars' array will now hold Star objects (SVG circle based)
    const stars = []; 
    const defenders = []; // Renamed from satellites
    const asteroids = [];
    const lasers = []; // Array to manage active laser beams
    const nukes = []; // New: Array to manage active nuke projectiles
    const ufos = []; // Changed: Array to manage active UFOs
    let nukeFlashElement = null; // New: Element for the full-screen nuke flash

    const ufoMessageQueue = []; // Queue for UFOs waiting to speak
    let currentSpeakingUFO = null; // The UFO currently speaking

    // Global variables for starfield movement
    let starfieldVx = 0;
    let starfieldVy = 0;
    let starfieldTargetVx = 0;
    let starfieldTargetVy = 0;
    const starfieldDirectionChangeInterval = 15000; // Change target direction every 15 seconds
    const starfieldDirectionChangeDuration = 5000; // Transition to new direction over 5 seconds
    let lastStarfieldDirectionChangeTime = 0; // When the *interval* timer last reset
    let starfieldDirectionTransitionStartTime = 0; // When the *transition* to the new target started

    // Global variables for date/time display movement
    let dateTimeOrbitCenterX; // Center X of the clock's orbit
    let dateTimeOrbitCenterY; // Center Y of the clock's orbit
    let dateTimeOrbitRadius; // Radius of the clock's orbit
    let dateTimeOrbitAngle = 0; // Current angle in radians for orbital movement
    const dateTimeOrbitSpeed = 0.00005; // Radians per millisecond (very slow orbit)

    let dateTimeOrbitCenterVx = 0; // Velocity X for the orbit center's drift
    let dateTimeOrbitCenterVy = 0; // Velocity Y for the orbit center's drift
    const dateTimeOrbitCenterSpeedMax = 0.01; // Max drift speed in pixels per millisecond
    const dateTimeOrbitCenterDirectionChangeInterval = 30000; // Change drift direction every 30 seconds
    let lastDateTimeOrbitCenterDirectionChangeTime = 0;

    let isDateTimeVisible = true; // Default to on
    let isPerfStatsVisible = false; // New: Default to off

    // Object Pools
    const laserPool = [];
    const nukePool = []; // New: Pool for nuke projectiles
    const particlePool = [];
    const fireballPool = []; // New: Pool for fireball effects
    const MAX_LASERS = 50; // Max concurrent lasers in pool
    const MAX_NUKES = 1; // Only one nuke projectile at a time
    const MAX_PARTICLES = 100; // Max concurrent particles in pool (reduced for performance)
    const MAX_FIREBALLS = 5; // Max concurrent fireball effects (should be low)

    const SCALE_FACTOR = 0.75; // All object sizes will be scaled by this factor

    // Global arrays for centralized animation
    const activeParticles = []; // New: To manage all active explosion/spark particles
    const activeFireballs = []; // New: To manage active fireball effects
    const explodingUfoParts = []; // New: To manage detached UFO parts during destruction

    // Game state variables
    let isMuted = false;
    let isPaused = false; // New pause state variable

    // Nuke specific variables
    let nukeAvailable = false; // Is a nuke ready to fire?
    const nukeCooldown = 15000; // 15 seconds cooldown after firing
    let nukeNextAvailableTime = Date.now() + nukeCooldown; // Initialize next available time
    const nukeGainInterval = 60000; // Gain a nuke every 60 seconds
    let lastNukeGainTime = Date.now(); // Initialize with current time

    // Browser detection for iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    // FPS counter variables
    let lastFrameTime = 0; // Time of the previous frame
    let lastFpsUpdateTime = 0; // Time when FPS was last updated
    let fps = 0;
    let frameCount = 0;

    // Performance monitoring variables
    const accumulatedPerformanceData = {
        overallUpdateTime: 0, // Total time spent in the JS update function
        stars: 0,
        defenders: 0,
        asteroids: 0,
        lasers: 0,
        nukes: 0,
        fireballs: 0,
        particles: 0,
        explodingUfoParts: 0,
        ufo: 0
    };
    let frameCounterForPerf = 0;
    let lastPerfStatsUpdateTime = 0; // When the perf stats were last *displayed*
    const PERF_UPDATE_INTERVAL = 5000; // Update every 5 seconds

    // Define target frame rate and duration for consistent movement
    const TARGET_FPS = 60;
    const TARGET_FRAME_DURATION = 1000 / TARGET_FPS; // Milliseconds per frame at target FPS
    const DEFENDER_LASER_SPEED_PX_PER_MS = 6.0; // Fixed speed for defender lasers (pixels per millisecond)

    const numInitialDefenders = 6; // Renamed from numInitialSatellites
    const numInitialAsteroids = 10;
    // Increased asteroid spawn interval for slower rate
    const asteroidSpawnInterval = 6000; // milliseconds (was 3000)
    const ufoSpawnInterval = 60000; // milliseconds (1 minute) - for a group of 3 UFOs
    let lastAsteroidSpawnTime = 0;
    let lastUfoSpawnTime = 0;

    const MIN_ASTEROID_SIZE = 25 * SCALE_FACTOR; // Minimum size before an asteroid vaporizes
    const MAX_ASTEROID_SIZE = 80 * SCALE_FACTOR;
    const ASTEROID_MAX_IRREGULARITY = 0.15; // Max irregularity factor used in generateIrregularPolygon (reduced for rounder asteroids)
    const ASTEROID_STROKE_WIDTH = 2 * SCALE_FACTOR; // Stroke width used for asteroid body

    // Hardcoded list of UFO words for message construction
    const ufoWords = [
      "Greetings", "We", "Observe", "Pattern", "Detected", "Existence", "Is", "Query", "Purpose",
      "Signal", "Received", "Unidentified", "Life", "Analyzing", "Data", "Hello", "World",
      "Unknown", "Vessel", "Probe", "Contact", "Approach", "Warning", "Peace", "Binary",
      "Source", "Destination", "Energy", "Flux", "Anomaly", "Presence", "Listen", "Speak",
      "Future", "Past", "Present", "Void", "Cosmos", "Star", "Planet", "System", "Galaxy",
      "Dimension", "Shift", "Truth", "Seek", "Connect", "Vibrate", "Echo", "Silence", "Light",
      "Darkness", "Journey", "Home", "Away", "Code", "Structure", "Form", "Essence", "Flow",
      "Stasis", "Rhythm", "Pulse", "Mind", "Spirit", "Matter", "Wave", "Particle", "Field",
      "Singularity", "Expansion", "Contraction", "Balance", "Chaos", "Order", "Dream", "Awake",
      "Perceive", "Understand", "Evolve", "Adapt", "Transcend", "Beyond", "Within", "Always",
      "Never", "Now", "Then", "Here", "There", "All", "None", "One", "Many", "Self", "Other",
      "Annihilate", "Conquer", "Dominate", "Exterminate", "Invade", "Subjugate", "Threat", "Warning",
      "Obliterate", "Vaporize", "Assimilate", "Resistance", "Futile", "Destroy", "Ruin", "Devour",
      "Consume", "Terror", "Fear", "Despair", "Doom", "Suffering", "Pain", "Death", "Chaos",
      "Dread", "Horror", "Menace", "Perish", "Crumble", "Collapse", "Eradicate", "Devastate",
      "Invasion", "Hostile", "Eliminate", "Subdue", "Vengeance", "Enslave", "Decimate", "Ravage",
      "Scourge", "Plague", "Raze", "Rend", "Shatter", "Crush",
      "Annihilation", "Conquest", "Domination", "Extinction", "Infiltrate", "Terminate", "Suffocate",
      "Devastation", "Rupture", "Raze", "Oblivion", "Desolation", "Wipeout", "Eradication", "Genocide",
      "Cataclysm", "Apocalypse", "Armageddon", "Doomsday", "Calamity", "Disaster", "Ruinous", "Destructive",
      "Malevolent", "Sinister", "Ominous", "Grim", "Dire", "Fatal", "Lethal", "Deadly", "Poison",
      "Corrupt", "Infect", "Contaminate", "Decay", "Rot", "Wither", "Fade", "Silence", "Darkness",
      "Void", "Empty", "Nothing", "End", "Final", "Last", "Zero", "Null", "Gone", "Lost", "Forgotten"
    ];

    // Global AudioContext and AudioBuffers for sounds
    let audioCtx;
    let audioContextInitialized = false; // Track if context has been created
    let audioContextResumed = false; // Track if context has been successfully resumed

    let laserBuffer;
    let userLaserBuffer;
    let explosionBuffer;
    let ufoBuffer;
    let nukeLaunchBuffer; // New: Nuke launch sound
    let nukeExplosionBuffer; // New: Nuke explosion sound
    let sparkSoundBuffer; // New: Sparking sound for hits
    let aggregationSoundBuffer; // New: Sound for particle aggregation

    function getAudioContext() {
        if (!audioContextInitialized) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioContextInitialized = true;
            // Attempt to resume immediately, but it might fail without user gesture
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    console.log('AudioContext resumed on init (if allowed by browser).');
                    audioContextResumed = true;
                }).catch(e => {
                    console.warn('AudioContext resume failed on init:', e);
                    // It's suspended, will need user gesture
                });
            } else {
                audioContextResumed = true; // Already running or started running
            }
        }
        return audioCtx;
    }

    // Global listener for first user interaction to resume audio context
    function resumeAudioContextOnFirstInteraction() {
        if (!audioContextResumed && audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => {
                console.log('AudioContext resumed by user gesture.');
                audioContextResumed = true;
                // Remove this listener once resumed
                document.body.removeEventListener('click', resumeAudioContextOnFirstInteraction);
                document.body.removeEventListener('touchstart', resumeAudioContextOnFirstInteraction);
            }).catch(e => {
                console.error('Failed to resume AudioContext on user gesture:', e);
            });
        }
    }

    // Add event listeners to the body to catch the first interaction
    document.body.addEventListener('click', resumeAudioContextOnFirstInteraction);
    document.body.addEventListener('touchstart', resumeAudioContextOnFirstInteraction);


    /**
     * Plays a sound with spatial positioning using Web Audio API.
     * @param {AudioBuffer} buffer - The AudioBuffer containing the sound data.
     * @param {number} sourceX - The X coordinate of the sound source on screen.
     * @param {number} [volume=1] - The volume of the sound (0 to 1).
     * @param {number} [pitchBend=1] - Multiplier for playback rate (1 for normal pitch).
     */
    function playSpatialSound(buffer, sourceX, volume = 1, pitchBend = 1) {
        if (isMuted || isPaused) return; // Do not play sound if muted or paused

        const ctx = getAudioContext();
        if (!buffer) {
            console.warn('Attempted to play sound but buffer is invalid.');
            return;
        }

        if (ctx.state !== 'running') {
            // If context is not running, try to resume it.
            // The nuke button click handler already attempts to resume the context.
            // If it's still suspended here, it means a user gesture hasn't fully activated it yet.
            // We'll let the next frame or user interaction handle the resume.
            console.warn('AudioContext not running, sound might not play immediately.');
            return;
        }

        const source = ctx.createBufferSource();
        source.buffer = buffer;
        source.playbackRate.value = pitchBend; // Apply pitch bend

        const panner = ctx.createPanner();
        panner.panningModel = 'HRTF'; // High-quality spatialization
        panner.distanceModel = 'linear';
        panner.refDistance = 1;
        panner.maxDistance = 10000;
        panner.rolloffFactor = 1;

        // Ensure width is not zero to prevent division by zero or NaN
        const currentWidth = width > 0 ? width : 1; // Use 1 if width is 0 to prevent division by zero

        // Map screen X (0 to width) to panner X (-1 to 1)
        // Listener is at (0, 0, 0). Source X is relative to listener.
        // Screen left (0) -> panner X -1
        // Screen right (width) -> panner X 1
        // Screen center (width/2) -> panner X 0
        const pannerX = (sourceX / currentWidth) * 2 - 1;
        panner.positionX.setValueAtTime(pannerX, ctx.currentTime);
        panner.positionY.setValueAtTime(0, ctx.currentTime); // Keep Y at 0 for side-to-side panning
        panner.positionZ.setValueAtTime(-0.5, ctx.currentTime); // Slightly behind the listener for a subtle 3D effect

        const gainNode = ctx.createGain();
        gainNode.gain.setValueAtTime(volume, ctx.currentTime);

        source.connect(panner);
        panner.connect(gainNode);
        gainNode.connect(ctx.destination);

        source.start(0); // Play immediately
        source.onended = () => {
            source.disconnect();
            panner.disconnect();
            gainNode.disconnect();
        };
    }


    // --- Quality Control Settings ---
    const qualityLevels = ['high', 'medium', 'low'];
    let currentQualityIndex = 0; // Index for qualityLevels array
    let currentQualityLevel = qualityLevels[currentQualityIndex];

    const qualitySettings = {
      'high': {
        starCount: 300, // Reverted to original star count
        asteroidNumParticles: 15,
        sparkNumParticles: 8,
        asteroidCrackSegments: [5, 10],
        asteroidCrackSizeFactor: [0.1, 0.5],
        defenderFireInterval: [300, 1000],
        laserLifeDefender: 200 * TARGET_FRAME_DURATION,
        laserTransitionDuration: '0.1s',
        laserGradient: true,
        laserShadow: true,
        ufoCrackSegments: [2, 5],
        ufoCrackSizeFactor: [0.05, 0.2],
        ufoMessageTransparency: true,
        ufoMessageShadow: true,
        ufoMessageTransition: '3s ease-in-out',
        crackFinalOpacity: 0.7,
        particleAggregationGridSize: 50,
        particleAggregationThreshold: 8,
        aggregatedParticleEffectSize: 40,
        aggregatedParticleEffectDuration: 600
      },
      'medium': {
        starCount: 150, // Reverted to original star count
        asteroidNumParticles: 8,
        sparkNumParticles: 5,
        asteroidCrackSegments: [2, 4],
        asteroidCrackSizeFactor: [0.08, 0.25],
        defenderFireInterval: [500, 1500],
        laserLifeDefender: 150 * TARGET_FRAME_DURATION,
        laserTransitionDuration: '0.05s',
        laserGradient: true,
        laserShadow: true,
        ufoCrackSegments: [1, 3],
        ufoCrackSizeFactor: [0.04, 0.15],
        ufoMessageTransparency: true,
        ufoMessageShadow: true,
        ufoMessageTransition: '2s ease-in-out',
        crackFinalOpacity: 0.8,
        particleAggregationGridSize: 70,
        particleAggregationThreshold: 6,
        aggregatedParticleEffectSize: 30,
        aggregatedParticleEffectDuration: 500
      },
      'low': {
        starCount: 50, // Reverted to original star count
        asteroidNumParticles: 2,
        sparkNumParticles: 1,
        asteroidCrackSegments: [1, 2],
        asteroidCrackSizeFactor: [0.05, 0.2],
        defenderFireInterval: [800, 2000],
        laserLifeDefender: 100 * TARGET_FRAME_DURATION,
        laserTransitionDuration: '0s',
        laserGradient: false,
        laserShadow: false,
        ufoCrackSegments: [1, 2],
        ufoCrackSizeFactor: [0.03, 0.1],
        ufoMessageTransparency: false,
        ufoMessageShadow: false,
        ufoMessageTransition: '0s',
        crackFinalOpacity: 1,
        particleAggregationGridSize: 100,
        particleAggregationThreshold: 4,
        aggregatedParticleEffectSize: 20,
        aggregatedParticleEffectDuration: 400
      }
    };

    /**
     * Applies the current rendering quality settings to relevant game elements.
     */
    function applyQualitySettings() {
      const settings = qualitySettings[currentQualityLevel];

      // Reinitialize stars with new count
      initStars(); // Call initStars to handle star count and opacity updates

      // Update defender fire intervals
      defenders.forEach(defender => {
        defender.fireInterval = random(settings.defenderFireInterval[0], settings.defenderFireInterval[1]);
      });
    }

    /**
     * Cycles through the rendering quality levels.
     */
    function cycleQuality() {
      currentQualityIndex = (currentQualityIndex + 1) % qualityLevels.length;
      currentQualityLevel = qualityLevels[currentQualityIndex];
      qualityToggleBtn.textContent = `Quality: ${currentQualityLevel.charAt(0).toUpperCase() + currentQualityLevel.slice(1)}`;
      applyQualitySettings();
    }

    /**
     * Toggles the mute state of the audio context.
     */
    function toggleMute() {
        const ctx = getAudioContext();
        if (ctx.state === 'running') {
            ctx.suspend();
            isMuted = true;
            muteToggleBtn.textContent = 'Mute: On';
        } else if (ctx.state === 'suspended') {
            ctx.resume();
            isMuted = false;
            muteToggleBtn.textContent = 'Mute: Off';
        }
    }

    /**
     * Toggles the pause state of the game.
     */
    function togglePause() {
        isPaused = !isPaused;
        pauseToggleBtn.textContent = `Pause: ${isPaused ? 'On' : 'Off'}`;
        const ctx = getAudioContext();
        if (isPaused) {
            if (ctx.state === 'running') {
                ctx.suspend();
            }
        } else {
            if (ctx.state === 'suspended' && !isMuted) { // Only resume if not globally muted
                ctx.resume();
            }
        }
    }

    /**
     * Updates the date and time display.
     */
    function updateDateTimeDisplay() {
        if (!dateTimeDisplay) return; // Ensure element exists

        const now = new Date();
        const dateOptions = { year: 'numeric', month: 'short', day: 'numeric' };
        const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true }; // Changed to AM/PM format

        const dateStr = now.toLocaleDateString(undefined, dateOptions);
        const timeStr = now.toLocaleTimeString(undefined, timeOptions);

        dateTimeDisplay.innerHTML = `${dateStr}<br>${timeStr}`;
    }


    /**
     * Toggles the visibility of the performance stats display.
     */
    /**
     * Toggles the visibility of the date/time display.
     */
    function toggleDateTimeDisplay() {
        isDateTimeVisible = !isDateTimeVisible;
        dateTimeToggleBtn.textContent = `Date/Time: ${isDateTimeVisible ? 'On' : 'Off'}`;
        dateTimeDisplay.style.display = isDateTimeVisible ? 'block' : 'none';
    }

    /**
     * Toggles the visibility of the performance stats display.
     */
    function togglePerfStatsDisplay() {
        isPerfStatsVisible = !isPerfStatsVisible;
        perfStatsToggleBtn.textContent = `Perf Stats: ${isPerfStatsVisible ? 'On' : 'Off'}`;
        perfStatsDiv.style.display = isPerfStatsVisible ? 'block' : 'none';
    }

    // --- Utility Functions ---
    /**
     * Generates a random number within a specified range.
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (exclusive).
     * @returns {number} A random number.
     */
    function random(min, max) {
      return Math.random() * (max - min) + min;
    }

    /**
     * Creates an SVG element with the given tag name.
     * @param {string} tag - The SVG tag name (e.g., 'circle', 'polygon').
     * @returns {SVGElement} The created SVG element.
     */
    function createSVGElement(tag) {
      return document.createElementNS("http://www.w3.org/2000/svg", tag);
    }

    /**
     * Generates a random HSL linear gradient and appends it to the SVG defs.
     * @returns {string} The ID of the newly created gradient.
     */
    function generateRandomUfoGradient() {
        const gradientId = `ufoGradient-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const gradient = createSVGElement('linearGradient');
        gradient.setAttribute('id', gradientId);
        gradient.setAttribute('x1', '0%');
        gradient.setAttribute('y1', '0%');
        gradient.setAttribute('x2', '100%');
        gradient.setAttribute('y2', '100%'); // Diagonal gradient

        // Random base hue for the UFO (e.g., blue, purple, green, grey-blue)
        const baseHue = random(180, 300); // Range for blues, purples, magentas
        const saturation = random(50, 90); // High saturation
        const lightnessStart = random(30, 60); // Darker start
        const lightnessEnd = random(10, 30); // Even darker end

        // Stop 1: Lighter color
        const stop1 = createSVGElement('stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', `hsl(${baseHue}, ${saturation}%, ${lightnessStart}%)`);
        gradient.appendChild(stop1);

        // Stop 2: Darker color
        const stop2 = createSVGElement('stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', `hsl(${baseHue}, ${saturation}%, ${lightnessEnd}%)`);
        gradient.appendChild(stop2);

        canvas.querySelector('defs').appendChild(gradient);
        return gradientId;
    }

    /**
     * Processes the UFO message queue, making UFOs speak in sequence.
     */
    function processUfoMessageQueue() {
        if (currentSpeakingUFO) {
            // A UFO is currently speaking, wait for it to finish
            return;
        }

        if (ufoMessageQueue.length > 0) {
            currentSpeakingUFO = ufoMessageQueue.shift(); // Get the next UFO from the queue
            if (currentSpeakingUFO && currentSpeakingUFO.displayMessage) {
                currentSpeakingUFO.displayMessage(() => {
                    // Callback when the UFO finishes speaking
                    currentSpeakingUFO = null; // Clear the current speaking UFO
                    processUfoMessageQueue(); // Process the next in queue
                });
            } else {
                // If for some reason the UFO or its displayMessage method is invalid,
                // clear it and try the next one.
                currentSpeakingUFO = null;
                processUfoMessageQueue();
            }
        }
    }

    /**
     * Aggregates overlapping particles into larger visual effects.
     * Uses a grid-based approach to find clusters of particles.
     */
    function aggregateParticles() {
        const settings = qualitySettings[currentQualityLevel];
        if (settings.particleAggregationThreshold <= 1) return; // Aggregation disabled or not meaningful

        const gridSize = settings.particleAggregationGridSize;
        const particleGrid = new Map(); // Map: "x_y" -> [particle1, particle2, ...]

        // Populate the grid with active particles
        for (const particle of activeParticles) {
            const gridX = Math.floor(particle.x / gridSize);
            const gridY = Math.floor(particle.y / gridSize);
            const key = `${gridX}_${gridY}`;

            if (!particleGrid.has(key)) {
                particleGrid.set(key, []);
            }
            particleGrid.get(key).push(particle);
        }

        const particlesToRemove = new Set();
        const newFireballsToSpawn = [];

        // Process cells for aggregation
        for (const [key, particlesInCell] of particleGrid.entries()) {
            if (particlesInCell.length >= settings.particleAggregationThreshold) {
                let sumX = 0;
                let sumY = 0;
                
                // Calculate average position and mark particles for removal
                particlesInCell.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                    particlesToRemove.add(p);
                });
                const avgX = sumX / particlesInCell.length;
                const avgY = sumY / particlesInCell.length;

                newFireballsToSpawn.push({ x: avgX, y: avgY });
            }
        }

        // Perform removals from activeParticles array and return to pool
        for (let i = activeParticles.length - 1; i >= 0; i--) {
            const particle = activeParticles[i];
            if (particlesToRemove.has(particle)) {
                particle.remove(); // This also returns the element to the pool
                activeParticles.splice(i, 1); // Remove from active list
            }
        }

        // Spawn new fireball effects for aggregated clusters
        newFireballsToSpawn.forEach(coords => {
            let fireball = fireballPool.pop();
            if (!fireball) {
                fireball = new FireballEffect();
            }
            fireball.reset(coords.x, coords.y, settings.aggregatedParticleEffectSize, settings.aggregatedParticleEffectDuration, 'visual');
            activeFireballs.push(fireball);
            playSpatialSound(aggregationSoundBuffer, coords.x, 0.5); // Play subtle sound
        });
    }

    /**
     * Generates a base64 encoded WAV audio data URI for a frequency sweep.
     * @param {number} durationMs - Duration of the sound in milliseconds.
     * @param {number} startFreqHz - Starting frequency in Hz.
     * @param {number} endFreqHz - Ending frequency in Hz.
     * @returns {string} Data URI for the WAV audio.
     */
    function generateToneSweep(durationMs, startFreqHz, endFreqHz) {
      const sampleRate = 44100; // samples per second
      const numSamples = Math.floor(sampleRate * (durationMs / 1000));
      const buffer = new Float32Array(numSamples);

      for (let i = 0; i < numSamples; i++) {
        const t = i / sampleRate;
        const freq = startFreqHz + (endFreqHz - startFreqHz) * (i / numSamples);
        buffer[i] = Math.sin(2 * Math.PI * freq * t) * 0.5; // 0.5 amplitude
      }

      // Convert Float32Array to WAV format
      const wav = encodeWAV(buffer, sampleRate);
      return 'data:audio/wav;base64,' + btoa(wav);
    }


    /**
     * Generates a base64 encoded WAV audio data URI for a frequency sweep with harmonic chord components.
     * @param {number} durationMs - Duration of the sound in milliseconds.
     * @param {number} startFreqHz - Starting frequency in Hz.
     * @param {number} endFreqHz - Ending frequency in Hz.
     * @param {Array<number>} harmonics - Array of harmonic multipliers (e.g., [1, 1.25, 1.5] for a major chord).
     * @param {number} [amplitude=0.5] - Overall amplitude.
     * @returns {string} Data URI for the WAV audio.
     */
    function generateHarmonicToneSweep(durationMs, startFreqHz, endFreqHz, harmonics, amplitude = 0.5) {
        const sampleRate = 44100; // samples per second
        const numSamples = Math.floor(sampleRate * (durationMs / 1000));
        const buffer = new Float32Array(numSamples);

        for (let i = 0; i < numSamples; i++) {
            const t = i / sampleRate;
            const freq = startFreqHz + (endFreqHz - startFreqHz) * (i / numSamples);
            let sample = 0;

            harmonics.forEach(harmonic => {
                sample += Math.sin(2 * Math.PI * (freq * harmonic) * t) * (amplitude / harmonics.length);
            });
            buffer[i] = sample;
        }

        const wav = encodeWAV(buffer, sampleRate);
        return 'data:audio/wav;base64,' + btoa(wav);
    }


    /**
     * Generates a base64 encoded WAV audio data URI for a short burst of noise with decaying amplitude.
     * This simulates a white noise from medium to lower frequency, like an explosion.
     * @param {number} durationMs - Duration of the sound in milliseconds.
     * @param {number} [decayPower=2] - Power for the exponential amplitude decay (higher = faster decay).
     * @returns {string} Data URI for the WAV audio.
     */
    function generateNoiseBurst(durationMs, decayPower = 2) {
      const sampleRate = 44100;
      const numSamples = Math.floor(sampleRate * (durationMs / 1000));
      const buffer = new Float32Array(numSamples);

      for (let i = 0; i < numSamples; i++) {
        const t = i / numSamples; // Normalized time from 0 to 1
        let amplitude = 1 - t; // Linear decay from 1 to 0
        amplitude = Math.pow(amplitude, decayPower); // Exponential decay controlled by decayPower

        buffer[i] = (Math.random() * 2 - 1) * 0.5 * amplitude; // White noise, decaying amplitude
      }

      const wav = encodeWAV(buffer, sampleRate);
      return 'data:audio/wav;base64,' + btoa(wav);
    }

    /**
     * Generates a base64 encoded WAV audio data URI for a short, high-frequency sparking noise.
     * @param {number} durationMs - Duration of the sound in milliseconds.
     * @returns {string} Data URI for the WAV audio.
     */
    function generateSparkSound(durationMs) {
        const sampleRate = 44100;
        const numSamples = Math.floor(sampleRate * (durationMs / 1000));
        const buffer = new Float32Array(numSamples);

        for (let i = 0; i < numSamples; i++) {
            const t = i / numSamples; // Normalized time from 0 to 1
            let amplitude = 1 - t; // Linear decay from 1 to 0
            amplitude = Math.pow(amplitude, 4); // Faster exponential decay for a sharper fizz

            // High-frequency noise
            buffer[i] = (Math.random() * 2 - 1) * 0.3 * amplitude; // Reduced amplitude
        }

        const wav = encodeWAV(buffer, sampleRate);
        return 'data:audio/wav;base64,' + btoa(wav);
    }

    /**
     * Generates a base64 encoded WAV audio data URI for a subtle, low hum.
     * @param {number} durationMs - Duration of the sound in milliseconds.
     * @param {number} freqHz - Frequency of the hum in Hz.
     * @returns {string} Data URI for the WAV audio.
     */
    function generateHum(durationMs, freqHz) {
      const sampleRate = 44100;
      const numSamples = Math.floor(sampleRate * (durationMs / 1000));
      const buffer = new Float32Array(numSamples);

      for (let i = 0; i < numSamples; i++) {
        const t = i / sampleRate;
        buffer[i] = Math.sin(2 * Math.PI * freqHz * t) * 0.2; // Low amplitude sine wave
      }

      const wav = encodeWAV(buffer, sampleRate);
      return 'data:audio/wav;base64,' + btoa(wav);
    }

    /**
     * Encodes a Float32Array audio buffer into a WAV format string.
     * @param {Float32Array} samples - Audio samples.
     * @param {number} sampleRate - Sample rate.
     * @returns {string} WAV formatted string.
     */
    function encodeWAV(samples, sampleRate) {
      const dataLength = samples.length * 2; // 16-bit PCM
      const buffer = new ArrayBuffer(44 + dataLength);
      const view = new DataView(buffer);

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      let offset = 0;
      /* RIFF identifier */
      writeString(view, offset, 'RIFF'); offset += 4;
      /* file length */
      view.setUint32(offset, 36 + dataLength, true); offset += 4;
      /* RIFF type */
      writeString(view, offset, 'WAVE'); offset += 4;
      /* format chunk identifier */
      writeString(view, offset, 'fmt '); offset += 4;
      /* format chunk length */
      view.setUint32(offset, 16, true); offset += 4;
      /* sample format (1 == PCM) */
      view.setUint16(offset, 1, true); offset += 2;
      /* channel count */
      view.setUint16(offset, 1, true); offset += 2;
      /* sample rate */
      view.setUint32(offset, sampleRate, true); offset += 4;
      /* byte rate (sampleRate * blockAlign) */
      view.setUint32(offset, sampleRate * 2, true); offset += 4;
      /* block align (channels * bytes per sample) */
      view.setUint16(offset, 2, true); offset += 2;
      /* bits per sample */
      view.setUint16(offset, 16, true); offset += 2;
      /* data chunk identifier */
      writeString(view, offset, 'data'); offset += 4;
      /* data chunk length */
      view.setUint32(offset, dataLength, true); offset += 4;

      // Write samples
      for (let i = 0; i < samples.length; i++) {
        let s = Math.max(-1, Math.min(1, samples[i]));
        s = s < 0 ? s * 0x8000 : s * 0x7FFF; // Convert to 16-bit PCM
        view.setInt16(offset, s, true);
        offset += 2;
      }

      return String.fromCharCode.apply(null, new Uint8Array(buffer));
    }

    /**
     * Plays a robotic-sounding voice for the given text using Web Audio API.
     * @param {string} text - The text to "speak".
     * @param {number} durationPerChar - Duration for each character's sound in ms.
     */
    function speakRoboticText(text, durationPerChar = 80) {
        if (isMuted || isPaused) return; // Do not play sound if muted or paused

        const ctx = getAudioContext();
        if (ctx.state !== 'running') { // Ensure context is running before attempting to play
            console.warn('Attempted to speak robotic text but AudioContext is not running.');
            return;
        }

        const words = text.split(/\s+/); // Split by whitespace to handle words
        let delay = 0;

        words.forEach((word) => {
            if (word.length === 0) {
                delay += durationPerChar * 2; // Longer pause for multiple spaces
                return;
            }

            // Generate a sound for each word or a segment of the word
            for (let i = 0; i < word.length; i++) {
                const char = word[i];
                if (char === '.' || char === ',' || char === '!' || char === '?') {
                    delay += durationPerChar * 1.5; // Longer pause for punctuation
                    continue;
                }

                setTimeout(() => {
                    const baseFreq = random(150, 900); // Base frequency for the chord (increased range for more variation)
                    const frequencies = [
                        baseFreq,              // Root
                        baseFreq * 1.25,       // Major Third (approx. 5/4 ratio)
                        baseFreq * 1.5         // Perfect Fifth (approx. 3/2 ratio)
                    ];

                    const gainNode = ctx.createGain();
                    gainNode.connect(ctx.destination);
                    gainNode.gain.setValueAtTime(0.6, ctx.currentTime); // Start volume (increased for loudness)
                    gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + (durationPerChar / 1000) * 0.8);

                    frequencies.forEach(freq => {
                        const oscillator = ctx.createOscillator();
                        oscillator.type = 'square'; // Square wave for robotic effect
                        oscillator.frequency.setValueAtTime(freq, ctx.currentTime);
                        oscillator.connect(gainNode);
                        oscillator.start(ctx.currentTime);
                        oscillator.stop(ctx.currentTime + (durationPerChar / 1000));
                    });
                }, delay);

                delay += durationPerChar;
            }
            delay += durationPerChar; // Small pause between words
        });
    }

    /**
     * Destroys all asteroids and the UFO within a given radius.
     * @param {number} centerX - The X coordinate of the center of the blast.
     * @param {number} centerY - The Y coordinate of the center of the blast.
     * @param {number} radius - The radius of the blast.
     */
    function destroyObjectsInRadius(centerX, centerY, radius, isNukeHit = false) {
        // Destroy UFOs if within radius
        for (let i = ufos.length - 1; i >= 0; i--) {
            const currentUfo = ufos[i];
            if (Math.hypot(currentUfo.x - centerX, currentUfo.y - centerY) < radius + currentUfo.size) {
                currentUfo.health = 0; // Ensure it's destroyed
                currentUfo.destroy(isNukeHit); // Pass isNukeHit to UFO destroy
            }
        }

        // Destroy asteroids within radius
        for (let i = asteroids.length - 1; i >= 0; i--) {
            const asteroid = asteroids[i];
            if (Math.hypot(asteroid.x - centerX, asteroid.y - centerY) < radius + asteroid.size) {
                asteroid.health = 0; // Ensure it's destroyed
                asteroid.destroy(isNukeHit); // Pass isNukeHit to asteroid destroy
            }
        }
    }

    // --- Game Objects ---


    /**
     * Represents a star in the background (SVG circle based).
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} size - Radius of the star.
     * @param {SVGElement} [element=null] - Optional existing SVG element to reuse.
     */
    class Star {
      constructor(x, y, size, element = null) {
        this.x = x;
        this.y = y;
        this.size = size * SCALE_FACTOR; // This will be the radius for SVG circle
        this.element = element || createSVGElement('circle'); // Use createSVGElement
        this.element.setAttribute('class', 'star'); // Set SVG attribute
        this.element.setAttribute('r', this.size / 2); // Set radius
        this.element.style.display = ''; // Ensure visible if reused
        
        // Set initial color
        this.updateColor(); 
        
        // Initial position (will be updated by update() method)
        this.element.setAttribute('cx', this.x); // Set cx
        this.element.setAttribute('cy', this.y); // Set cy

        if (!element) { // Only append if new element
            starsLayer.appendChild(this.element); // Append to starsLayer (SVG group)
        }
      }

      update(deltaTime) {
        this.x += starfieldVx * deltaTime;
        this.y += starfieldVy * deltaTime;

        // Wrapping logic for all directions
        // Use this.size (radius) for boundary checks
        if (starfieldVx > 0 && this.x > width + this.size / 2) { // Moving right, off right edge
            this.x = -this.size / 2;
            this.y = random(0, height);
        } else if (starfieldVx < 0 && this.x < -this.size / 2) { // Moving left, off left edge
            this.x = width + this.size / 2;
            this.y = random(0, height);
        }

        if (starfieldVy > 0 && this.y > height + this.size / 2) { // Moving down, off bottom edge
            this.y = -this.size / 2;
            this.x = random(0, width); // New X when wrapping vertically
        } else if (starfieldVy < 0 && this.y < -this.size / 2) { // Moving up, off top edge
            this.y = height + this.size / 2;
            this.x = random(0, width); // New X when wrapping vertically
        }

        // Update SVG attributes for positioning
        this.element.setAttribute('cx', this.x);
        this.element.setAttribute('cy', this.y);
      }

      updateColor() {
        const hue = random(200, 240);
        const saturation = random(5, 15);
        const lightness = random(90, 100);
        this.element.setAttribute('fill', `hsl(${hue}, ${saturation}%, ${lightness}%)`); // Set SVG fill attribute
      }

      hide() {
        this.element.style.display = 'none';
      }

      show() {
        this.element.style.display = '';
      }

      remove() {
        if (this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
      }
    }

    /**
     * Represents a defender.
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     */
    class Defender { // Renamed from Satellite
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = random(25, 40) * SCALE_FACTOR; // Slightly larger size for more distinct shape
        // Convert velocities to per-millisecond for delta time scaling
        this.vx = 0; // Initial velocity X (will be controlled by AI)
        this.vy = 0; // Initial velocity Y (will be controlled by AI)
        this.rotation = random(0, 360); // Initial rotation
        this.vRotation = 0; // Initial rotational velocity (will be controlled by AI)
        
        const settings = qualitySettings[currentQualityLevel];
        this.fireInterval = random(settings.defenderFireInterval[0], settings.defenderFireInterval[1]); // Renamed from satelliteFireInterval
        this.lastFireTime = Date.now() + random(0, this.fireInterval); // Stagger initial firing

        this.thrustForce = 0.005 / TARGET_FRAME_DURATION; // Acceleration per frame
        this.rotationForce = 0.05 / TARGET_FRAME_DURATION; // Increased rotational acceleration per frame (more aggressive)
        this.maxSpeed = 3.0 / TARGET_FRAME_DURATION; // Max linear speed
        this.maxRotationSpeed = 0.5 / TARGET_FRAME_DURATION; // Max rotational speed

        this.thrustCooldown = 500; // Cooldown for main thruster (ms)
        this.rcsCooldown = 100; // Minimum time between RCS impulses (ms)
        this.lastThrustTime = 0; // When main thrust was last *activated*
        this.lastRcsImpulseTime = 0; // When the last RCS impulse was applied

        this.isThrusting = false; // Is the main thruster currently active?
        this.thrustOnDuration = 1000 * SCALE_FACTOR; // How long main thruster stays on (ms)
        this.thrustOffDuration = 1000 * SCALE_FACTOR; // How long main thruster stays off (ms) - Reduced for more frequent thrusting
        this.lastThrustToggleTime = 0; // When thrust state last changed (on to off, or off to on)

        this.roamingTargetX = random(width * 0.2, width * 0.8); // Initial roaming target
        this.roamingTargetY = random(height * 0.2, height * 0.8);
        this.roamingTargetReachedThreshold = this.size * 10 * SCALE_FACTOR; // Distance to consider target reached

        this.element = createSVGElement('g'); // Group for defender parts
        this.element.setAttribute('class', 'defender'); // Renamed class
        gameplayLayer.appendChild(this.element); // Append to gameplay layer

        this.mainThrusterLeftElement = null; // Will hold the SVG element for left main thruster fire
        this.mainThrusterRightElement = null; // Will hold the SVG element for right main thruster fire
        this.rcsLeftElement = null; // Will hold the SVG element for left RCS fire
        this.rcsRightElement = null; // Will hold the SVG element for right RCS fire

        this.drawDefender(); // Initial drawing, renamed from drawSatellite

        this.target = null; // Current target (asteroid or UFO) for firing
      }

      /**
       * Generates points for a symmetrical polygon, typically for UFO parts.
       * The shape is generated for the right half (positive X) and then mirrored to the left (negative X).
       * @param {number} numSegments - Number of segments for one half of the shape (e.g., 3 segments means 4 points).
       * @param {number} irregularity - How much points deviate from a smooth curve (0-1).
       * @param {number} baseWidth - The approximate maximum width of the shape.
       * @param {number} baseHeight - The approximate maximum height of the shape.
       * @param {number} [offsetX=0] - Horizontal offset from the UFO's center.
       * @param {number} [offsetY=0] - Vertical offset from the UFO's center.
       * @param {number} [rotationDegrees=0] - Rotation of the entire shape around its own center.
       * @returns {string} SVG points string.
       */
      generateSymmetricalShapePoints(numSegments, irregularity, baseWidth, baseHeight, offsetX = 0, offsetY = 0, rotationDegrees = 0) {
        let rightHalfPoints = [];
        // Generate random offsets for each segment point *once* to ensure perfect symmetry
        const xOffsets = Array.from({length: numSegments + 1}, () => random(-irregularity, irregularity));
        const yOffsets = Array.from({length: numSegments + 1}, () => random(-irregularity * 0.5, irregularity * 0.5)); // Less y irregularity

        // Generate points for the right half, from top to bottom
        for (let i = 0; i <= numSegments; i++) {
          const progress = i / numSegments; // Progress from 0 to 1 along the height
          
          // Use a sine wave for width variation to create a "waist" or "bulge" effect
          // This makes the shape more organic and less boxy.
          const currentWidthFactor = Math.sin(progress * Math.PI); // 0 at top/bottom, 1 in middle
          const currentWidth = (baseWidth / 2) * (0.2 + 0.8 * currentWidthFactor); // Min width 20% of max, max 100%
          
          const x = currentWidth * (1 + xOffsets[i]); // Use pre-generated offset for X
          const y = (progress - 0.5) * baseHeight * (1 + yOffsets[i]); // Use pre-generated offset for Y

          rightHalfPoints.push({ x: x, y: y });
        }

        let allPoints = [];
        // Add points for the right side (top to bottom)
        for (let i = 0; i < rightHalfPoints.length; i++) {
          allPoints.push(rightHalfPoints[i]);
        }
        // Add points for the left side (bottom to top, mirrored X)
        for (let i = rightHalfPoints.length - 1; i >= 0; i--) {
          allPoints.push({ x: -rightHalfPoints[i].x, y: rightHalfPoints[i].y });
        }

        // Apply rotation and offset to all points
        const radRotation = rotationDegrees * Math.PI / 180;
        const transformedPoints = allPoints.map(p => {
          const rotatedX = p.x * Math.cos(radRotation) - p.y * Math.sin(radRotation);
          const rotatedY = p.x * Math.sin(radRotation) + p.y * Math.cos(radRotation);
          return `${rotatedX + offsetX},${rotatedY + offsetY}`;
        });

        return transformedPoints.join(' ');
      }

      /**
       * Draws the defender's SVG elements (A-shaped with polygonal details).
       */
      drawDefender() {
        // Clear existing parts
        while (this.element.firstChild) {
          this.element.removeChild(this.element.firstChild);
        }

        // Main A-shaped body
        const bodyWidth = this.size * random(1.0, 1.2) * SCALE_FACTOR;
        const bodyHeight = this.size * random(1.5, 1.8) * SCALE_FACTOR;
        const tipY = -bodyHeight / 2;
        const baseY = bodyHeight / 2;
        const baseWidth = bodyWidth;
        const midHeight = bodyHeight * random(0.2, 0.4); // For the inner V-cut

        // Points for a more distinct 'A' shape
        const bodyPoints = [
          `0,${tipY}`, // Top point
          `${baseWidth / 2},${baseY}`, // Bottom right
          `${baseWidth / 2 * random(0.4, 0.6)},${midHeight}`, // Inner right point
          `${-baseWidth / 2 * random(0.4, 0.6)},${midHeight}`, // Inner left point
          `${-baseWidth / 2},${baseY}` // Bottom left
        ].join(' ');

        const body = createSVGElement('polygon');
        body.setAttribute('points', bodyPoints);
        body.setAttribute('fill', 'url(#defenderGradient)'); // Apply gradient fill
        body.removeAttribute('stroke'); // Remove stroke for a cleaner gradient look
        body.removeAttribute('stroke-width'); // Remove stroke-width
        this.element.appendChild(body);

        // Central polygonal "cockpit" or sensor array
        const cockpitSize = this.size * random(0.2, 0.3) * SCALE_FACTOR;
        const cockpitPoints = [
          `0,${-cockpitSize * 0.8}`,
          `${cockpitSize * 0.5},${-cockpitSize * 0.4}`,
          `${cockpitSize * 0.5},${cockpitSize * 0.4}`,
          `0,${cockpitSize * 0.8}`,
          `${-cockpitSize * 0.5},${cockpitSize * 0.4}`,
          `${-cockpitSize * 0.5},${-cockpitSize * 0.4}`
        ].join(' '); // Hexagon or diamond-like shape

        const cockpit = createSVGElement('polygon');
        cockpit.setAttribute('points', cockpitPoints);
        cockpit.setAttribute('fill', '#a9a9a9'); // Dark grey
        cockpit.removeAttribute('stroke'); // Remove stroke
        cockpit.removeAttribute('stroke-width'); // Remove stroke-width
        this.element.appendChild(cockpit);

        // Polygonal thruster exhausts (two symmetrical shapes at the back)
        const thrusterWidth = this.size * random(0.2, 0.3) * SCALE_FACTOR;
        const thrusterHeight = this.size * random(0.1, 0.15) * SCALE_FACTOR;
        const thrusterOffset = this.size * random(0.3, 0.4) * SCALE_FACTOR; // Distance from center

        // Left thruster
        const thruster1Points = [
          `${-thrusterOffset},${baseY - thrusterHeight * 0.5}`,
          `${-thrusterOffset - thrusterWidth * 0.5},${baseY + thrusterHeight * 0.5}`,
          `${-thrusterOffset + thrusterWidth * 0.5},${baseY + thrusterHeight * 0.5}`
        ].join(' '); // Simple triangle

        const thruster1 = createSVGElement('polygon');
        thruster1.setAttribute('points', thruster1Points);
        thruster1.setAttribute('fill', 'url(#defenderThrusterPodGradient)'); // Apply new gradient
        thruster1.removeAttribute('stroke'); // Remove stroke
        thruster1.removeAttribute('stroke-width'); // Remove stroke-width
        this.element.appendChild(thruster1);

        // Right thruster (mirrored)
        const thruster2Points = [
          `${thrusterOffset},${baseY - thrusterHeight * 0.5}`,
          `${thrusterOffset + thrusterWidth * 0.5},${baseY + thrusterHeight * 0.5}`,
          `${thrusterOffset - thrusterWidth * 0.5},${baseY + thrusterHeight * 0.5}`
        ].join(' '); // Simple triangle

        const thruster2 = createSVGElement('polygon');
        thruster2.setAttribute('points', thruster2Points);
        thruster2.setAttribute('fill', 'url(#defenderThrusterPodGradient)'); // Apply new gradient
        thruster2.removeAttribute('stroke'); // Remove stroke
        thruster2.removeAttribute('stroke-width'); // Remove stroke-width
        this.element.appendChild(thruster2);

        // --- Main Thruster Fire (Two Triangular, behind each thruster) ---
        const fireLength = this.size * 1.5 * SCALE_FACTOR; // Length of the fire effect
        const fireWidth = this.size * 0.8 * SCALE_FACTOR; // Width of the fire effect at its base
        const fireOffset = baseY + thrusterHeight * 0.5; // Position behind the thrusters

        // Left Main Thruster Fire
        this.mainThrusterLeftElement = createSVGElement('polygon');
        // Points relative to the left thruster's base
        this.mainThrusterLeftElement.setAttribute('points', `${-thrusterOffset},${fireOffset} ${-thrusterOffset + fireWidth / 2},${fireOffset + fireLength} ${-thrusterOffset - fireWidth / 2},${fireOffset + fireLength}`);
        this.mainThrusterLeftElement.setAttribute('fill', 'url(#mainThrusterFireGradient)');
        this.mainThrusterLeftElement.style.display = 'none'; // Hidden by default
        this.element.appendChild(this.mainThrusterLeftElement);

        // Right Main Thruster Fire
        this.mainThrusterRightElement = createSVGElement('polygon');
        // Points relative to the right thruster's base
        this.mainThrusterRightElement.setAttribute('points', `${thrusterOffset},${fireOffset} ${thrusterOffset + fireWidth / 2},${fireOffset + fireLength} ${thrusterOffset - fireWidth / 2},${fireOffset + fireLength}`);
        this.mainThrusterRightElement.setAttribute('fill', 'url(#mainThrusterFireGradient)');
        this.mainThrusterRightElement.style.display = 'none'; // Hidden by default
        this.element.appendChild(this.mainThrusterRightElement);

        // --- RCS Thruster Fire (Triangular) ---
        const rcsSize = this.size * 0.3 * SCALE_FACTOR; // Increased size for bigger triangles
        // Position RCS thrusters closer to the top of the A-shape, on the "shoulders"
        const rcsOffsetFrontX = baseWidth / 2 * random(0.5, 0.7); // Closer to the center line
        const rcsOffsetFrontY = tipY + this.size * random(0.1, 0.3) * SCALE_FACTOR; // Slightly below the tip

        // Left RCS Thruster Fire (Triangular)
        this.rcsLeftElement = createSVGElement('polygon');
        // Points for a triangle pointing right (inwards) from its base
        const rcsLeftPoints = [
          `${-rcsOffsetFrontX},${rcsOffsetFrontY - rcsSize / 2}`,
          `${-rcsOffsetFrontX},${rcsOffsetFrontY + rcsSize / 2}`,
          `${-rcsOffsetFrontX + rcsSize},${rcsOffsetFrontY}` // Tip points inwards (right)
        ].join(' ');
        this.rcsLeftElement.setAttribute('points', rcsLeftPoints);
        this.rcsLeftElement.setAttribute('fill', 'url(#rcsThrusterFireGradient)');
        this.rcsLeftElement.style.display = 'none'; // Hidden by default
        this.element.appendChild(this.rcsLeftElement);

        // Right RCS Thruster Fire (Triangular)
        this.rcsRightElement = createSVGElement('polygon');
        // Points for a triangle pointing left (inwards) from its base
        const rcsRightPoints = [
          `${rcsOffsetFrontX},${rcsOffsetFrontY - rcsSize / 2}`,
          `${rcsOffsetFrontX},${rcsOffsetFrontY + rcsSize / 2}`,
          `${rcsOffsetFrontX - rcsSize},${rcsOffsetFrontY}` // Tip points inwards (left)
        ].join(' ');
        this.rcsRightElement.setAttribute('points', rcsRightPoints);
        this.rcsRightElement.setAttribute('fill', 'url(#rcsThrusterFireGradient)');
        this.rcsRightElement.style.display = 'none'; // Hidden by default
        this.element.appendChild(this.rcsRightElement);
      }

      update(deltaTime) {
        const now = Date.now();

        // --- Movement AI ---
        const distanceToRoamingTarget = Math.hypot(this.roamingTargetX - this.x, this.roamingTargetY - this.y);

        // If defender is close to its roaming target, pick a new one
        if (distanceToRoamingTarget < this.roamingTargetReachedThreshold) {
            this.roamingTargetX = random(width * 0.1, width * 0.9);
            this.roamingTargetY = random(height * 0.1, height * 0.9);
        }

        const desiredAngleToTarget = Math.atan2(this.roamingTargetY - this.y, this.roamingTargetX - this.x); // Radians

        // Convert current rotation (degrees) to radians for calculations.
        // The 'A' shape points upwards when rotation is 0.
        // So, the "nose" of the craft is at rotation + 270 degrees (or -90 degrees).
        const currentHeadingRad = (this.rotation + 270) * Math.PI / 180;

        // Calculate angle difference for rotation
        let angleDiff = desiredAngleToTarget - currentHeadingRad;
        // Normalize angle difference to be between -PI and PI
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        const rotationThreshold = 0.1; // Radians
        const thrustActivationThreshold = this.size * 2 * SCALE_FACTOR; // Distance to start thrusting if not already

        // --- Rotation Control (RCS Thrusters) ---
        // --- Rotation Control (RCS Thrusters) ---
        // Hide RCS visuals at the start of the frame
        this.rcsLeftElement.style.display = 'none';
        this.rcsRightElement.style.display = 'none';

        const rotationalBrakingThreshold = 0.05 / TARGET_FRAME_DURATION; // Small vRotation to consider "stopped"
        const rotationalAccelerationFactor = 1.0; // How much to accelerate rotation
        const rotationalBrakingFactor = 1.0; // How much to brake rotation

        let rcsImpulseAppliedThisFrame = false; // Flag to track if an RCS impulse was applied

        if (Math.abs(angleDiff) > rotationThreshold) {
            // Need to turn
            if (now - this.lastRcsImpulseTime > this.rcsCooldown) {
                if (angleDiff > 0) { // Turn clockwise
                    this.vRotation += this.rotationForce * rotationalAccelerationFactor;
                    this.rcsLeftElement.style.display = ''; // Fire left RCS
                } else { // Turn counter-clockwise
                    this.vRotation -= this.rotationForce * rotationalAccelerationFactor;
                    this.rcsRightElement.style.display = ''; // Fire right RCS
                }
                this.lastRcsImpulseTime = now;
                rcsImpulseAppliedThisFrame = true;
            }
        } else {
            // Aligned, now check if we need to stop spinning
            if (Math.abs(this.vRotation) > rotationalBrakingThreshold) {
                if (now - this.lastRcsImpulseTime > this.rcsCooldown) {
                    if (this.vRotation > 0) { // Spinning clockwise, need to brake counter-clockwise
                        this.vRotation -= this.rotationForce * rotationalBrakingFactor;
                        this.rcsRightElement.style.display = ''; // Fire right RCS
                    } else { // Spinning counter-clockwise, need to brake clockwise
                        this.vRotation += this.rotationForce * rotationalBrakingFactor;
                        this.rcsLeftElement.style.display = ''; // Fire left RCS
                    }
                    this.lastRcsImpulseTime = now;
                    rcsImpulseAppliedThisFrame = true;
                }
            }
        }

        // Passive dampening: if no active RCS impulse was applied this frame, slowly reduce rotation
        if (!rcsImpulseAppliedThisFrame) {
            this.vRotation *= 0.98; // Gentle decay
            // If rotation is very small, snap to zero to prevent infinite tiny rotations
            if (Math.abs(this.vRotation) < 0.001 / TARGET_FRAME_DURATION) {
                this.vRotation = 0;
            }
        }

        // Clamp rotational speed (important for stability)
        this.vRotation = Math.max(-this.maxRotationSpeed, Math.min(this.maxRotationSpeed, this.vRotation));

        // --- Thrust Control (Main Thrusters) ---
        this.mainThrusterLeftElement.style.display = 'none';
        this.mainThrusterRightElement.style.display = 'none';

        // Logic for continuous thrusting
        if (this.isThrusting) {
            if (now - this.lastThrustToggleTime < this.thrustOnDuration) {
                // Continue thrusting
                this.vx += Math.cos(currentHeadingRad) * this.thrustForce;
                this.vy += Math.sin(currentHeadingRad) * this.thrustForce;
                this.mainThrusterLeftElement.style.display = '';
                this.mainThrusterRightElement.style.display = '';
            } else {
                // Stop thrusting
                this.isThrusting = false;
                this.lastThrustToggleTime = now;
            }
        } else { // Not currently thrusting
            if (now - this.lastThrustToggleTime > this.thrustOffDuration) {
                // Decide to start thrusting if far from target and aligned
                if (distanceToRoamingTarget > thrustActivationThreshold && Math.abs(angleDiff) < rotationThreshold * 2) {
                    this.isThrusting = true;
                    this.lastThrustToggleTime = now;
                    // Apply initial thrust
                    this.vx += Math.cos(currentHeadingRad) * this.thrustForce;
                    this.vy += Math.sin(currentHeadingRad) * this.thrustForce;
                    this.mainThrusterLeftElement.style.display = '';
                    this.mainThrusterRightElement.style.display = '';
                }
            }
            // Removed: Dampen linear velocity if not thrusting (momentum is maintained)
            // this.vx *= 0.98;
            // this.vy *= 0.98;
        }

        // Clamp linear speed
        const currentSpeed = Math.hypot(this.vx, this.vy);
        if (currentSpeed > this.maxSpeed) {
            const ratio = this.maxSpeed / currentSpeed;
            this.vx *= ratio;
            this.vy *= ratio;
        }

        // Update position and rotation based on velocities
        this.x += this.vx * deltaTime; // Scaled by delta time
        this.y += this.vy * deltaTime; // Scaled by delta time
        this.rotation += this.vRotation * deltaTime; // Scaled by delta time

        // Wrap around horizontally
        if (this.x < -this.size) this.x = width + this.size;
        if (this.x > width + this.size) this.x = -this.size;

        // Wrap around vertically
        if (this.y < -this.size) this.y = height + this.size;
        if (this.y > height + this.size) this.y = -this.size;

        this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${this.rotation})`);

        this.fire();
      }

      fire() {
        const now = Date.now();
        if (now - this.lastFireTime > this.fireInterval) {
          this.lastFireTime = now;

          // Prioritize UFOs if present
          if (ufos.length > 0) {
            // Target a random active UFO
            this.target = ufos[Math.floor(random(0, ufos.length))];
          } else {
            // Filter for on-screen asteroids that are well within the screen bounds.
            const onScreenAsteroids = asteroids.filter(a => 
                a.x > a.size * 2 && a.x < width - a.size * 2 && // At least 2x asteroid size away from horizontal edges
                a.y > a.size * 2 && a.y < height - a.size * 2   // At least 2x asteroid size away from vertical edges
            );

            if (onScreenAsteroids.length > 0) {
              // Prioritize smaller and faster asteroids
              let bestTarget = null;
              let highestThreatScore = -1;

              onScreenAsteroids.forEach(asteroid => {
                const speed = Math.hypot(asteroid.vx, asteroid.vy);
                // Threat score: smaller size and higher speed contribute more
                // (MAX_ASTEROID_SIZE - asteroid.size + 1) ensures score is positive and smaller asteroids get higher scores
                const threatScore = (MAX_ASTEROID_SIZE - asteroid.size + 1) * speed; 

                if (threatScore > highestThreatScore) {
                  highestThreatScore = threatScore;
                  bestTarget = asteroid;
                }
              });
              this.target = bestTarget;
            } else {
              this.target = null;
            }
          }

          if (this.target) {
            // Calculate distance to target
            const distanceToTarget = Math.hypot(this.target.x - this.x, this.target.y - this.y);
            // Estimate travel time based on fixed laser speed
            const estimatedTravelTime = distanceToTarget / DEFENDER_LASER_SPEED_PX_PER_MS;

            // Predict target's future position based on its velocity and estimated laser travel time
            const predictedTargetX = this.target.x + this.target.vx * estimatedTravelTime;
            const predictedTargetY = this.target.y + this.target.vy * estimatedTravelTime;

            const angle = Math.atan2(predictedTargetY - this.y, predictedTargetX - this.x);
            // Use laser pool
            let laser = laserPool.pop();
            if (!laser) { // If pool is empty, create a new one
                laser = new Laser();
            }
            // Pass the predicted target coordinates to the laser
            laser.reset(this.x, this.y, angle, 'defender', predictedTargetX, predictedTargetY, this.target);
            laser.element.style.display = ''; // Make visible
            laser.element.style.opacity = 1; // Ensure full opacity at start
            lasers.push(laser);
            // Play defender laser sound with spatial audio and an even wider pitch variation
            playSpatialSound(laserBuffer, this.x, 0.5, random(0.7, 1.3)); // Reduced volume to 0.5
          }
        }
      }
    }

    /**
     * Manages the glowing and fading effect of a single crack element.
     * Manages the glowing and fading effect of a single crack element.
     * The crack's color and opacity fade, and the glow filter's properties are animated.
     */
    /**
     * Manages the glowing and fading effect of a single crack element.
     * It animates the opacity of the glowing crack, which has a pre-defined glow filter applied.
     */
    class CrackEffect {
        constructor(svgElement, durationMs) {
            this.element = svgElement; // This is the "glowing" crack element
            this.duration = durationMs;
            this.startTime = Date.now();
            this.isAlive = true;

            this.element.setAttribute('opacity', 1); // Ensure it starts fully opaque
        }

        update() {
            const elapsed = Date.now() - this.startTime;
            let progress = elapsed / this.duration;

            if (progress >= 1) {
                this.element.setAttribute('opacity', 0); // Ensure it's fully transparent
                
                // The parent (UFO/Asteroid) is now responsible for removing the element from DOM
                // when this.update() returns true.

                this.isAlive = false;
                return true; // Mark for removal from parent's activeCrackEffects array
            }

            // Interpolate opacity of the glowing crack element (fades from 1 to 0)
            const currentOpacity = 1 - progress;
            this.element.setAttribute('opacity', Math.max(0, currentOpacity)); // Ensure opacity doesn't go negative

            return false;
        }
    }

    /**
     * Represents an asteroid.
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} size - Size of the asteroid.
     * @param {number} [health] - Health of the asteroid (defaults to size).
     * @param {number} [vx=0] - Initial velocity X.
     * @param {number} [vy=0] - Initial velocity Y.
     * @param {number} [vRotation=0] - Initial rotational velocity.
     * @param {string} [inheritedGradientId=null] - Optional: Gradient ID to inherit from parent.
     */
    class Asteroid {
      constructor(x, y, size, health = size, vx = 0, vy = 0, vRotation = 0, inheritedGradientId = null) {
        this.id = `asteroid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`; // Unique ID for clipping
        this.x = x;
        this.y = y;
        this.size = size;
        this.initialHealth = health; // Store initial health for crack calculation
        this.health = health;

        this.vx = vx;
        this.vy = vy;

        this.rotation = random(0, 360);
        this.vRotation = vRotation === 0 ? random(-0.8, 0.8) / TARGET_FRAME_DURATION : vRotation;
        this.element = createSVGElement('g'); // Group for asteroid and craters
        this.element.setAttribute('class', 'asteroid');
        
        // Default transition is only for opacity (used if an asteroid is removed for other reasons, though currently not the case)
        this.element.style.transition = 'opacity 0.5s ease-out'; 
        
        gameplayLayer.appendChild(this.element); // Append to gameplay layer

        // Select asteroid gradient: inherit if provided, otherwise random
        const asteroidGradients = ['asteroidGradientGrey', 'asteroidGradientBrown', 'asteroidGradientRed'];
        this.gradientId = inheritedGradientId || asteroidGradients[Math.floor(random(0, asteroidGradients.length))];

        this.crackGroup = createSVGElement('g'); 
        // crackGroup is now appended in drawAsteroid for correct Z-order

        this.drawAsteroid(); 
        this.updatePosition(); 

        this.activeCrackEffects = []; 
        this.damageStagesHit = 0; 
        this.damageThresholds = [0.75, 0.50, 0.25]; 
      }

      updatePosition() {
        // Transform changes here are immediate due to the default style.transition
        this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${this.rotation})`);
      }

      generateIrregularPolygon(centerX, centerY, radius, numPoints, irregularity) {
        let points = [];
        for (let i = 0; i < numPoints; i++) {
          const angle = (Math.PI * 2 / numPoints) * i;
          const r = radius * (1 + random(-irregularity, irregularity));
          const x = centerX + r * Math.cos(angle);
          const y = centerY + r * Math.sin(angle);
          points.push(`${x},${y}`);
        }
        return `M${points[0]} L${points.slice(1).join(' ')} Z`;
      }

      drawAsteroid() {
        const children = Array.from(this.element.children);
        children.forEach(child => {
            if (child !== this.crackGroup) {
                this.element.removeChild(child);
            }
        });

        const asteroidPath = createSVGElement('path');
        const asteroidPathData = this.generateIrregularPolygon(0, 0, this.size, random(10, 15), ASTEROID_MAX_IRREGULARITY);
        asteroidPath.setAttribute('d', asteroidPathData);
        asteroidPath.setAttribute('fill', `url(#${this.gradientId})`); // Use the selected gradient
        // Removed stroke and stroke-width for asteroid body
        this.element.appendChild(asteroidPath); 

        // Create and apply clipping path based on the asteroid's main shape
        const clipPathId = `asteroidClip-${this.id}`;
        let clipPath = document.getElementById(clipPathId);
        if (!clipPath) {
            clipPath = createSVGElement('clipPath');
            clipPath.setAttribute('id', clipPathId);
            canvas.querySelector('defs').appendChild(clipPath); // Append to main defs
        } else {
            // Clear existing path if reusing clipPath (though asteroids are not pooled, this is good practice)
            while(clipPath.firstChild) {
                clipPath.removeChild(clipPath.firstChild);
            }
        }
        const clipShape = createSVGElement('path');
        clipShape.setAttribute('d', asteroidPathData); // Use the same path data as the asteroid body
        clipPath.appendChild(clipShape);
        this.element.setAttribute('clip-path', `url(#${clipPathId})`); // Apply clipping to the main asteroid group

        // Store all placed features (craters and pockmarks) to prevent overlap
        const placedFeatures = []; 
        // Calculate the effective radius for feature placement, considering asteroid irregularity
        const effectiveAsteroidRadius = this.size * (1 - ASTEROID_MAX_IRREGULARITY * 0.8); // Slightly less than min for better spread

        // Scale the number of craters and pockmarks based on asteroid size
        const sizeRatio = this.size / MAX_ASTEROID_SIZE;
        const minCraters = 2; // Always draw at least this many craters
        const maxCraters = 15;
        const numCraters = Math.floor(random(minCraters, maxCraters * sizeRatio)); 

        for (let i = 0; i < numCraters; i++) {
            let craterX, craterY, craterSize;
            let attempts = 0;
            const maxAttempts = 50; // Increased attempts to find non-overlapping position

            let foundPosition = false;
            do {
                craterSize = random(this.size * 0.05, this.size * 0.15); // Smaller craters
                // Max distance from center for crater placement, ensuring it fits within the asteroid
                const maxCraterCenterDist = effectiveAsteroidRadius - craterSize;
                
                if (maxCraterCenterDist <= 0) {
                    attempts = maxAttempts; // Force exit loop if crater is too large to fit
                    break;
                } 

                const craterAngle = random(0, Math.PI * 2);
                // Spread craters more towards the edges, away from the very center
                const craterCenterDist = random(maxCraterCenterDist * 0.3, maxCraterCenterDist); 
                craterX = craterCenterDist * Math.cos(craterAngle);
                craterY = craterCenterDist * Math.sin(craterAngle);

                // Check for overlap with already placed features (craters or pockmarks)
                let overlaps = false;
                for (const existingFeature of placedFeatures) {
                    const dist = Math.hypot(craterX - existingFeature.x, craterY - existingFeature.y);
                    if (dist < craterSize + existingFeature.r) { // Overlap detected
                        overlaps = true;
                        break;
                    }
                }

                if (!overlaps) {
                    foundPosition = true;
                }
                attempts++;
            } while (!foundPosition && attempts < maxAttempts);

            if (!foundPosition) {
                continue; // Could not find a non-overlapping position, skip this crater
            }

            // Define common properties for both ovals
            const craterOvalRadiusX = craterSize * random(0.7, 0.9); // Oval shape
            const craterOvalRadiusY = craterSize * random(0.7, 0.9);
            const craterRotation = random(0, 360); // Common rotation for both ovals

            // Crater shadow (darker oval)
            const shadowCrater = createSVGElement('ellipse');
            const shadowOffsetX = craterSize * random(0.05, 0.15); // Offset for shadow (bottom-right)
            const shadowOffsetY = craterSize * random(0.05, 0.15);

            shadowCrater.setAttribute('cx', craterX + shadowOffsetX);
            shadowCrater.setAttribute('cy', craterY + shadowOffsetY);
            shadowCrater.setAttribute('rx', craterOvalRadiusX);
            shadowCrater.setAttribute('ry', craterOvalRadiusY);
            shadowCrater.setAttribute('transform', `rotate(${craterRotation} ${craterX + shadowOffsetX} ${craterY + shadowOffsetY})`);
            shadowCrater.setAttribute('fill', this.getDarkenedColorForCrater(this.gradientId, random(0.1, 0.25))); // Less dark fill
            this.element.appendChild(shadowCrater);

            // Crater highlight (lighter oval)
            const lightCrater = createSVGElement('ellipse');
            const lightOffsetX = craterSize * random(-0.05, -0.15); // Offset for light (top-left)
            const lightOffsetY = craterSize * random(-0.05, -0.15);

            lightCrater.setAttribute('cx', craterX + lightOffsetX);
            lightCrater.setAttribute('cy', craterY + lightOffsetY);
            lightCrater.setAttribute('rx', craterOvalRadiusX); // Same size as shadow
            lightCrater.setAttribute('ry', craterOvalRadiusY); // Same size as shadow
            lightCrater.setAttribute('transform', `rotate(${craterRotation} ${craterX + lightOffsetX} ${craterY + lightOffsetY})`); // Same rotation as shadow
            lightCrater.setAttribute('fill', this.getDarkenedColorForCrater(this.gradientId, random(0.05, 0.15))); // Use darker color for light part
            lightCrater.setAttribute('opacity', random(0.6, 0.9)); // Semi-transparent for subtle effect
            this.element.appendChild(lightCrater);

            // Add the newly placed crater to the list of all features for overlap checking
            placedFeatures.push({ x: craterX, y: craterY, r: Math.max(craterOvalRadiusX, craterOvalRadiusY) });
        }

        // Add small circular pockmarks
        const minPockmarks = 3; // Always draw at least this many pockmarks
        const maxPockmarks = 25;
        const numPockmarks = Math.floor(random(minPockmarks, maxPockmarks * sizeRatio)); // Scale pockmarks by size
        for (let i = 0; i < numPockmarks; i++) {
            let pockmarkX, pockmarkY, pockmarkRadius;
            let attempts = 0;
            const maxAttempts = 50; // Increased attempts

            let foundPosition = false;
            do {
                pockmarkRadius = random(this.size * 0.01, this.size * 0.04); // Very small circles, slightly smaller max
                // Max distance from center for pockmark placement
                const maxPockmarkCenterDist = effectiveAsteroidRadius - pockmarkRadius;
                
                if (maxPockmarkCenterDist <= 0) {
                    attempts = maxAttempts; // Force exit loop
                    break;
                }

                const pockmarkAngle = random(0, Math.PI * 2);
                // Spread pockmarks more towards the edges
                const pockmarkCenterDist = random(maxPockmarkCenterDist * 0.2, maxPockmarkCenterDist);
                pockmarkX = pockmarkCenterDist * Math.cos(pockmarkAngle);
                pockmarkY = pockmarkCenterDist * Math.sin(pockmarkAngle);

                // Check for overlap with already placed features
                let overlaps = false;
                for (const existingFeature of placedFeatures) {
                    const dist = Math.hypot(pockmarkX - existingFeature.x, pockmarkY - existingFeature.y);
                    if (dist < pockmarkRadius + existingFeature.r) { // Overlap detected
                        overlaps = true;
                        break;
                    }
                }

                if (!overlaps) {
                    foundPosition = true;
                }
                attempts++;
            } while (!foundPosition && attempts < maxAttempts);

            if (!foundPosition) {
                continue; // Could not find a non-overlapping position, skip this pockmark
            }

            const pockmarkCircle = createSVGElement('circle');
            pockmarkCircle.setAttribute('cx', pockmarkX);
            pockmarkCircle.setAttribute('cy', pockmarkY);
            pockmarkCircle.setAttribute('r', pockmarkRadius);
            
            // Make pockmark color match asteroid's base color, but darker
            const pockmarkFillColor = this.getDarkenedColorForCrater(this.gradientId, random(0.1, 0.3)); // Less dark
            pockmarkCircle.setAttribute('fill', pockmarkFillColor);
            this.element.appendChild(pockmarkCircle);

            // Add the newly placed pockmark to the list of all features for overlap checking
            placedFeatures.push({ x: pockmarkX, y: pockmarkY, r: pockmarkRadius });
        }

        // Append crackGroup here, after craters and pockmarks, to ensure cracks are on top.
        if (this.crackGroup.parentNode) { // If it was already a child (e.g., from previous draw), remove it first
            this.element.removeChild(this.crackGroup);
        }
        this.element.appendChild(this.crackGroup);
      }

      /**
       * Returns a darker RGB color based on the asteroid's gradient ID.
       * @param {string} gradientId - The ID of the gradient used for the asteroid.
       * @param {number} darkenFactor - How much to darken (0 to 1, 0 means no change, 1 means black).
       * @returns {string} An RGB color string.
       */
      getDarkenedColorForCrater(gradientId, darkenFactor) {
          let baseColorRgb;
          switch (gradientId) {
              case 'asteroidGradientGrey':
                  baseColorRgb = [96, 96, 96]; // RGB for #606060 (middle of grey gradient)
                  break;
              case 'asteroidGradientBrown':
                  baseColorRgb = [128, 96, 64]; // RGB for #806040 (middle of brown gradient)
                  break;
              case 'asteroidGradientRed':
                  baseColorRgb = [144, 80, 80]; // RGB for #905050 (middle of red gradient)
                  break;
              default:
                  baseColorRgb = [50, 50, 50]; // Default dark grey
          }

          const r = Math.max(0, Math.floor(baseColorRgb[0] * (1 - darkenFactor)));
          const g = Math.max(0, Math.floor(baseColorRgb[1] * (1 - darkenFactor)));
          const b = Math.max(0, Math.floor(baseColorRgb[2] * (1 - darkenFactor)));

          return `rgb(${r},${g},${b})`;
      }

      /**
       * Returns a lighter RGB color based on the asteroid's gradient ID.
       * @param {string} gradientId - The ID of the gradient used for the asteroid.
       * @param {number} lightenFactor - How much to lighten (0 to 1, 0 means no change, 1 means max white).
       * @returns {string} An RGB color string.
       */
      getLightenedColorForCrater(gradientId, lightenFactor) {
          let baseColorRgb;
          switch (gradientId) {
              case 'asteroidGradientGrey':
                  baseColorRgb = [160, 160, 160]; // RGB for #a0a0a0 (top of grey gradient)
                  break;
              case 'asteroidGradientBrown':
                  baseColorRgb = [176, 144, 112]; // RGB for #b09070 (top of brown gradient)
                  break;
              case 'asteroidGradientRed':
                  baseColorRgb = [192, 128, 128]; // RGB for #c08080 (top of red gradient)
                  break;
              default:
                  baseColorRgb = [100, 100, 100]; // Default light grey
          }

          const r = Math.min(255, Math.floor(baseColorRgb[0] * (1 + lightenFactor)));
          const g = Math.min(255, Math.floor(baseColorRgb[1] * (1 + lightenFactor)));
          const b = Math.min(255, Math.floor(baseColorRgb[2] * (1 + lightenFactor)));

          return `rgb(${r},${g},${b})`;
      }

      /**
       * Converts local coordinates (relative to asteroid's center) to global screen coordinates.
       * @param {number} localX - Local X coordinate.
       * @param {number} localY - Local Y coordinate.
       * @returns {{x: number, y: number}} Global X and Y coordinates.
       */
      getGlobalCoordinates(localX, localY) {
          const radRotation = this.rotation * Math.PI / 180;
          const rotatedX = localX * Math.cos(radRotation) - localY * Math.sin(radRotation);
          const rotatedY = localX * Math.sin(radRotation) + localY * Math.cos(radRotation);
          return {
              x: this.x + rotatedX,
              y: this.y + rotatedY
          };
      }

      addDamageCracks(numNewCracks, impactX = null, impactY = null, crackType = 'linear') { // Added impactX, impactY, crackType
          if (!this.crackGroup) return;
          const settings = qualitySettings[currentQualityLevel];
          // Determine the final color for the crack, which is the darkest part of the asteroid
          // Determine the final color for the crack, which is the darkest part of the asteroid
          const finalCrackColor = this.getDarkenedColorForCrater(this.gradientId, random(0.4, 0.6)); // Use a higher darken factor for the "darkest part"
          const finalCrackOpacity = 1; // Ensure crack is fully opaque after glow fades

          // Convert global impact coordinates to asteroid's local coordinates
          // This is crucial because the asteroid's group is translated and rotated.
          // We need to reverse the asteroid's current transform to get the local impact point.
          let localImpactX = 0;
          let localImpactY = 0;
          if (impactX !== null && impactY !== null) {
              // Translate back to origin
              const translatedX = impactX - this.x;
              const translatedY = impactY - this.y;

              // Rotate back (inverse rotation)
              const radRotation = -this.rotation * Math.PI / 180; // Convert to radians and negate
              localImpactX = translatedX * Math.cos(radRotation) - translatedY * Math.sin(radRotation);
              localImpactY = translatedX * Math.sin(radRotation) + translatedY * Math.cos(radRotation);
          }

          for (let i = 0; i < numNewCracks; i++) {
              // The final shaded color for the crack, which will be visible after the glow fades
              const shadedCrackColor = this.getDarkenedColorForCrater(this.gradientId, random(0.4, 0.6)); 
              const glowingCrackFadeDuration = 5000; // Duration for the glowing crack to fade out


              // Define offsets for 3D effect, scaling with asteroid size for a more shallow 3D effect
              const offsetMagnitude = this.size * random(0.005, 0.015); // Offset scales with asteroid size
              const offsetX = offsetMagnitude;
              const offsetY = offsetMagnitude;
              const lightOffsetX = -offsetMagnitude; // Opposite offset for highlight
              const lightOffsetY = -offsetMagnitude;

              let pathData = '';
              let isCrackFilled = false;

              if (crackType === 'starburst' && impactX !== null && impactY !== null) {
                  isCrackFilled = true;
                  // Starburst crack logic: create a filled polygon
                  const numRays = Math.floor(random(10, 20)); // Increased number of rays for more spikes
                  const maxRayLength = this.size * random(0.2, 0.5); // Max length of a ray
                  const innerRadiusFactor = random(0.3, 0.5); // How far in the "valley" points are
                  const starburstOffsetMagnitude = this.size * random(0.05, 0.1); // Offset from impact point towards center
                  
                  // Calculate the starburst origin: slightly offset from impact point towards asteroid center (0,0)
                  const distImpactToCenter = Math.hypot(localImpactX, localImpactY);
                  let starburstOriginX = localImpactX;
                  let starburstOriginY = localImpactY;

                  if (distImpactToCenter > 0) { // Avoid division by zero if impact is at (0,0)
                      const angleImpactToCenter = Math.atan2(localImpactY, localImpactX);
                      starburstOriginX = localImpactX - starburstOffsetMagnitude * Math.cos(angleImpactToCenter);
                      starburstOriginY = localImpactY - starburstOffsetMagnitude * Math.sin(angleImpactToCenter);
                  }

                  pathData = `M${starburstOriginX},${starburstOriginY}`; // Start at the center
                  const initialOffsetAngle = random(0, Math.PI * 2); // Random initial rotation for the starburst
                  const irregularityFactor = random(0.1, 0.3); // How much to offset points for irregularity

                  for (let k = 0; k < numRays; k++) {
                      // Outer point (peak of the ray)
                      const angleOuter = (2 * Math.PI / numRays) * k + initialOffsetAngle;
                      const outerX = starburstOriginX + maxRayLength * Math.cos(angleOuter);
                      const outerY = starburstOriginY + maxRayLength * Math.sin(angleOuter);
                      
                      // Add random offset to outer points
                      const outerOffsetX = random(-maxRayLength * irregularityFactor, maxRayLength * irregularityFactor);
                      const outerOffsetY = random(-maxRayLength * irregularityFactor, maxRayLength * irregularityFactor);
                      pathData += ` L${outerX + outerOffsetX},${outerY + outerOffsetY}`;

                      // Inner point (valley between rays)
                      const angleInner = (2 * Math.PI / numRays) * k + (Math.PI / numRays) + initialOffsetAngle;
                      const innerX = starburstOriginX + (maxRayLength * innerRadiusFactor) * Math.cos(angleInner);
                      const innerY = starburstOriginY + (maxRayLength * innerRadiusFactor) * Math.sin(angleInner);
                      
                      // Add random offset to inner points
                      const innerOffsetX = random(-maxRayLength * irregularityFactor * 0.5, maxRayLength * irregularityFactor * 0.5); // Smaller offset for inner points
                      const innerOffsetY = random(-maxRayLength * irregularityFactor * 0.5, maxRayLength * irregularityFactor * 0.5);
                      pathData += ` L${innerX + innerOffsetX},${innerY + innerOffsetY}`;
                  }
                  pathData += ` Z`; // Close the polygon

                  // Shaded crack (bottom layer)
                  const shadedCrack = createSVGElement('path');
                  shadedCrack.setAttribute('d', pathData);
                  shadedCrack.setAttribute('fill', shadedCrackColor); // Solid shaded color
                  shadedCrack.setAttribute('stroke', 'none');
                  shadedCrack.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
                  shadedCrack.setAttribute('opacity', settings.crackFinalOpacity); // Set final opacity for the shaded crack
                  this.crackGroup.appendChild(shadedCrack);

                  // Glowing crack (top layer)
                  const glowingCrack = createSVGElement('path');
                  glowingCrack.setAttribute('d', pathData);
                  glowingCrack.setAttribute('fill', 'url(#crackGradient)'); // Gradient fill
                  glowingCrack.setAttribute('stroke', 'none');
                  glowingCrack.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
                  glowingCrack.setAttribute('filter', 'url(#crackGlowFilter)'); // Apply the shared glow filter
                  // Opacity is managed by CrackEffect
                  this.crackGroup.appendChild(glowingCrack);

                  // Create sparks at the starburst origin
                  const globalStarburstOrigin = this.getGlobalCoordinates(starburstOriginX, starburstOriginY);
                  createExplosion(globalStarburstOrigin.x, globalStarburstOrigin.y, this.size * 0.1, 'spark');

                  // Add CrackEffect for the glowing crack
                  this.activeCrackEffects.push(new CrackEffect(
                      glowingCrack,
                      glowingCrackFadeDuration
                  ));

              } else { // Linear crack logic
                  const crackWidth = random(1, 8); // Wider variation in stroke width for each crack
                  const totalCrackLength = random(this.size * settings.asteroidCrackSizeFactor[0], this.size * settings.asteroidCrackSizeFactor[1]);
                  const numSegments = Math.floor(random(settings.asteroidCrackSegments[0], settings.asteroidCrackSegments[1]));
                  const segmentLength = totalCrackLength / numSegments;

                  // Start point: near the edge of the asteroid
                  const startAngle = random(0, Math.PI * 2);
                  const startDist = this.size * random(0.7, 0.95); // Closer to the edge
                  let currentX = startDist * Math.cos(startAngle);
                  let currentY = startDist * Math.sin(startAngle);
                  pathData = `M${currentX},${currentY}`;

                  // Initial direction: generally towards the center, with some randomness
                  let currentSegmentAngle = startAngle + Math.PI + random(-Math.PI / 4, Math.PI / 4); // Opposite to radial direction, plus wiggle

                  for (let j = 0; j < numSegments; j++) {
                      // Randomly perturb angle for next segment
                      currentSegmentAngle += random(-Math.PI / 4, Math.PI / 4); // Increased deviation for more jaggedness

                      const nextX = currentX + segmentLength * Math.cos(currentSegmentAngle);
                      const nextY = currentY + segmentLength * Math.sin(currentSegmentAngle);

                      // Check if the crack is going too far outside the asteroid's approximate bounds
                      const distFromCenter = Math.hypot(nextX, nextY);
                      // If it's trying to go too far out, redirect it inwards slightly or stop
                      if (distFromCenter > this.size * (1 - ASTEROID_MAX_IRREGULARITY * 0.1)) {
                          // Try to redirect inwards by adjusting the angle
                          const angleToCenter = Math.atan2(-nextY, -nextX); // Angle from next point towards (0,0)
                          currentSegmentAngle = angleToCenter + random(-Math.PI / 8, Math.PI / 8); // Redirect towards center with some wiggle
                          // Recalculate next point with new angle
                          const redirectedNextX = currentX + segmentLength * Math.cos(currentSegmentAngle);
                          const redirectedNextY = currentY + segmentLength * Math.sin(currentSegmentAngle);
                          // Only use if it actually brings it back inside or closer
                          if (Math.hypot(redirectedNextX, redirectedNextY) < distFromCenter) {
                              currentX = redirectedNextX;
                              currentY = redirectedNextY;
                          } else {
                              // If redirection didn't help, or it's the first segment, just break to prevent it from going too far
                              if (j > 0) break; 
                          }
                      } else {
                          currentX = nextX;
                          currentY = nextY;
                      }
                      pathData += ` L${currentX},${currentY}`;

                      // Create sparks along the crack segments
                      if (j % 2 === 0) { // Create a spark every other segment
                          const globalSparkPos = this.getGlobalCoordinates(currentX, currentY);
                          createExplosion(globalSparkPos.x, globalSparkPos.y, this.size * 0.05, 'spark'); // Small sparks
                      }
                  }
                  
                  // Shaded crack (bottom layer)
                  const shadedCrack = createSVGElement('path');
                  shadedCrack.setAttribute('d', pathData);
                  shadedCrack.setAttribute('fill', 'none');
                  shadedCrack.setAttribute('stroke', shadedCrackColor); // Solid shaded color
                  shadedCrack.setAttribute('stroke-width', crackWidth);
                  shadedCrack.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
                  shadedCrack.setAttribute('opacity', settings.crackFinalOpacity); // Set final opacity for the shaded crack
                  this.crackGroup.appendChild(shadedCrack);

                  // Glowing crack (top layer)
                  const glowingCrack = createSVGElement('path');
                  glowingCrack.setAttribute('d', pathData);
                  glowingCrack.setAttribute('fill', 'none');
                  glowingCrack.setAttribute('stroke', 'url(#crackGradient)'); // Gradient stroke
                  glowingCrack.setAttribute('stroke-width', crackWidth);
                  glowingCrack.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
                  glowingCrack.setAttribute('filter', 'url(#crackGlowFilter)'); // Apply the shared glow filter
                  // Opacity is managed by CrackEffect
                  this.crackGroup.appendChild(glowingCrack);

                  // Add CrackEffect for the glowing crack
                  this.activeCrackEffects.push(new CrackEffect(
                      glowingCrack,
                      glowingCrackFadeDuration
                  ));
              }
          }
      }

      update(deltaTime) {
        this.x += this.vx * deltaTime; 
        this.y += this.vy * deltaTime; 
        this.rotation += this.vRotation * deltaTime; 

        if (this.x < -this.size) {
          this.x = width + this.size;
        }
        else if (this.x > width + this.size) {
          this.x = -this.size;
        }
        
        if (this.y < -this.size) {
          this.y = height + this.size;
        }
        else if (this.y > height + this.size) {
          this.y = -this.size;
        }

        // Update and clean up crack effects
        if (this.activeCrackEffects) {
            for (let i = this.activeCrackEffects.length - 1; i >= 0; i--) {
                const effect = this.activeCrackEffects[i];
                if (effect.update()) { // If the effect is dead
                    if (effect.element.parentNode === this.crackGroup) { // Ensure it's still a child
                        this.crackGroup.removeChild(effect.element);
                    }
                    this.activeCrackEffects.splice(i, 1);
                }
            }
        }

        this.updatePosition(); 

        // Return true if the asteroid is far off-screen and should be removed
        // Use a larger buffer (e.g., 2 times its size) to ensure it's well out of view
        const removalBuffer = this.size * 2;
        if (this.x < -removalBuffer || this.x > width + removalBuffer ||
            this.y < -removalBuffer || this.y > height + removalBuffer) {
            return true; // Mark for removal
        }
        return false; // Still alive and on-screen or within buffer
      }

      takeDamage(damage, laserAngle, impactX, impactY) { // Added impactX, impactY
        this.health -= damage;

        // Play spark sound on hit (reduced volume to avoid cutting off laser sound)
        playSpatialSound(sparkSoundBuffer, this.x, 0.2); // Play spark sound, even quieter

        // Create a small, dissipating fireball on hit
        let hitFireball = fireballPool.pop();
        if (!hitFireball) {
            hitFireball = new FireballEffect();
        }
        hitFireball.reset(impactX, impactY, this.size * 0.5 * SCALE_FACTOR, 200, 'visual'); // Smaller, shorter fireball for a hit
        activeFireballs.push(hitFireball);

        // Create sparks at the impact point, inheriting asteroid's velocity
        createExplosion(impactX, impactY, this.size * SCALE_FACTOR, 'spark', this.vx, this.vy);

        const currentHealthRatio = this.health / this.initialHealth;
        for (let i = this.damageThresholds.length - 1; i >= 0; i--) {
            if (currentHealthRatio <= this.damageThresholds[i] && i >= this.damageStagesHit) {
                // Pass impact coordinates and determine crack type
                const crackType = (this.damageStagesHit === 0) ? 'starburst' : 'linear'; // First hit is starburst
                this.addDamageCracks(1 + i, impactX, impactY, crackType); 
                this.damageStagesHit = i + 1; 
                break; 
            }
        }

        const deflectionForce = 0.5 / TARGET_FRAME_DURATION; 
        this.vx += Math.cos(laserAngle) * deflectionForce;
        this.vy += Math.sin(laserAngle) * deflectionForce;
        this.vRotation += random(-1, 1) / TARGET_FRAME_DURATION; 

        if (this.health <= 0) {
          this.destroy();
        }
      }

      destroy(isNukeHit = false) { 
        // Calculate pitch based on asteroid size: smaller asteroids get higher pitch
        const minOverallSize = MIN_ASTEROID_SIZE;
        const maxOverallSize = MAX_ASTEROID_SIZE;
        const minTargetPitch = 0.05; // Pitch for largest objects (made even lower for very bassy sound)
        const maxTargetPitch = 1.3; // Pitch for smallest objects

        const normalizedSize = (this.size - minOverallSize) / (maxOverallSize - minOverallSize);
        const clampedNormalizedSize = Math.max(0, Math.min(1, normalizedSize)); // Ensure value is between 0 and 1
        const basePitch = maxTargetPitch - (clampedNormalizedSize * (maxTargetPitch - minTargetPitch));
        const finalPitch = basePitch * random(0.9, 1.1); // Add +/- 10% random variation

        playSpatialSound(explosionBuffer, this.x, 1, finalPitch); 
        // Explosion particles should inherit asteroid's velocity
        createExplosion(this.x, this.y, this.size * SCALE_FACTOR, 'explosion', this.vx, this.vy); 

        let fireball = fireballPool.pop();
        if (!fireball) {
            fireball = new FireballEffect();
        }
        fireball.reset(this.x, this.y, this.size * 1.2 * SCALE_FACTOR, 400, 'visual'); // Reduced size and duration
        activeFireballs.push(fireball);

        const index = asteroids.indexOf(this);
        if (index > -1) {
            asteroids.splice(index, 1);
        }

        // Remove all crack elements that are still children of this.crackGroup
        while (this.crackGroup.firstChild) {
            this.crackGroup.removeChild(this.crackGroup.firstChild);
        }
        this.activeCrackEffects = []; 

        // Remove the clipPath definition from defs to prevent memory leaks
        const clipPathElement = document.getElementById(`asteroidClip-${this.id}`);
        if (clipPathElement && clipPathElement.parentNode) {
            clipPathElement.parentNode.removeChild(clipPathElement);
        }

        const newSize = this.size * 0.8; 
        if (!isNukeHit && newSize >= MIN_ASTEROID_SIZE) { 
          const spawnX = this.x;
          const spawnY = this.y;

          const angle1 = random(0, Math.PI * 2); 
          const angle2 = random(0, Math.PI * 2); 

          const inheritedSpeedFactor = random(0.8, 1.2);
          const inheritedRotationFactor = random(0.8, 1.2);
          
          const kickSpeedMagnitude = random(0.2, 0.6) / TARGET_FRAME_DURATION; 
          const kickRotationMagnitude = random(-0.3, 0.3) / TARGET_FRAME_DURATION; 

          const newVx1 = this.vx * inheritedSpeedFactor + Math.cos(angle1) * kickSpeedMagnitude;
          const newVy1 = this.vy * inheritedSpeedFactor + Math.sin(angle1) * kickSpeedMagnitude;
          const newVRotation1 = this.vRotation * inheritedRotationFactor + kickRotationMagnitude;

          const newVx2 = this.vx * inheritedSpeedFactor + Math.cos(angle2) * kickSpeedMagnitude;
          const newVy2 = this.vy * inheritedSpeedFactor + Math.sin(angle2) * kickSpeedMagnitude;
          const newVRotation2 = this.vRotation * inheritedRotationFactor + random(-0.3, 0.3) / TARGET_FRAME_DURATION;

          asteroids.push(new Asteroid(
            spawnX, 
            spawnY, 
            newSize,
            newSize, 
            newVx1, newVy1, newVRotation1,
            this.gradientId // Pass parent's gradientId
          ));
          asteroids.push(new Asteroid(
            spawnX, 
            spawnY, 
            newSize,
            newSize, 
            newVx2, newVy2, newVRotation2,
            this.gradientId // Pass parent's gradientId
          ));
        }

        // If on iOS, just remove the element immediately after splitting.
        // Otherwise, perform the expand and fade animation.
        if (isIOS) {
            if (this.element.parentNode) {
                gameplayLayer.removeChild(this.element); // Remove from gameplay layer
            }
        } else {
            // Temporarily enable transition for transform to animate the explosion scaling.
            // The duration of 0.3s for transform can be different from opacity's 0.5s if desired.
            // Here, we make them both 0.5s for simplicity.
            const animationDuration = 500; // ms
            this.element.style.transition = `opacity ${animationDuration/1000}s ease-out, transform ${animationDuration/1000}s ease-out`;

            // Trigger the animations by setting the final state
            this.element.style.opacity = 0;
            // The transform will animate from its current state (scale 1) to scale 1.5
            this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${this.rotation}) scale(1.5)`); 
            
            // Remove from DOM after the animation completes
            setTimeout(() => {
                if (this.element.parentNode) {
                    gameplayLayer.removeChild(this.element); // Remove from gameplay layer
                }
                // Optional: Reset transition if the element were to be pooled, 
                // but since it's removed, it's not strictly necessary here.
                // if (this.element) this.element.style.transition = 'opacity 0.5s ease-out';
            }, animationDuration);
        }
      }
    }

    /**
     * Represents a laser beam.
     * @param {number} startX - Starting X coordinate.
     * @param {number} startY - Starting Y coordinate.
     * @param {number} angle - Angle of the laser in radians.
     * @param {string} type - Type of laser ('defender' or 'user'). // Renamed from 'satellite'
     * @param {number} [targetX] - Target X coordinate for user lasers.
     * @param {number} [targetY] - Target Y coordinate for user lasers.
     * @param {SVGElement} [element=null] - Optional existing SVG element to reuse.
     */
    class Laser {
      constructor() { // Constructor no longer takes initial position/angle
        this.element = createSVGElement('g');
        this.element.setAttribute('class', 'laser-beam');
        // Do NOT append to gameplayLayer here; append in reset() when activated.

        // Create shapeElement once in constructor
        this.shapeElement = createSVGElement('rect');
        this.element.appendChild(this.shapeElement);

        // Ensure it's hidden and off-screen initially
        this.element.style.display = 'none';
        this.element.setAttribute('transform', 'translate(-9999,-9999)');
      }

      // Reset method now takes all parameters and configures the laser for use
      reset(startX, startY, angle, type, predictedTargetX, predictedTargetY, actualTarget = null) {
        // Append to gameplayLayer here to ensure it's in the DOM when active
        if (!this.element.parentNode) { // Only append if not already in DOM
            gameplayLayer.appendChild(this.element);
        }

        this.shapeElement.removeAttribute('filter'); // Ensure no lingering filter from previous use
        this.x = startX;
        this.y = startY;
        this.predictedTargetX = predictedTargetX; // Store predicted coordinates
        this.predictedTargetY = predictedTargetY;
        this.actualTarget = actualTarget; // Store actual target object (for defender lasers)
        this.angle = angle;
        this.type = type;
        this.hasDamaged = false;
        this.checkedTargetPointCollision = false; // New: Flag for user laser to check collision only once at target point

        const settings = qualitySettings[currentQualityLevel];
        this.damage = type === 'user' ? 10 : 10;

        // Update shapeElement attributes based on type
        if (this.type === 'user') {
            this.initialWidth = 15 * SCALE_FACTOR; // Max width at origin
            this.finalWidth = 1 * SCALE_FACTOR; // Min width at target (or beyond)
            this.maxLength = Math.hypot(this.predictedTargetX - this.x, this.predictedTargetY - this.y); // Distance from origin to target
            this.visualLength = 100 * SCALE_FACTOR; // Fixed visual length of the plasma burst (length of the rect)
            this.growthDuration = 200 * SCALE_FACTOR; // Duration for the laser's tip to reach the target (faster)
            this.fadeOutDuration = 200 * SCALE_FACTOR; // Duration for the laser to fade out after reaching target
            this.initialLife = this.growthDuration + this.fadeOutDuration; // Total life duration
            this.lifeRemaining = this.initialLife; // Initialize remaining life
            this.startTime = Date.now();
            this.currentTipX = startX; // Initialize currentTipX
            this.currentTipY = startY; // Initialize currentTipY

            this.shapeElement.setAttribute('fill', settings.laserGradient ? 'url(#userLaserGradient)' : 'rgb(0, 255, 0)');
            this.shapeElement.removeAttribute('stroke'); // Remove stroke for user lasers
            this.shapeElement.removeAttribute('stroke-width'); // Remove stroke-width for user lasers
            this.shapeElement.setAttribute('rx', 3);
            this.shapeElement.setAttribute('ry', 3);
            if (settings.laserShadow) {
                this.shapeElement.setAttribute('filter', 'url(#laserGlow)');
            } else {
                this.shapeElement.removeAttribute('filter'); // Ensure filter is removed if not needed
            }
            // Set fixed dimensions for the rect, with its right edge at 0 (relative to group origin)
            // This makes the laser "trail" behind its leading edge.
            this.shapeElement.setAttribute('x', -this.visualLength);
            this.shapeElement.setAttribute('y', -this.initialWidth / 2);
            this.shapeElement.setAttribute('width', this.visualLength);
            this.shapeElement.setAttribute('height', this.initialWidth); // Initial height, will be tapered in update

        } else { // Defender laser
            this.initialWidth = 3 * SCALE_FACTOR; // Fixed width for defender
            this.initialLength = 150 * SCALE_FACTOR; // Fixed length for defender
            
            // Defender lasers travel at a fixed speed
            this.vx = Math.cos(angle) * DEFENDER_LASER_SPEED_PX_PER_MS;
            this.vy = Math.sin(angle) * DEFENDER_LASER_SPEED_PX_PER_MS;

            // Calculate total distance to target for life calculation
            this.totalDistance = Math.hypot(predictedTargetX - startX, predictedTargetY - startY);
            // Life is based on time to reach target plus a small fade out buffer
            this.initialLife = (this.totalDistance / DEFENDER_LASER_SPEED_PX_PER_MS) + 50; 
            this.lifeRemaining = this.initialLife; // Initialize remaining life

            this.shapeElement.setAttribute('fill', settings.laserGradient ? 'url(#satelliteLaserGradient)' : 'rgb(255, 0, 0)');
            this.shapeElement.removeAttribute('stroke'); // Remove stroke for defender lasers
            this.shapeElement.removeAttribute('stroke-width'); // Remove stroke-width for defender lasers
            this.shapeElement.setAttribute('rx', 3);
            this.shapeElement.setAttribute('ry', 3);
            // Set dimensions for defender laser
            this.shapeElement.setAttribute('x', 0);
            this.shapeElement.setAttribute('y', -this.initialWidth / 2);
            this.shapeElement.setAttribute('width', this.initialLength);
            this.shapeElement.setAttribute('height', this.initialWidth);
            this.shapeElement.removeAttribute('filter'); // Ensure no filter from previous use
        }
        // Visibility and opacity are handled by the caller when retrieving from pool
        this.updatePosition(); // Initial position and size
      }

      update(deltaTime) {
        const now = Date.now();

        if (this.type === 'user') {
            const elapsed = now - this.startTime;
            const totalAnimationTime = this.growthDuration + this.fadeOutDuration;

            let growthProgress = 0;
            if (elapsed <= this.growthDuration) {
                growthProgress = elapsed / this.growthDuration;
                growthProgress = 1 - Math.pow(1 - growthProgress, 3); // Ease-out for smoother growth
            } else {
                growthProgress = 1; // Ensure it reaches full growth
            }

            // Calculate the current tip position of the laser
            this.currentTipX = this.x + (this.predictedTargetX - this.x) * growthProgress;
            this.currentTipY = this.y + (this.predictedTargetY - this.y) * growthProgress;

            // Calculate and apply width tapering directly to the shape element
            const currentWidth = this.initialWidth + (this.finalWidth - this.initialWidth) * growthProgress;
            this.shapeElement.setAttribute('height', currentWidth);
            this.shapeElement.setAttribute('y', -currentWidth / 2); // Keep centered vertically

            // Collision check: only when the laser tip has reached the predicted target point
            // and hasn't damaged yet.
            if (elapsed >= this.growthDuration && !this.hasDamaged && !this.checkedTargetPointCollision) {
                this.checkedTargetPointCollision = true; // Mark as checked

                let hitObject = null;
                // Check for collision at the PREDICTED target point
                // Use a small radius around the predicted target point for hit detection
                const hitDetectionRadius = 10 * SCALE_FACTOR; // Pixels around the clicked point

                // Check UFOs
                for (let j = ufos.length - 1; j >= 0; j--) {
                    const currentUfo = ufos[j];
                    if (Math.hypot(this.predictedTargetX - currentUfo.x, this.predictedTargetY - currentUfo.y) < currentUfo.size + hitDetectionRadius) {
                        hitObject = currentUfo;
                        break; // Hit a UFO, no need to check others
                    }
                }

                if (!hitObject) { // Only check asteroids if no UFO was hit
                    // Check asteroids
                    for (let j = asteroids.length - 1; j >= 0; j--) {
                        const asteroid = asteroids[j];
                        if (Math.hypot(this.predictedTargetX - asteroid.x, this.predictedTargetY - asteroid.y) < asteroid.size + hitDetectionRadius) {
                            hitObject = asteroid;
                            break;
                        }
                    }
                }

                if (hitObject) {
                    hitObject.takeDamage(this.damage, this.angle, this.predictedTargetX, this.predictedTargetY); // Pass predicted impact coordinates
                    createExplosion(this.predictedTargetX, this.predictedTargetY, hitObject.size, 'spark');
                    this.hasDamaged = true;
                    this.lifeRemaining = 0; // Make the laser disappear immediately on impact
                } else {
                    // If no hit object found, and we've checked the target point, immediately remove the laser
                    this.lifeRemaining = 0;
                }
            }
            
            // Laser life and fade out (only if not already impacted)
            // If the laser has reached its target point and either hit something or found nothing,
            // it should proceed to fade out.
            if (!this.hasDamaged) {
                // For user lasers, lifeRemaining is based on elapsed time from startTime
                this.lifeRemaining = Math.max(0, this.initialLife - elapsed);
            } else {
                // If damaged, ensure it's marked for immediate removal
                this.lifeRemaining = 0;
            }

        } else { // Defender laser
            this.x += this.vx * deltaTime; // Defender laser's origin moves
            this.y += this.vy * deltaTime;

            // Calculate the tip of the defender laser for collision detection
            const tipX = this.x + Math.cos(this.angle) * this.initialLength;
            const tipY = this.y + Math.sin(this.angle) * this.initialLength;

            // Check for collision with the actual target object
            // Use a larger collision radius for defender lasers to make them more effective
            const collisionRadius = 20 * SCALE_FACTOR; // Increased from 10
            if (this.actualTarget && Math.hypot(tipX - this.actualTarget.x, tipY - this.actualTarget.y) < (this.actualTarget.size / 2) + collisionRadius && !this.hasDamaged) {
                // The target object is already known: this.actualTarget
                this.actualTarget.takeDamage(this.damage, this.angle, tipX, tipY); // Pass actual impact coordinates
                createExplosion(tipX, tipY, this.actualTarget.size, 'spark'); // Use actual impact point for explosion
                this.hasDamaged = true;
                this.lifeRemaining = 0; // Defender laser disappears immediately on impact
            } else {
                this.lifeRemaining -= deltaTime; // Defender laser also fades out
            }
        }

        this.element.style.opacity = this.lifeRemaining / this.initialLife;
        this.updatePosition();

        return this.lifeRemaining <= 0; // Return true if laser's time is up
      }

      remove() {
        this.element.style.display = 'none'; // Hide the element
        this.element.setAttribute('transform', 'translate(-9999,-9999)'); // Move off-screen
        this.shapeElement.removeAttribute('filter'); // Explicitly remove filter
        
        // Explicitly remove from DOM when returning to pool
        if (this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
        // Return to pool only if the pool is not full, otherwise allow for garbage collection
        if (laserPool.length < MAX_LASERS) {
            laserPool.push(this);
        }
      }

      updatePosition() {
        // Defensive check to prevent errors if x or y become undefined/NaN unexpectedly
        if (typeof this.x !== 'number' || isNaN(this.x) || typeof this.y !== 'number' || isNaN(this.y)) {
            console.error("Laser position (x or y) is invalid:", this.x, this.y, "Laser instance:", this);
            // Attempt to set to a safe default to prevent further errors for this instance
            this.x = 0; 
            this.y = 0;
            // If this happens, it indicates a deeper issue in how laser positions are managed.
            // The transform will still be applied with (0,0) for this frame.
        }

        let rotationDegrees = this.angle * 180 / Math.PI;
        
        if (this.type === 'user') {
            // Defensive check for currentTipX/Y as well, as they are derived
            if (typeof this.currentTipX !== 'number' || isNaN(this.currentTipX) || typeof this.currentTipY !== 'number' || isNaN(this.currentTipY)) {
                console.error("User Laser tip position (currentTipX or Y) is invalid:", this.currentTipX, this.currentTipY, "Laser instance:", this);
                this.currentTipX = this.x; // Fallback to base position
                this.currentTipY = this.y;
            }
            this.element.setAttribute('transform', `translate(${this.currentTipX}, ${this.currentTipY}) rotate(${rotationDegrees})`);
        } else { // type === 'defender'
            this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${rotationDegrees})`);
        }
      }
    }

    /**
     * Represents a nuke projectile.
     */
    class Nuke {
        constructor() {
            this.element = createSVGElement('g');
            this.element.setAttribute('class', 'nuke-projectile');
            // Do NOT append to gameplayLayer here; append in reset() to ensure it's on top.

            this.shapeElement = createSVGElement('circle');
            this.element.appendChild(this.shapeElement);

            // Ensure it's hidden and off-screen initially
            this.element.style.display = 'none';
            this.element.setAttribute('transform', 'translate(-9999,-9999)');
        }

        reset(startX, startY, targetX, targetY) {
            this.x = startX;
            this.y = startY;
            this.targetX = targetX;
            this.targetY = targetY;
            this.hasExploded = false;

            this.initialProjectileSize = 80 * SCALE_FACTOR; // Start large
            this.finalProjectileSize = 1 * SCALE_FACTOR; // Shrink to this size
            this.explosionRadius = 600 * SCALE_FACTOR; // Further reduced radius of destruction for the nuke
            this.speed = 5.0 / TARGET_FRAME_DURATION; // Speed remains the same

            this.vx = Math.cos(Math.atan2(targetY - startY, targetX - startX)) * this.speed;
            this.vy = Math.sin(Math.atan2(targetY - startY, targetX - startX)) * this.speed;

            // Store initial Y for progress calculation
            this.initialY = startY;

            // Calculate initial life based on distance and speed
            const distance = Math.hypot(targetX - startX, targetY - startY);
            this.initialLife = distance / this.speed; // Time to reach target
            this.life = this.initialLife; // Remaining life

            this.shapeElement.setAttribute('fill', 'url(#nukeGradient)'); // Use radial gradient
            this.shapeElement.removeAttribute('stroke'); // Remove stroke
            this.shapeElement.removeAttribute('stroke-width'); // Remove stroke-width
            this.shapeElement.setAttribute('filter', 'url(#laserGlow)'); // Apply a glow filter

            // Append to gameplayLayer here to ensure it's on top of other elements when activated
            gameplayLayer.appendChild(this.element);
            this.element.style.display = ''; // Make visible
            this.element.style.opacity = 1; // Ensure full opacity at start
            this.updatePosition(); // Initial position
        }

        update(deltaTime) {
            if (this.hasExploded) {
                this.life -= deltaTime; // Just fade out if already exploded
                this.element.style.opacity = this.life / this.initialLife;
                return this.life <= 0;
            }

            this.x += this.vx * deltaTime;
            this.y += this.vy * deltaTime;

            // Calculate progress for scaling (0 at startY, 1 at targetY)
            // Since it moves upwards, y decreases.
            const travelRange = this.initialY - this.targetY;
            let progress = 0;
            if (travelRange > 0) { // Avoid division by zero
                progress = (this.initialY - this.y) / travelRange;
                progress = Math.max(0, Math.min(1, progress)); // Clamp between 0 and 1
            }
            
            // Interpolate size based on progress
            const currentRadius = this.initialProjectileSize + (this.finalProjectileSize - this.initialProjectileSize) * progress;
            this.shapeElement.setAttribute('r', currentRadius);

            // Check if reached or passed target (since it moves upwards)
            if (this.y <= this.targetY) {
                this.explode();
                this.hasExploded = true;
                this.life = 500; // Give it a short life to fade out after explosion
            }

            this.updatePosition();
            return this.life <= 0; // Return true if nuke's time is up
        }

        explode() {
            playSpatialSound(nukeExplosionBuffer, this.x, 1.5); // Play nuke explosion sound, louder

            // Trigger full-screen white flash
            if (nukeFlashElement) {
                nukeFlashElement.setAttribute('x', 0);
                nukeFlashElement.setAttribute('y', 0);
                nukeFlashElement.setAttribute('width', width);
                nukeFlashElement.setAttribute('height', height);
                nukeFlashElement.setAttribute('fill', 'white');
                nukeFlashElement.style.transition = 'none'; // Disable transition for instant flash
                nukeFlashElement.style.opacity = 1;
                nukeFlashElement.style.display = ''; // Make visible

                // Trigger fade after a very short delay to ensure opacity 1 is rendered
                setTimeout(() => {
                    nukeFlashElement.style.transition = 'opacity 1.5s ease-out'; // Longer 1.5s fade
                    nukeFlashElement.style.opacity = 0;
                }, 10); // Small delay

                // Hide element after transition
                setTimeout(() => {
                    nukeFlashElement.style.display = 'none';
                }, 1510); // 10ms delay + 1500ms transition
            }

            // Create the main expanding fireball visual effect
            let fireball = fireballPool.pop();
            if (!fireball) {
                fireball = new FireballEffect();
            }
            // Nuke fireball, type is 'nuke'
            fireball.reset(this.x, this.y, this.explosionRadius * SCALE_FACTOR, 2000, 'nuke');
            activeFireballs.push(fireball);

            // Still create some smaller particles for added visual chaos
            createExplosion(this.x, this.y, this.explosionRadius * 0.75 * SCALE_FACTOR, 'nukeFireball'); // Increased particle base size
            
            destroyObjectsInRadius(this.x, this.y, this.explosionRadius * SCALE_FACTOR, true); // Pass true for isNukeHit
            this.element.style.display = 'none'; // Hide immediately on explosion
        }

        remove() {
            this.element.style.display = 'none'; // Hide the element
            this.element.setAttribute('transform', 'translate(-9999,-9999)'); // Move off-screen
            this.shapeElement.removeAttribute('filter'); // Explicitly remove filter
            
            // Explicitly remove from DOM when returning to pool
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            // Return to pool only if the pool is not full, otherwise allow for garbage collection
            if (nukePool.length < MAX_NUKES) {
                nukePool.push(this);
            }
        }

        updatePosition() {
            this.element.setAttribute('transform', `translate(${this.x}, ${this.y})`);
            this.shapeElement.setAttribute('cx', 0); // Center circle within its group
            this.shapeElement.setAttribute('cy', 0);
        }
    }

    /**
     * Represents an expanding circular fireball effect.
     */
    class FireballEffect {
        constructor() {
            this.element = createSVGElement('circle');
            this.element.setAttribute('class', 'fireball-effect');

            // Ensure it's hidden and off-screen initially
            this.element.style.display = 'none';
            this.element.setAttribute('cx', -9999);
            this.element.setAttribute('cy', -9999);
        }

        reset(x, y, maxRadius, durationMs, type = 'visual') {
            this.x = x;
            this.y = y;
            this.maxRadius = maxRadius;
            this.duration = durationMs;
            this.startTime = Date.now();
            this.isAlive = true;
            this.type = type; // Store the type
            this.hasAppliedDamage = false; // New: Flag to ensure damage is applied only once

            this.element.setAttribute('cx', this.x);
            this.element.setAttribute('cy', this.y);
            // Append to effectsLayer here to ensure it's on top of other elements when activated
            effectsLayer.appendChild(this.element);
            this.element.setAttribute('r', 0); // Start with zero radius
            this.element.setAttribute('fill', 'url(#fireballGradient)'); // Use the new gradient
            this.element.style.opacity = 1; // Start fully opaque
            this.element.style.display = ''; // Make visible
        }

        update() {
            const elapsed = Date.now() - this.startTime;
            let progress = elapsed / this.duration;

            if (progress >= 1) {
                this.isAlive = false;
                this.element.style.display = 'none'; // Hide when dead
                return true; // Mark for removal
            }

            // Ease-out for radius growth
            const easedProgress = 1 - Math.pow(1 - progress, 2); // Quadratic ease-out
            const currentRadius = this.maxRadius * easedProgress;
            this.element.setAttribute('r', currentRadius);

            // Apply damage only once when the fireball reaches a significant size
            if (this.type === 'nuke' && !this.hasAppliedDamage && progress >= 0.2) { // Apply damage when 20% grown
                destroyObjectsInRadius(this.x, this.y, currentRadius, true); // Pass true for isNukeHit
                this.hasAppliedDamage = true; // Set flag to prevent repeated damage
            }

            // Fade out towards the end
            const fadeStartProgress = 0.7; // Start fading when 70% of duration is complete
            if (progress > fadeStartProgress) {
                const fadeProgress = (progress - fadeStartProgress) / (1 - fadeStartProgress);
                this.element.style.opacity = 1 - fadeProgress;
            } else {
                this.element.style.opacity = 1;
            }
            return false; // Still alive
        }

        remove() {
            this.element.style.display = 'none';
            this.element.setAttribute('cx', -9999);
            this.element.setAttribute('cy', -9999);
            
            // Explicitly remove from DOM when returning to pool
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            // Return to pool only if the pool is not full, otherwise allow for garbage collection
            if (fireballPool.length < MAX_FIREBALLS) {
                fireballPool.push(this);
            }
        }
    }

    /**
     * Represents a UFO.
     */
    class UFO {
      constructor() {
        this.x = random(width * 0.2, width * 0.8);
        this.y = random(height * 0.2, height * 0.8);
        this.size = random(40, 70) * SCALE_FACTOR; // This is the final, normal size of the UFO
        this.currentVisualScale = 0.01; // Start very small for warp-in effect
        this.warpInStartTime = Date.now();
        this.warpInDuration = 1000 * SCALE_FACTOR; // 1 second warp-in duration

        this.initialHealth = 500 * SCALE_FACTOR; // Increased UFO health
        this.health = 500 * SCALE_FACTOR; // UFOs start with full health
        // Convert velocities to per-millisecond for delta time scaling
        this.vx = random(-1.5, 1.5) / TARGET_FRAME_DURATION; // Increased speed
        this.vy = random(-1.5, 1.5) / TARGET_FRAME_DURATION; // Increased speed
        this.rotation = random(0, 360);
        // Convert rotational velocity to per-millisecond for delta time scaling
        this.vRotation = random(-0.2, 0.2) / TARGET_FRAME_DURATION;
        this.element = createSVGElement('g');
        this.element.setAttribute('class', 'ufo');
        // No initial opacity transition on the main group for the break-apart effect
        gameplayLayer.appendChild(this.element); // Append to gameplay layer

        this.parts = []; // To store references to individual SVG elements
        this.crackGroup = createSVGElement('g'); // Group for cracks (will be appended later)
        this.healthBarGroup = createSVGElement('g'); // New: Group for health bar
        gameplayLayer.appendChild(this.healthBarGroup); // Append health bar group directly to gameplay layer

        this.messageGroup = null; // New: Group for UFO message (rect + text)

        this.drawUFO(); // Initial drawing - populates this.parts and message elements
        this.drawHealthBar(); // Draw health bar (appends health bar elements to healthBarGroup)

        // Ensure crackGroup is appended last to be on top of all other UFO parts
        this.element.appendChild(this.crackGroup);

        // Append messageGroup to healthBarGroup so it moves and positions relative to the health bar
        this.healthBarGroup.appendChild(this.messageGroup);

        playSpatialSound(ufoBuffer, this.x); // Play UFO appearance sound with spatial audio
        // Message display is now handled by spawnUFO() for the group and managed by queue
        // this.displayMessage();

        // Initialize activeCrackEffects and damageThresholds for UFO
        this.activeCrackEffects = []; // Array to hold active CrackEffect instances
        this.damageStagesHit = 0; // Track how many damage stages have been hit
        this.damageThresholds = [0.75, 0.50, 0.25]; // Health ratios for new crack stages
      }

      /**
       * Generates points for a symmetrical polygon, typically for UFO parts.
       * The shape is generated for the right half (positive X) and then mirrored to the left (negative X).
       * @param {number} numSegments - Number of segments for one half of the shape (e.g., 3 segments means 4 points).
       * @param {number} irregularity - How much points deviate from a smooth curve (0-1).
       * @param {number} baseWidth - The approximate maximum width of the shape.
       * @param {number} baseHeight - The approximate maximum height of the shape.
       * @param {number} [offsetX=0] - Horizontal offset from the UFO's center.
       * @param {number} [offsetY=0] - Vertical offset from the UFO's center.
       * @param {number} [rotationDegrees=0] - Rotation of the entire shape around its own center.
       * @returns {string} SVG points string.
       */
      generateSymmetricalShapePoints(numSegments, irregularity, baseWidth, baseHeight, offsetX = 0, offsetY = 0, rotationDegrees = 0) {
        let rightHalfPoints = [];
        // Generate points for the right half, from top to bottom
        for (let i = 0; i <= numSegments; i++) {
          const progress = i / numSegments; // Progress from 0 to 1 along the height
          
          // Use a sine wave for width variation to create a "waist" or "bulge" effect
          // This makes the shape more organic and less boxy.
          const currentWidthFactor = Math.sin(progress * Math.PI); // 0 at top/bottom, 1 in middle
          const currentWidth = (baseWidth / 2) * (0.2 + 0.8 * currentWidthFactor); // Min width 20% of max, max 100%
          
          const x = currentWidth * (1 + random(-irregularity, irregularity));
          const y = (progress - 0.5) * baseHeight * (1 + random(-irregularity * 0.5, irregularity * 0.5)); // Y from -baseHeight/2 to +baseHeight/2

          rightHalfPoints.push({ x: x, y: y });
        }

        let allPoints = [];
        // Add points for the right side (top to bottom)
        for (let i = 0; i < rightHalfPoints.length; i++) {
          allPoints.push(rightHalfPoints[i]);
        }
        // Add points for the left side (bottom to top, mirrored X)
        for (let i = rightHalfPoints.length - 1; i >= 0; i--) {
          allPoints.push({ x: -rightHalfPoints[i].x, y: rightHalfPoints[i].y });
        }

        // Apply rotation and offset to all points
        const radRotation = rotationDegrees * Math.PI / 180;
        const transformedPoints = allPoints.map(p => {
          const rotatedX = p.x * Math.cos(radRotation) - p.y * Math.sin(radRotation);
          const rotatedY = p.x * Math.sin(radRotation) + p.y * Math.cos(radRotation);
          return `${rotatedX + offsetX},${rotatedY + offsetY}`;
        });

        return transformedPoints.join(' ');
      }

      /**
       * Draws the UFO's SVG elements with procedural variations while ensuring symmetry.
       */
      drawUFO() {
        // Clear existing parts (excluding crackGroup and health bars)
        const children = Array.from(this.element.children);
        children.forEach(child => {
            if (child !== this.crackGroup && child !== this.healthBarBg && child !== this.healthBarFg) {
                this.element.removeChild(child);
            }
        });
        this.parts = []; // Reset parts array

        // --- Main Body ---
        const mainBodyWidth = this.size * random(1.5, 2.5) * SCALE_FACTOR; // Wider main body
        const mainBodyHeight = this.size * random(0.4, 0.8) * SCALE_FACTOR; // Made flatter (reduced height range)
        const mainBodySegments = Math.floor(random(4, 8)); // More segments for main body
        const mainBodyIrregularity = random(0.1, 0.3);

        const mainBodyPoints = this.generateSymmetricalShapePoints(
            mainBodySegments, mainBodyIrregularity, mainBodyWidth, mainBodyHeight
        );
        const mainBody = createSVGElement('polygon');
        mainBody.setAttribute('points', mainBodyPoints);
        mainBody.setAttribute('fill', `url(#${generateRandomUfoGradient()})`);
        this.element.appendChild(mainBody);
        this.parts.push(mainBody);

        // --- Cockpit / Top Dome ---
        const cockpitWidth = mainBodyWidth * random(0.3, 0.6) * SCALE_FACTOR;
        const cockpitHeight = mainBodyHeight * random(0.2, 0.4) * SCALE_FACTOR;
        const cockpitSegments = Math.floor(random(3, 5));
        const cockpitIrregularity = random(0.05, 0.15);
        const cockpitOffsetY = -mainBodyHeight * random(0.2, 0.4) * SCALE_FACTOR; // Position above center

        const cockpitPoints = this.generateSymmetricalShapePoints(
            cockpitSegments, cockpitIrregularity, cockpitWidth, cockpitHeight, 0, cockpitOffsetY
        );
        const cockpit = createSVGElement('polygon');
        cockpit.setAttribute('points', cockpitPoints);
        cockpit.setAttribute('fill', `url(#${generateRandomUfoGradient()})`);
        this.element.appendChild(cockpit);
        this.parts.push(cockpit);

        // --- Side Wings / Appendages ---
        const numWingPairs = Math.floor(random(1, 3)); // 1 to 2 pairs of wings
        for (let i = 0; i < numWingPairs; i++) {
            const wingWidth = mainBodyWidth * random(0.4, 0.7) * SCALE_FACTOR;
            const wingHeight = mainBodyHeight * random(0.1, 0.3) * SCALE_FACTOR;
            const wingSegments = Math.floor(random(2, 4));
            const wingIrregularity = random(0.1, 0.25);
            const wingOffsetX = mainBodyWidth * random(0.4, 0.6) * SCALE_FACTOR; // Position further out
            const wingOffsetY = mainBodyHeight * random(-0.2, 0.2) * SCALE_FACTOR; // Vertical position relative to main body

            // Right Wing
            const rightWingPoints = this.generateSymmetricalShapePoints(
                wingSegments, wingIrregularity, wingWidth, wingHeight, wingOffsetX, wingOffsetY, random(-15, 15) // Slight rotation
            );
            const rightWing = createSVGElement('polygon');
            rightWing.setAttribute('points', rightWingPoints);
            rightWing.setAttribute('fill', `url(#${generateRandomUfoGradient()})`);
            this.element.appendChild(rightWing);
            this.parts.push(rightWing);

            // Left Wing (mirrored)
            const leftWingPoints = this.generateSymmetricalShapePoints(
                wingSegments, wingIrregularity, wingWidth, wingHeight, -wingOffsetX, wingOffsetY, random(-15, 15) // Slight rotation
            );
            const leftWing = createSVGElement('polygon');
            leftWing.setAttribute('points', leftWingPoints);
            leftWing.setAttribute('fill', `url(#${generateRandomUfoGradient()})`);
            this.element.appendChild(leftWing);
            this.parts.push(leftWing);
        }

        // --- Rear Thrusters ---
        const numThrusters = Math.floor(random(2, 4)); // 2 to 3 thrusters
        const thrusterSpacing = mainBodyWidth * 0.15 * SCALE_FACTOR;
        const thrusterBaseY = mainBodyHeight * random(0.4, 0.6) * SCALE_FACTOR; // Position at the rear

        for (let i = 0; i < numThrusters; i++) {
            const thrusterWidth = this.size * random(0.1, 0.2) * SCALE_FACTOR;
            const thrusterHeight = this.size * random(0.2, 0.4) * SCALE_FACTOR;
            const thrusterSegments = Math.floor(random(2, 3));
            const thrusterIrregularity = random(0.05, 0.1);

            const thrusterOffsetX = (i - (numThrusters - 1) / 2) * thrusterSpacing; // Center thrusters
            
            const thrusterPoints = this.generateSymmetricalShapePoints(
                thrusterSegments, thrusterIrregularity, thrusterWidth, thrusterHeight, thrusterOffsetX, thrusterBaseY, 180 // Point downwards
            );
            const thruster = createSVGElement('polygon');
            thruster.setAttribute('points', thrusterPoints);
            thruster.setAttribute('fill', `url(#${generateRandomUfoGradient()})`);
            this.element.appendChild(thruster);
            this.parts.push(thruster);
        }

        // --- Symmetrical "Eyes" / "Sensors" (Glowing circles) ---
        const numEyePairs = Math.floor(random(1, 2)); // 1 pair of eyes
        const eyeRadius = this.size * random(0.05, 0.1) * SCALE_FACTOR;
        const eyeAttachY = -mainBodyHeight * random(0.3, 0.5) * SCALE_FACTOR; // Attach near the top of the main body
        const eyeAttachXOffset = mainBodyWidth * random(0.15, 0.25) * SCALE_FACTOR; // Offset from center

        for (let i = 0; i < numEyePairs; i++) {
            const currentEyeAttachX = eyeAttachXOffset * random(0.9, 1.1);
            const currentEyeRadius = eyeRadius * random(0.8, 1.2);

            // Right Eye
            const eyeRight = createSVGElement('circle');
            eyeRight.setAttribute('cx', currentEyeAttachX);
            eyeRight.setAttribute('cy', eyeAttachY);
            eyeRight.setAttribute('r', currentEyeRadius);
            eyeRight.setAttribute('fill', `hsl(${random(180, 240)}, 100%, ${random(60, 90)}%)`); // Blueish glow
            this.element.appendChild(eyeRight);
            this.parts.push(eyeRight);

            // Left Eye (mirrored)
            const eyeLeft = createSVGElement('circle');
            eyeLeft.setAttribute('cx', -currentEyeAttachX);
            eyeLeft.setAttribute('cy', eyeAttachY);
            eyeLeft.setAttribute('r', currentEyeRadius);
            eyeLeft.setAttribute('fill', `hsl(${random(180, 240)}, 100%, ${random(60, 90)}%)`);
            this.element.appendChild(eyeLeft);
            this.parts.push(eyeLeft);
        }

        // --- UFO Message (SVG rect + text) ---
        this.messageGroup = createSVGElement('g');
        this.messageGroup.style.display = 'none'; // Hidden by default

        this.messageBg = createSVGElement('rect');
        this.messageBg.setAttribute('rx', 5); // Rounded corners
        this.messageBg.setAttribute('ry', 5);
        this.messageGroup.appendChild(this.messageBg);

        this.messageText = createSVGElement('text');
        this.messageText.setAttribute('text-anchor', 'middle'); // Center text horizontally
        this.messageText.setAttribute('dominant-baseline', 'hanging'); // Align text to top for easier background sizing
        this.messageText.setAttribute('font-family', 'Space Mono, monospace'); // Techy font
        this.messageText.setAttribute('font-size', `${1.2 * SCALE_FACTOR}em`); // Relative font size
        this.messageText.setAttribute('fill', '#aaffaa'); // Default text color
        this.messageGroup.appendChild(this.messageText);
      }

      /**
       * Adds new cracks to the UFO based on damage stages hit.
       * @param {number} numNewCracks - The number of new crack elements to add.
       */
      addDamageCracks(numNewCracks) {
          if (!this.crackGroup) return;
          const settings = qualitySettings[currentQualityLevel];

          for (let i = 0; i < numNewCracks; i++) {
              const crack = createSVGElement('path');
              const crackSize = random(this.size * settings.ufoCrackSizeFactor[0], this.size * settings.ufoCrackSizeFactor[1]);
              // Calculate max allowed center radius for crack to stay within UFO's main body (polygon)
              // Approximate with a bounding circle based on the average size
              const maxCrackCenterRadius = this.size * 0.8 - crackSize;
              const crackAngle = random(0, Math.PI * 2);
              const crackCenterDist = random(0, maxCrackCenterRadius); // Distance from UFO's center
              const startX = crackCenterDist * Math.cos(crackAngle);
              const startY = crackCenterDist * Math.sin(crackAngle);

              let pathData = `M${startX},${startY}`;
              const numSegments = Math.floor(random(settings.ufoCrackSegments[0], settings.ufoCrackSegments[1]));
              for (let j = 0; j < numSegments; j++) {
                  // Generate segment points relative to the crack's start point and within its size
                  const segmentOffsetX = random(-crackSize, crackSize);
                  const segmentOffsetY = random(-crackSize, crackSize);
                  pathData += ` L${startX + segmentOffsetX},${startY + segmentOffsetY}`;
              }

              // The final shaded color for the crack (UFO cracks are always dark grey/black)
              const shadedCrackColor = 'rgb(20,20,25)'; 
              const glowingCrackFadeDuration = 5000; // Duration for the glowing crack to fade out

              // Shaded crack (bottom layer)
              const shadedCrack = createSVGElement('path');
              shadedCrack.setAttribute('d', pathData);
              shadedCrack.setAttribute('fill', 'none'); // Cracks are outlines
              shadedCrack.setAttribute('stroke', shadedCrackColor); // Solid shaded color
              shadedCrack.setAttribute('stroke-width', random(1, 3));
              shadedCrack.setAttribute('opacity', settings.crackFinalOpacity); // Set final opacity for the shaded crack
              this.crackGroup.appendChild(shadedCrack);

              // Glowing crack (top layer)
              const glowingCrack = createSVGElement('path');
              glowingCrack.setAttribute('d', pathData);
              glowingCrack.setAttribute('fill', 'none'); // Cracks are outlines
              glowingCrack.setAttribute('stroke', 'url(#crackGradient)'); // Use gradient stroke
              glowingCrack.setAttribute('stroke-width', random(1, 3));
              glowingCrack.setAttribute('filter', 'url(#crackGlowFilter)'); // Apply the shared glow filter
              // Opacity is managed by CrackEffect
              this.crackGroup.appendChild(glowingCrack);

              // Add CrackEffect for the glowing crack
              this.activeCrackEffects.push(new CrackEffect(glowingCrack, glowingCrackFadeDuration));
          }
      }

      /**
       * Draws the UFO's health bar.
       */
      drawHealthBar() {
          // Health bar background
          this.healthBarBg = createSVGElement('rect');
          this.healthBarBg.setAttribute('x', -this.size * 0.7 * SCALE_FACTOR); // Relative to UFO center
          this.healthBarBg.setAttribute('y', this.size + 10 * SCALE_FACTOR); // Below UFO
          this.healthBarBg.setAttribute('width', this.size * 1.4 * SCALE_FACTOR);
          this.healthBarBg.setAttribute('height', 8 * SCALE_FACTOR);
          this.healthBarBg.setAttribute('fill', '#333');
          this.healthBarBg.setAttribute('rx', 3 * SCALE_FACTOR);
          this.healthBarBg.setAttribute('ry', 3 * SCALE_FACTOR);
          this.healthBarGroup.appendChild(this.healthBarBg); // Append to healthBarGroup

          // Health bar foreground
          this.healthBarFg = createSVGElement('rect');
          this.healthBarFg.setAttribute('x', -this.size * 0.7 * SCALE_FACTOR);
          this.healthBarFg.setAttribute('y', this.size + 10 * SCALE_FACTOR);
          this.healthBarFg.setAttribute('height', 8 * SCALE_FACTOR);
          this.healthBarFg.setAttribute('rx', 3 * SCALE_FACTOR);
          this.healthBarFg.setAttribute('ry', 3 * SCALE_FACTOR);
          this.healthBarGroup.appendChild(this.healthBarFg); // Append to healthBarGroup

          this.updateHealthBar(); // Initial update
      }

      /**
       * Updates the visual representation of the health bar.
       */
      updateHealthBar() {
          if (!this.healthBarFg) return;
          const totalBarWidth = this.size * 1.4 * SCALE_FACTOR;
          const healthWidth = (this.health / this.initialHealth) * totalBarWidth;
          this.healthBarFg.setAttribute('width', Math.max(0, healthWidth)); // Ensure width doesn't go negative

          // Color change based on health
          let healthColor;
          if (this.health > 70) {
              healthColor = '#00FF00'; // Green
          } else if (this.health > 30) {
              healthColor = '#FFFF00'; // Yellow
          } else {
              healthColor = '#FF0000'; // Red
          }
          this.healthBarFg.setAttribute('fill', healthColor);
      }


      update(deltaTime) {
        const now = Date.now();

        // Handle warp-in scaling
        if (now < this.warpInStartTime + this.warpInDuration) {
          const progress = (now - this.warpInStartTime) / this.warpInDuration;
          // Cubic ease-out for smoother acceleration at the beginning and deceleration at the end
          const easedProgress = 1 - Math.pow(1 - progress, 3);
          this.currentVisualScale = 0.01 + (1 - 0.01) * easedProgress;
        } else {
          this.currentVisualScale = 1; // Ensure it's at full scale after warp-in
        }

        this.x += this.vx * deltaTime; // Scaled by delta time
        this.y += this.vy * deltaTime; // Scaled by delta time
        this.rotation += this.vRotation * deltaTime; // Scaled by delta time

        // Update health bar position (independent of UFO rotation)
        this.healthBarGroup.setAttribute('transform', `translate(${this.x}, ${this.y})`);

        // Update and clean up crack effects
        if (this.activeCrackEffects) {
            for (let i = this.activeCrackEffects.length - 1; i >= 0; i--) {
                const effect = this.activeCrackEffects[i];
                if (effect.update()) { // If the effect is dead
                    if (effect.element.parentNode === this.crackGroup) { // Ensure it's still a child
                        this.crackGroup.removeChild(effect.element);
                    }
                    this.activeCrackEffects.splice(i, 1);
                }
            }
        }

        // Wrap around - use the actual rendered size for boundary checks
        const actualRenderedSize = this.size * this.currentVisualScale;
        if (this.x < -actualRenderedSize * 2) this.x = width + actualRenderedSize * 2;
        if (this.x > width + actualRenderedSize * 2) this.x = -actualRenderedSize * 2;
        if (this.y < -actualRenderedSize * 2) this.y = height + actualRenderedSize * 2;
        if (this.y > height + actualRenderedSize * 2) this.y = -actualRenderedSize * 2;

        // Apply translation, rotation, and scale
        this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${this.rotation}) scale(${this.currentVisualScale})`);
      }

      /**
       * Applies damage to the UFO.
       * @param {number} damage - Amount of damage to apply.
       * @param {number} laserAngle - Angle of the incoming laser for deflection.
       */
      takeDamage(damage, laserAngle, impactX, impactY) { // Added impactX, impactY
        this.health -= damage;

        // Play spark sound on hit (reduced volume to avoid cutting off laser sound)
        playSpatialSound(sparkSoundBuffer, this.x, 0.2); // Play spark sound, even quieter

        const currentHealthRatio = this.health / this.initialHealth;
        // Check if a new damage stage has been hit
        for (let i = this.damageThresholds.length - 1; i >= 0; i--) {
            if (currentHealthRatio <= this.damageThresholds[i] && i >= this.damageStagesHit) {
                // New stage hit, add cracks
                // UFO cracks are always linear, no starburst for UFOs
                this.addDamageCracks(1 + i, impactX, impactY, 'linear'); // Pass impact coordinates and force 'linear' type
                this.damageStagesHit = i + 1; // Update stage hit
                break; // Only add cracks for the highest stage hit
            }
        }
        this.updateHealthBar(); // Update health bar on damage

        // Calculate health ratio to determine resistance
        const healthRatio = Math.max(0, this.health / this.initialHealth); // Clamp to 0 to prevent negative health issues
        // deflectionMultiplier is 0 when health is full, and 1 when health is zero.
        const deflectionMultiplier = 1 - healthRatio;

        // Apply deflection based on laser angle, scaled by health
        const baseDeflectionForce = 0.2 / TARGET_FRAME_DURATION; // Increased base deflection force
        const actualDeflectionForce = baseDeflectionForce * deflectionMultiplier;

        this.vx += Math.cos(laserAngle) * actualDeflectionForce;
        this.vy += Math.sin(laserAngle) * actualDeflectionForce;

        // Apply rotational deflection, scaled by health
        const baseVRotationMagnitude = 0.5 / TARGET_FRAME_DURATION; // Max random rotation magnitude
        const actualVRotation = random(-baseVRotationMagnitude, baseVRotationMagnitude) * deflectionMultiplier;
        this.vRotation += actualVRotation;

        if (this.health <= 0) {
          this.destroy();
        }
      }

      destroy() {
        // Calculate pitch based on UFO size: larger UFOs get lower pitch
        const minOverallSize = MIN_ASTEROID_SIZE; // Use asteroid min size as a reference for the smallest possible object
        const maxOverallSize = MAX_ASTEROID_SIZE; // Use asteroid max size as a reference for the largest possible object
        const minTargetPitch = 0.05; // Pitch for largest objects (made even lower for very bassy sound)
        const maxTargetPitch = 1.3; // Pitch for smallest objects

        const normalizedSize = (this.size - minOverallSize) / (maxOverallSize - minOverallSize);
        const clampedNormalizedSize = Math.max(0, Math.min(1, normalizedSize)); // Ensure value is between 0 and 1
        const basePitch = maxTargetPitch - (clampedNormalizedSize * (maxTargetPitch - minTargetPitch));
        const finalPitch = basePitch * random(0.9, 1.1); // Add +/- 10% random variation

        playSpatialSound(explosionBuffer, this.x, 1, finalPitch); // Play explosion sound with spatial audio
        createExplosion(this.x, this.y, this.size * 1.2, 'explosion'); // Slightly smaller explosion for UFO

        // Remove all active crack effects' elements
        // Remove all crack elements that are still children of this.crackGroup
        while (this.crackGroup.firstChild) {
            this.crackGroup.removeChild(this.crackGroup.firstChild);
        }
        this.activeCrackEffects = []; // Clear the array immediately

        // Remove this UFO instance from the global ufos array
        const index = ufos.indexOf(this);
        if (index > -1) {
            ufos.splice(index, 1);
        }

        // If this UFO had a message group, remove it and its filter
        if (this.messageGroup && this.messageGroup.parentNode) {
            this.messageGroup.parentNode.removeChild(this.messageGroup);
            // Also remove the associated filter from defs to prevent leaks
            const filterId = `ufoMessageShadow-${this.id}`;
            const filterElement = document.getElementById(filterId);
            if (filterElement && filterElement.parentNode) {
                filterElement.parentNode.removeChild(filterElement);
            }
        }

        // Remove health bar group from DOM
        if (this.healthBarGroup && this.healthBarGroup.parentNode) {
            this.healthBarGroup.parentNode.removeChild(this.healthBarGroup);
        }

        // Conditional part animation for quality levels
        if (currentQualityLevel === 'low') {
            // For low quality, just remove the main element
            if (this.element.parentNode) {
                canvas.removeChild(this.element);
            }
        } else {
            // Detach and animate individual parts for medium/high quality
            const ufoAbsoluteX = this.x;
            const ufoAbsoluteY = this.y;
            const ufoCurrentRotation = this.rotation;
            const ufoCurrentScale = this.currentVisualScale;

            this.parts.forEach(part => {
                // Get the part's current transformation matrix relative to the UFO's group
                // This is a simplified way to get its initial relative position and rotation
                // assuming the part itself doesn't have complex transforms before destruction.
                const bbox = part.getBBox();
                let initialPartX = bbox.x + bbox.width / 2; // Center of the part relative to UFO's group (0,0)
                let initialPartY = bbox.y + bbox.height / 2;

                // Remove part from UFO group and append directly to effectsLayer
                if (part.parentNode === this.element) {
                    this.element.removeChild(part);
                }
                effectsLayer.appendChild(part); // Now it's a direct child of the effects layer

                // Calculate initial absolute position and rotation for the detached part
                // Apply UFO's current rotation and scale to the part's relative position
                const rotatedScaledX = initialPartX * Math.cos(ufoCurrentRotation * Math.PI / 180) * ufoCurrentScale - initialPartY * Math.sin(ufoCurrentRotation * Math.PI / 180) * ufoCurrentScale;
                const rotatedScaledY = initialPartX * Math.sin(ufoCurrentRotation * Math.PI / 180) * ufoCurrentScale + initialPartY * Math.cos(ufoCurrentRotation * Math.PI / 180) * ufoCurrentScale;

                let currentPartAbsoluteX = ufoAbsoluteX + rotatedScaledX;
                let currentPartAbsoluteY = ufoAbsoluteY + rotatedScaledY;
                let currentPartRotation = ufoCurrentRotation; // Part starts with UFO's current rotation

                // Randomize velocity and rotation for explosion (even slower)
                const angle = Math.random() * 2 * Math.PI;
                const speed = random(0.02, 0.1); // Further reduced speed for slower disintegration
                const vx = speed * Math.cos(angle);
                const vy = speed * Math.sin(angle);
                // Inherit UFO's rotational velocity and add some random variation
                const rotationSpeed = this.vRotation + random(-0.1, 0.1); 

                const partFadeDuration = 4000; // 4 seconds for parts to fade (increased)

                // Add to global explodingUfoParts array for centralized animation
                explodingUfoParts.push(new UFOExplodingPart(
                    part,
                    currentPartAbsoluteX,
                    currentPartAbsoluteY,
                    currentPartRotation,
                    vx, vy, rotationSpeed,
                    partFadeDuration, partFadeDuration
                ));
            });

            // Remove the main UFO group element after all parts have been detached
            if (this.element.parentNode) {
                gameplayLayer.removeChild(this.element); // Remove from gameplay layer
            }
        }

        // Create a fireball effect for the UFO explosion AFTER parts have been moved
        let fireball = fireballPool.pop();
        if (!fireball) {
            fireball = new FireballEffect();
        }
        fireball.reset(this.x, this.y, this.size * 1.5 * SCALE_FACTOR, 800, 'visual'); // Reduced size and duration for UFO fireball
        activeFireballs.push(fireball);
      }

      /**
       * Displays a random hardcoded message from the UFO.
       */
      displayMessage = (callback) => { // Changed to arrow function for consistent 'this' binding, added callback
        const settings = qualitySettings[currentQualityLevel];
        // Construct a 2-3 word message from the ufoWords list
        let message = "";
        const numWords = Math.floor(random(2, 4)); // 2 or 3 words
        for (let i = 0; i < numWords; i++) {
          const word = ufoWords[Math.floor(random(0, ufoWords.length))];
          message += (i > 0 ? " " : "") + word;
        }

        this.messageText.textContent = `"${message}"`; // Add double quotes around the message
        
        // Position the message group below the health bar
        const messageYOffset = this.size + 10 * SCALE_FACTOR + 8 * SCALE_FACTOR + 10 * SCALE_FACTOR; // UFO size + health bar offset + health bar height + padding
        this.messageGroup.setAttribute('transform', `translate(0, ${messageYOffset})`);

        // Get text bounding box to size the background rectangle
        // Must be visible to get accurate bbox
        this.messageGroup.style.display = ''; 
        const bbox = this.messageText.getBBox();
        const padding = 5 * SCALE_FACTOR; // Reduced padding for a smaller border
        const bgWidth = bbox.width + padding * 2;
        const bgHeight = bbox.height + padding * 2;
        const bgX = bbox.x - padding;
        const bgY = bbox.y - padding;

        this.messageBg.setAttribute('x', bgX);
        this.messageBg.setAttribute('y', bgY);
        this.messageBg.setAttribute('width', bgWidth);
        this.messageBg.setAttribute('height', bgHeight);

        // Center the text within its background
        this.messageText.setAttribute('x', bbox.x + bbox.width / 2); // Center X of text relative to its own bbox
        this.messageText.setAttribute('y', bbox.y + bbox.height / 2); // Center Y of text relative to its own bbox
        this.messageText.setAttribute('dominant-baseline', 'middle'); // Re-align to middle for centering

        // Apply styling based on quality settings
        if (settings.ufoMessageTransparency) {
            this.messageBg.setAttribute('fill', 'rgba(20, 20, 40, 0.9)');
            this.messageText.setAttribute('fill', '#aaffaa');
            this.messageBg.setAttribute('stroke', '#66bb66');
            this.messageBg.setAttribute('stroke-width', 1);
        } else {
            this.messageBg.setAttribute('fill', 'rgb(20, 20, 40)'); // Solid dark background
            this.messageText.setAttribute('fill', 'rgb(170, 255, 170)'); // Solid green text
            this.messageBg.setAttribute('stroke', 'rgb(102, 187, 102)'); // Solid green border
            this.messageBg.setAttribute('stroke-width', 1);
        }

        if (settings.ufoMessageShadow) {
            // SVG filters for shadow
            const filterId = `ufoMessageShadow-${this.id}`; // Unique filter ID per UFO
            let filter = document.getElementById(filterId);
            if (!filter) {
                filter = createSVGElement('filter');
                filter.setAttribute('id', filterId);
                filter.setAttribute('x', '-50%');
                filter.setAttribute('y', '-50%');
                filter.setAttribute('width', '200%');
                filter.setAttribute('height', '200%');
                const feDropShadow = createSVGElement('feDropShadow');
                feDropShadow.setAttribute('dx', '0');
                feDropShadow.setAttribute('dy', '0');
                feDropShadow.setAttribute('stdDeviation', '5'); // Blur radius
                feDropShadow.setAttribute('flood-color', 'rgba(100, 200, 100, 0.5)'); // Shadow color
                filter.appendChild(feDropShadow);
                canvas.querySelector('defs').appendChild(filter);
            }
            this.messageBg.setAttribute('filter', `url(#${filterId})`);
        } else {
            this.messageBg.removeAttribute('filter');
        }

        this.messageGroup.style.transition = `opacity ${settings.ufoMessageTransition}`;
        this.messageGroup.style.opacity = 1; // Show message
        speakRoboticText(message, 50); // Play robotic voice for the message, faster (50ms per char)

        setTimeout(() => {
          this.messageGroup.style.opacity = 0; // Fade out after 0.5 seconds
          setTimeout(() => {
              this.messageGroup.style.display = 'none'; // Hide after fade
              if (callback) callback(); // Signal completion
          }, parseFloat(settings.ufoMessageTransition) * 1000); // Wait for transition to complete
        }, 500); // Reduced from 1000ms to 500ms
      }
    }

    /**
     * Represents an individual particle for explosions/sparks.
     */
    class Particle {
        constructor(element, x, y, vx, vy, life, initialLife) {
            this.element = element;
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.lifeRemaining = life;
            this.initialLife = initialLife;
            this.element.style.display = ''; // Make visible
            this.element.style.opacity = 1; // Start full opacity
            this.element.style.pointerEvents = 'none'; // Ensure clicks pass through
        }

        update(deltaTime) {
            this.x += this.vx * deltaTime;
            this.y += this.vy * deltaTime;
            this.element.setAttribute('cx', this.x);
            this.element.setAttribute('cy', this.y);
            this.lifeRemaining -= deltaTime;
            this.element.style.opacity = this.lifeRemaining / this.initialLife;
            return this.lifeRemaining <= 0; // True if dead
        }

        remove() {
            this.element.style.display = 'none';
            this.element.setAttribute('cx', -9999); // Move off-screen
            this.element.setAttribute('cy', -9999); // Move off-screen
            this.element.removeAttribute('filter'); // Explicitly remove filter
            
            // Explicitly remove from DOM when returning to pool
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            particlePool.push(this.element); // Return the SVG element to the pool
        }
    }

    /**
     * Represents a detached UFO part during destruction.
     */
    class UFOExplodingPart {
        constructor(element, x, y, rotation, vx, vy, vRotation, life, initialLife) {
            this.element = element;
            this.x = x;
            this.y = y;
            this.rotation = rotation; // Initial rotation
            this.vx = vx;
            this.vy = vy;
            this.vRotation = vRotation; // Rotational velocity
            this.lifeRemaining = life;
            this.initialLife = initialLife;
            this.element.style.opacity = 1; // Start full opacity
        }

        update(deltaTime) {
            this.x += this.vx * deltaTime;
            this.y += this.vy * deltaTime;
            this.rotation += this.vRotation * deltaTime; // Re-added: pieces should rotate around their own axis
            this.lifeRemaining -= deltaTime;
            this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${this.rotation})`); // Apply current rotation
            this.element.style.opacity = this.lifeRemaining / this.initialLife;
            return this.lifeRemaining <= 0; // True if dead
        }

        remove() {
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
        }
    }

    /**
     * Creates explosion or spark particles for visual effect.
     * @param {number} x - X coordinate of explosion/sparks.
     * @param {number} y - Y coordinate of explosion/sparks.
     * @param {number} baseSize - Base size for particles.
     * @param {string} type - Type of particles ('explosion' or 'spark').
     * @param {number} [parentVx=0] - Inherited velocity X from the parent object.
     * @param {number} [parentVy=0] - Inherited velocity Y from the parent object.
     */
    function createExplosion(x, y, baseSize, type = 'explosion', parentVx = 0, parentVy = 0) {
      const settings = qualitySettings[currentQualityLevel];
      let numParticles;
      let particleSizeMin, particleSizeMax;
      let particleSpeedMin, particleSpeedMax;
      let particleLife; // This will now be in milliseconds

      if (type === 'explosion') {
        numParticles = settings.asteroidNumParticles;
        particleSizeMin = baseSize * 0.1 * SCALE_FACTOR;
        particleSizeMax = baseSize * 0.3 * SCALE_FACTOR;
        particleSpeedMin = 3 / TARGET_FRAME_DURATION; // Increased speed
        particleSpeedMax = 8 / TARGET_FRAME_DURATION; // Increased speed
        particleLife = 30 * TARGET_FRAME_DURATION; // Reduced life to 0.5 seconds
      } else if (type === 'spark') { // Corrected to else if
        numParticles = settings.sparkNumParticles;
        particleSizeMin = baseSize * 0.05 * SCALE_FACTOR; // Increased for more noticeable sparks
        particleSizeMax = baseSize * 0.15 * SCALE_FACTOR; // Increased for more noticeable sparks
        particleSpeedMin = 1.5 / TARGET_FRAME_DURATION; // Increased speed
        particleSpeedMax = 4 / TARGET_FRAME_DURATION; // Increased speed
        particleLife = 30 * TARGET_FRAME_DURATION; // Increased life to 0.5 seconds for better visibility
      } else if (type === 'nukeFireball') { // New: Nuke explosion particles
        numParticles = 70; // Reduced number of particles for nuke explosion
        particleSizeMin = baseSize * 0.05 * SCALE_FACTOR; // Larger particles
        particleSizeMax = baseSize * 0.15 * SCALE_FACTOR; // Slightly reduced max size
        particleSpeedMin = 0.5 / TARGET_FRAME_DURATION; // Slower, lingering particles
        particleSpeedMax = 2 / TARGET_FRAME_DURATION;
        particleLife = 90 * TARGET_FRAME_DURATION; // Reduced life for fireball effect (1.5 seconds)
      }

      for (let i = 0; i < numParticles; i++) {
        let particleElement = particlePool.pop();
        if (!particleElement) {
            particleElement = createSVGElement('circle');
        }
        // Append to effectsLayer here to ensure it's on top of other elements when activated
        effectsLayer.appendChild(particleElement);
        
        const size = random(particleSizeMin, particleSizeMax);
        particleElement.setAttribute('r', size / 2);
        particleElement.setAttribute('cx', x);
        particleElement.setAttribute('cy', y);

        if (type === 'spark') {
            const hue = random(0, 60);
            const saturation = random(80, 100);
            const lightness = random(40, 70);
            particleElement.setAttribute('fill', `hsl(${hue}, ${saturation}%, ${lightness}%)`);
        } else if (type === 'nukeFireball') {
            // Orange to yellow gradient for nuke fireball
            const hue = random(30, 60); // Yellow to orange
            const saturation = random(80, 100);
            const lightness = random(50, 80);
            particleElement.setAttribute('fill', `hsl(${hue}, ${saturation}%, ${lightness}%)`);
        }
        else { // Default explosion
            particleElement.setAttribute('fill', `rgb(255, 165, 0)`);
        }
        
        const angle = random(0, Math.PI * 2);
        const speed = random(particleSpeedMin, particleSpeedMax);
        const vx = Math.cos(angle) * speed + parentVx; // Add parent's velocity
        const vy = Math.sin(angle) * speed + parentVy; // Add parent's velocity

        // Add to global activeParticles array for centralized animation
        activeParticles.push(new Particle(particleElement, x, y, vx, vy, particleLife, particleLife));
      }
    }

    // --- Initialization Functions ---

    function initStars() {
      const settings = qualitySettings[currentQualityLevel];
      const targetStarCount = settings.starCount; // Star count is not scaled, but their size is handled in Star constructor

      // Adjust existing stars or add new ones
      while (stars.length < targetStarCount) {
        // Add new stars if needed
        const newStar = new Star(random(0, width), random(0, height), random(0.5, 2));
        stars.push(newStar);
      }

      while (stars.length > targetStarCount) {
        // Remove excess stars from DOM and array
        const starToRemove = stars.pop();
        starToRemove.remove(); // Remove element from DOM
      }

      // Update color for all existing stars based on current quality settings
      stars.forEach(star => star.updateColor());

      // Initialize starfield direction
      setNewStarfieldTargetDirection(); // Sets targetVx/Vy and starfieldDirectionTransitionStartTime
      lastStarfieldDirectionChangeTime = Date.now(); // Set initial interval timer
    }

    /**
     * Sets a new random target direction for the starfield.
     */
    function setNewStarfieldTargetDirection() {
        const baseSpeed = random(0.1, 0.5) / TARGET_FRAME_DURATION; // Revert to original speed
        const angle = random(0, Math.PI * 2); // Random angle
        starfieldTargetVx = Math.cos(angle) * baseSpeed;
        starfieldTargetVy = Math.sin(angle) * baseSpeed;
        starfieldDirectionTransitionStartTime = Date.now(); // Reset start time for the *new* transition
    }

    function initDefenders() { // Renamed from initSatellites
      for (let i = 0; i < numInitialDefenders; i++) { // Renamed from numInitialSatellites
        defenders.push(new Defender(random(width * 0.1, width * 0.9), random(height * 0.1, height * 0.9)));
      }
    }

    function initAsteroids() {
      for (let i = 0; i < numInitialAsteroids; i++) {
        spawnOnscreenAsteroid(); // Initial asteroids can appear anywhere on screen
      }
    }

    /**
     * Spawns a new asteroid from off-screen and directs it towards the center.
     */
    function spawnOffscreenAsteroid() {
      const size = random(MIN_ASTEROID_SIZE, MAX_ASTEROID_SIZE);
      const speed = random(0.5, 1.0) / TARGET_FRAME_DURATION;
      
      let x, y;
      const edge = Math.floor(random(0, 4)); // 0: top, 1: right, 2: bottom, 3: left
      const offset = size * 1.5 * SCALE_FACTOR; // Spawn a bit further off-screen

      switch (edge) {
        case 0: // Top
          x = random(-offset, width + offset);
          y = -offset;
          break;
        case 1: // Right
          x = width + offset;
          y = random(-offset, height + offset);
          break;
        case 2: // Bottom
          x = random(-offset, width + offset);
          y = height + offset;
          break;
        case 3: // Left
          x = -offset;
          y = random(-offset, height + offset);
          break;
      }

      // Calculate velocity towards a random point within the screen
      const targetX = random(width * 0.2, width * 0.8);
      const targetY = random(height * 0.2, height * 0.8);
      
      let angle = Math.atan2(targetY - y, targetX - x);
      // Add some randomness to the angle to vary trajectories
      angle += random(-Math.PI / 6, Math.PI / 6); // +/- 30 degrees

      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;

      asteroids.push(new Asteroid(x, y, size, size, vx, vy));
    }

    /**
     * Spawns a new asteroid directly on-screen with random position and velocity.
     */
    function spawnOnscreenAsteroid() {
      const size = random(MIN_ASTEROID_SIZE, MAX_ASTEROID_SIZE);
      const speed = random(0.5, 1.0) / TARGET_FRAME_DURATION;
      // Random on-screen position
      const x = random(size * SCALE_FACTOR, width - size * SCALE_FACTOR);
      const y = random(size * SCALE_FACTOR, height - size * SCALE_FACTOR);
      // Random velocity in any direction
      const angle = random(0, Math.PI * 2);
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      asteroids.push(new Asteroid(x, y, size, size, vx, vy));
    }

    /**
     * Spawns a new group of UFOs (3 at a time).
     */
    function spawnUFO() {
      // Only spawn a new group if no UFOs are currently active
      if (ufos.length > 0) {
        return;
      }

      const numUFOsToSpawn = 3;
      for (let i = 0; i < numUFOsToSpawn; i++) {
        const newUFO = new UFO();
        ufos.push(newUFO);
        ufoMessageQueue.push(newUFO); // Add new UFOs to the message queue
      }
      
      processUfoMessageQueue(); // Start processing the queue
    }

    // --- Game Loop ---

    function update(time) {
      // Calculate delta time for consistent movement regardless of frame rate
      const deltaTime = time - lastFrameTime;
      lastFrameTime = time;

      const settings = qualitySettings[currentQualityLevel]; // Define settings here for broader scope

      // Increment frame counter for FPS calculation
      frameCount++;

      // Update FPS every second
      if (time - lastFpsUpdateTime >= 1000) {
        fps = frameCount; // Number of frames in the last second
        frameCount = 0; // Reset frame count for the next second
        lastFpsUpdateTime = time; // Reset the time for the next FPS calculation period
      }

      const now = Date.now();
      const frameStart = performance.now(); // Start measuring total frame time for this frame


      // If paused, only update FPS and stats, then request next frame and return
      if (isPaused) {
          requestAnimationFrame(update);
          return;
      }

      // Check if it's time to set a new target direction for the starfield
      if (now - lastStarfieldDirectionChangeTime >= starfieldDirectionChangeInterval) {
          setNewStarfieldTargetDirection();
          lastStarfieldDirectionChangeTime = now; // Reset the interval timer
      }

      // Smoothly interpolate current starfield velocity towards target velocity
      const transitionProgress = Math.min(1, (now - starfieldDirectionTransitionStartTime) / starfieldDirectionChangeDuration);
      // Linear interpolation: current = start + (end - start) * progress
      starfieldVx = starfieldVx + (starfieldTargetVx - starfieldVx) * transitionProgress;
      starfieldVy = starfieldVy + (starfieldTargetVy - starfieldVy) * transitionProgress;

      // Update stars
      let sectionStart = performance.now();
      stars.forEach(star => star.update(deltaTime)); // Pass deltaTime
      accumulatedPerformanceData.stars += (performance.now() - sectionStart);

      // Update date/time display position ONLY if it's visible
      if (isDateTimeVisible) {
          // Update orbit center drift direction periodically
          if (now - lastDateTimeOrbitCenterDirectionChangeTime > dateTimeOrbitCenterDirectionChangeInterval) {
              const angle = random(0, Math.PI * 2);
              dateTimeOrbitCenterVx = Math.cos(angle) * dateTimeOrbitCenterSpeedMax;
              dateTimeOrbitCenterVy = Math.sin(angle) * dateTimeOrbitCenterSpeedMax;
              lastDateTimeOrbitCenterDirectionChangeTime = now;
          }

          // Update orbit center position
          dateTimeOrbitCenterX += dateTimeOrbitCenterVx * deltaTime;
          dateTimeOrbitCenterY += dateTimeOrbitCenterVy * deltaTime;

          // Clamp orbit center within bounds, ensuring the entire orbit stays on screen
          // The orbit center must be at least dateTimeOrbitRadius from any edge.
          const minX = dateTimeOrbitRadius;
          const maxX = width - dateTimeOrbitRadius;
          const minY = dateTimeOrbitRadius;
          const maxY = height - dateTimeOrbitRadius;

          if (dateTimeOrbitCenterX < minX) {
              dateTimeOrbitCenterVx = Math.abs(dateTimeOrbitCenterVx); // Bounce right
              dateTimeOrbitCenterX = minX; // Clamp
          } else if (dateTimeOrbitCenterX > maxX) {
              dateTimeOrbitCenterVx = -Math.abs(dateTimeOrbitCenterVx); // Bounce left
              dateTimeOrbitCenterX = maxX; // Clamp
          }
          if (dateTimeOrbitCenterY < minY) {
              dateTimeOrbitCenterVy = Math.abs(dateTimeOrbitCenterVy); // Bounce down
              dateTimeOrbitCenterY = minY; // Clamp
          } else if (dateTimeOrbitCenterY > maxY) {
              dateTimeOrbitCenterVy = -Math.abs(dateTimeOrbitCenterVy); // Bounce up
              dateTimeOrbitCenterY = maxY; // Clamp
          }

          // Update orbital angle
          dateTimeOrbitAngle += dateTimeOrbitSpeed * deltaTime;
          if (dateTimeOrbitAngle > Math.PI * 2) dateTimeOrbitAngle -= Math.PI * 2; // Keep angle within 0 to 2PI

          // Calculate final position based on orbit center and orbital offset
          const orbitalX = dateTimeOrbitCenterX + dateTimeOrbitRadius * Math.cos(dateTimeOrbitAngle);
          const orbitalY = dateTimeOrbitCenterY + dateTimeOrbitRadius * Math.sin(dateTimeOrbitAngle);

          // Apply transform. The CSS already has translate(-50%, -50%) to center the div itself.
          // So, orbitalX and orbitalY are the desired center coordinates.
          dateTimeDisplay.style.transform = `translate(${orbitalX}px, ${orbitalY}px) translate(-50%, -50%)`;
      }

      // Update defenders
      sectionStart = performance.now();
      defenders.forEach(defender => defender.update(deltaTime)); // Pass deltaTime, renamed from satellites
      accumulatedPerformanceData.defenders += (performance.now() - sectionStart);

      // Update asteroids and check for removal
      sectionStart = performance.now();
      for (let i = asteroids.length - 1; i >= 0; i--) {
        const asteroid = asteroids[i];
        // If asteroid.update() returns true, it means it went off-screen horizontally and needs removal.
        // Asteroids are also removed from the array by their destroy() method (when health <= 0).
        // So, we remove here if update() signals removal.
        if (asteroid.update(deltaTime)) {
            // Remove its SVG element from DOM
            if (asteroid.element.parentNode) {
                gameplayLayer.removeChild(asteroid.element); // Remove from gameplay layer
            }
            // Remove all active crack effects' elements
            asteroid.activeCrackEffects.forEach(effect => {
                if (effect.element.parentNode) {
                    effect.element.parentNode.removeChild(effect.element);
                }
            });
            asteroid.activeCrackEffects = []; // Clear the array

            asteroids.splice(i, 1); // Remove from array
        }
      }
      accumulatedPerformanceData.asteroids += (performance.now() - sectionStart);

      // Maintain the number of asteroids (spawn off-screen if needed)
      while (asteroids.length < numInitialAsteroids) {
          spawnOffscreenAsteroid();
      }

      // Update UFOs
      sectionStart = performance.now();
      for (let i = ufos.length - 1; i >= 0; i--) {
        ufos[i].update(deltaTime); // Pass deltaTime
      }
      accumulatedPerformanceData.ufo += (performance.now() - sectionStart);

      // Update lasers and check for removal
      sectionStart = performance.now();
      for (let i = lasers.length - 1; i >= 0; i--) {
        const laser = lasers[i];
        
        // Update the laser's position and life.
        // This will also handle damage and setting life=0 if it's a user laser and hits its target.
        if (laser.update(deltaTime)) { // If update returns true, laser's life is up
          laser.remove(); // Return to pool
          lasers.splice(i, 1);
        }
      }
      accumulatedPerformanceData.lasers += (performance.now() - sectionStart);

      // Update nukes and check for removal
      sectionStart = performance.now();
      for (let i = nukes.length - 1; i >= 0; i--) {
          const nuke = nukes[i];
          if (nuke.update(deltaTime)) { // If update returns true, nuke's life is up
              nuke.remove(); // Return to pool
              nukes.splice(i, 1);
          }
      }
      accumulatedPerformanceData.nukes += (performance.now() - sectionStart);

      // Update fireballs and check for removal
      sectionStart = performance.now();
      for (let i = activeFireballs.length - 1; i >= 0; i--) {
          const fireball = activeFireballs[i];
          if (fireball.update()) { // If fireball is dead
              fireball.remove();
              activeFireballs.splice(i, 1);
          }
      }
      accumulatedPerformanceData.fireballs += (performance.now() - sectionStart);

      // Update particles (centralized animation)
      sectionStart = performance.now();
      for (let i = activeParticles.length - 1; i >= 0; i--) {
          const particle = activeParticles[i];
          if (particle.update(deltaTime)) { // If particle is dead
              particle.remove();
              activeParticles.splice(i, 1);
          }
      }
      accumulatedPerformanceData.particles += (performance.now() - sectionStart);

      // New: Aggregate particles
      sectionStart = performance.now();
      aggregateParticles();
      accumulatedPerformanceData.particles += (performance.now() - sectionStart); // Add aggregation time to particles category

      // Update exploding UFO parts (centralized animation)
      sectionStart = performance.now();
      for (let i = explodingUfoParts.length - 1; i >= 0; i--) {
          const part = explodingUfoParts[i];
          if (part.update(deltaTime)) { // If part is dead
              part.remove();
              explodingUfoParts.splice(i, 1);
          }
      }
      accumulatedPerformanceData.explodingUfoParts += (performance.now() - sectionStart);

      // Spawn new asteroids (off-screen)
      if (Date.now() - lastAsteroidSpawnTime > asteroidSpawnInterval) {
        spawnOffscreenAsteroid();
        lastAsteroidSpawnTime = Date.now();
      }

      // Spawn UFO
      if (Date.now() - lastUfoSpawnTime > ufoSpawnInterval) {
        spawnUFO();
        lastUfoSpawnTime = Date.now();
      }

      // Process UFO message queue
    /**
     * Processes the UFO message queue, making UFOs speak in sequence.
     */
    function processUfoMessageQueue() {
        if (currentSpeakingUFO) {
            // A UFO is currently speaking, wait for it to finish
            return;
        }

        if (ufoMessageQueue.length > 0) {
            currentSpeakingUFO = ufoMessageQueue.shift(); // Get the next UFO from the queue
            if (currentSpeakingUFO && currentSpeakingUFO.displayMessage) {
                currentSpeakingUFO.displayMessage(() => {
                    // Callback when the UFO finishes speaking
                    currentSpeakingUFO = null; // Clear the current speaking UFO
                    processUfoMessageQueue(); // Process the next in queue
                });
            } else {
                // If for some reason the UFO or its displayMessage method is invalid,
                // clear it and try the next one.
                currentSpeakingUFO = null;
                processUfoMessageQueue();
            }
        }
    }

      // Nuke availability logic
      if (now >= nukeNextAvailableTime) { // Nuke is ready
          nukeAvailable = true;
          nukeButton.textContent = 'Nuke'; // Keep text simple
          nukeButton.classList.add('nuke-ready-pulse'); // Add pulsation class
          nukeButton.disabled = false;
      } else { // Nuke is on cooldown
          nukeAvailable = false; // Ensure this is false
          const remainingTimeMs = nukeNextAvailableTime - now;
          const remainingSeconds = Math.max(0, Math.ceil(remainingTimeMs / 1000)); 
          nukeButton.textContent = `Nuke: Cooldown (${remainingSeconds}s)`; // Show timer with label
          nukeButton.classList.remove('nuke-ready-pulse'); // Remove pulsation class
          nukeButton.disabled = true;
      }

      // Optional: Gain nuke over time (if you want more than one)
      // if (nukeAvailable === false && now - lastNukeGainTime >= nukeGainInterval) {
      //     nukeAvailable = true;
      //     lastNukeGainTime = now;
      //     nukeButton.textContent = 'Nuke: Ready';
      //     nukeButton.classList.remove('bg-gray-900/50', 'text-gray-300', 'hover:bg-gray-800/70');
      //     nukeButton.classList.add('bg-red-800/50', 'text-red-200', 'hover:bg-red-700/70');
      //     nukeButton.disabled = false;
      // }

      // Accumulate overall update time for this frame
      accumulatedPerformanceData.overallUpdateTime += (performance.now() - frameStart);
      frameCounterForPerf++;

      // Update and display performance stats periodically
      if (isPerfStatsVisible && now - lastPerfStatsUpdateTime >= PERF_UPDATE_INTERVAL) {
          let perfHtml = '<h3>Perf (ms/frame avg over 5s)</h3>';
          if (frameCounterForPerf > 0) { // Avoid division by zero
              const avgOverallUpdateTime = accumulatedPerformanceData.overallUpdateTime / frameCounterForPerf;

              // Create a temporary object for displaying averages
              const currentAverages = {};
              let totalMeasuredLogicTime = 0; // Sum of all measured categories for the interval
              for (const key in accumulatedPerformanceData) {
                  if (key !== 'overallUpdateTime') { // Exclude overallUpdateTime from category sum
                      const avg = accumulatedPerformanceData[key] / frameCounterForPerf;
                      currentAverages[key] = avg;
                      totalMeasuredLogicTime += accumulatedPerformanceData[key]; // Sum raw accumulated values
                  }
              }
              const avgMeasuredLogicTime = totalMeasuredLogicTime / frameCounterForPerf;
              const avgUnmeasuredJsOverhead = avgOverallUpdateTime - avgMeasuredLogicTime;

              // Sort categories by their average time spent, descending
              const sortedCategories = Object.keys(currentAverages)
                  .sort((a, b) => currentAverages[b] - currentAverages[a]);

              let totalDomObjects = 0;
              sortedCategories.forEach(key => {
                  let count = 0;
                  // Get the count for each category
                  switch(key) {
                      case 'stars': count = stars.length; break;
                      case 'defenders': count = defenders.length; break;
                      case 'asteroids': count = asteroids.length; break;
                      case 'lasers': count = lasers.length; break;
                      case 'nukes': count = nukes.length; break;
                      case 'fireballs': count = activeFireballs.length; break;
                      case 'particles': count = activeParticles.length; break;
                      case 'explodingUfoParts': count = explodingUfoParts.length; break;
                      case 'ufo': count = ufos.length; break;
                  }
                  totalDomObjects += count;
                  perfHtml += `${key}: ${currentAverages[key].toFixed(2)} ms (${count})<br>`;
              });
              perfHtml += `FPS: ${fps}<br>`; // Add FPS
              perfHtml += `Total DOM Objects: ${totalDomObjects}<br>`; // Add total DOM objects
              perfHtml += `---<br>`;
              perfHtml += `Total JS Update Time: ${avgOverallUpdateTime.toFixed(2)} ms<br>`;
              perfHtml += `Measured Logic Time: ${avgMeasuredLogicTime.toFixed(2)} ms<br>`;
              perfHtml += `Unmeasured JS Overhead: ${avgUnmeasuredJsOverhead.toFixed(2)} ms<br>`;
          } else {
              perfHtml += `No frames recorded in last ${PERF_UPDATE_INTERVAL / 1000}s`;
          }
          perfStatsDiv.innerHTML = perfHtml;

          // Reset accumulated data for the next interval
          for (const key in accumulatedPerformanceData) {
              accumulatedPerformanceData[key] = 0;
          }
          frameCounterForPerf = 0;
          lastPerfStatsUpdateTime = now;
      }

      requestAnimationFrame(update);
    }

    // --- Event Listeners ---

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.setAttribute('viewBox', `0 0 ${width} ${height}`);
      // Reset orbit center to the new screen center on resize
      dateTimeOrbitCenterX = width / 2;
      dateTimeOrbitCenterY = height / 2;
      // Re-apply transform to ensure it's centered immediately
      dateTimeDisplay.style.transform = `translate(${dateTimeOrbitCenterX}px, ${dateTimeOrbitCenterY}px) translate(-50%, -50%)`;
    });

    canvas.addEventListener('click', async (event) => {
      // Initialize AudioContext on first user interaction to comply with browser autoplay policies
      // This call is now redundant here as a global listener handles it, but harmless.
      getAudioContext(); 

      // If paused, do not allow new lasers to be fired
      if (isPaused) return;

      const targetX = event.clientX;
      const targetY = event.clientY;

      // Define the four corner origins, now slightly off-screen
      const offset = 50 * SCALE_FACTOR; // Pixels to move off-screen
      const origins = [
        { x: -offset, y: -offset },             // Top-left
        { x: width + offset, y: -offset },         // Top-right
        { x: -offset, y: height + offset },        // Bottom-left
        { x: width + offset, y: height + offset }     // Bottom-right
      ];

      origins.forEach(origin => {
        const angle = Math.atan2(targetY - origin.y, targetX - origin.x);
        // Use laser pool
        let laser = laserPool.pop();
        if (!laser) { // If pool is empty, create a new one
            laser = new Laser();
        }
        laser.reset(origin.x, origin.y, angle, 'user', targetX, targetY);
        laser.element.style.display = ''; // Make visible
        laser.element.style.opacity = 1; // Ensure full opacity at start
        lasers.push(laser);
      });
      // Play user laser sound with spatial audio and an even wider pitch variation
      playSpatialSound(userLaserBuffer, event.clientX, 0.5, random(0.7, 1.3)); // Reduced volume to 0.5
    });

    qualityToggleBtn.addEventListener('click', cycleQuality);
    muteToggleBtn.addEventListener('click', toggleMute); // Add event listener for mute button
    pauseToggleBtn.addEventListener('click', togglePause); // Add event listener for pause button
    dateTimeToggleBtn.addEventListener('click', toggleDateTimeDisplay); // Add event listener for date/time toggle
    perfStatsToggleBtn.addEventListener('click', togglePerfStatsDisplay); // Add event listener for perf stats toggle

    nukeButton.addEventListener('click', async (event) => { // Made async to await audio context resume
        // Don't fire if paused, not available, or one is already active
        if (isPaused || !nukeAvailable || nukes.length > 0) return; 

        const ctx = getAudioContext();
        if (ctx.state === 'suspended') {
            try {
                await ctx.resume(); // Attempt to resume audio context on user gesture
            } catch (e) {
                console.error('Failed to resume AudioContext for nuke launch:', e);
                return; // If resume fails, don't proceed with sound
            }
        }

        // Nuke always fires to the center of the screen
        const targetX = width / 2;
        const targetY = height / 2;

        // Nuke always fires from the bottom center of the screen
        const startX = width / 2;
        const startY = height + 50 * SCALE_FACTOR; // Start slightly off-screen bottom

        let nuke = nukePool.pop();
        if (!nuke) {
            nuke = new Nuke();
        }
        nuke.reset(startX, startY, targetX, targetY);
        nukes.push(nuke);

        playSpatialSound(nukeLaunchBuffer, startX, 1.2); // Play nuke launch sound, louder
        
        nukeAvailable = false;
        nukeNextAvailableTime = Date.now() + nukeCooldown; // Set next available time
        nukeButton.textContent = 'Nuke'; // Keep text simple
        nukeButton.classList.remove('nuke-ready-pulse'); // Remove pulsation class
        nukeButton.disabled = true; // Disable immediately
    });

    // --- Main Setup ---
    window.onload = async function() {
      getAudioContext(); // This will create and attempt to resume the context

      // Generate sound data URIs and decode into AudioBuffers
      const decodeAudio = async (dataUri) => {
        const response = await fetch(dataUri);
        const arrayBuffer = await response.arrayBuffer();
        return await audioCtx.decodeAudioData(arrayBuffer);
      };

      try {
        laserBuffer = await decodeAudio(generateToneSweep(150, 1200, 400)); // Defender laser: Higher pitch sweep
      } catch (e) { console.error("Failed to load laserBuffer:", e); }
      try {
        userLaserBuffer = await decodeAudio(generateHarmonicToneSweep(200, 1200, 400, [1, 1.25, 1.5])); // Higher pitch for user laser (increased start/end freqs)
      } catch (e) { console.error("Failed to load userLaserBuffer:", e); }
      try {
        explosionBuffer = await decodeAudio(generateNoiseBurst(500, 1.5)); // Shorter duration for quicker explosions
      } catch (e) { console.error("Failed to load explosionBuffer:", e); }
      try {
        ufoBuffer = await decodeAudio(generateHum(1000, 50)); // Low, sustained hum
      } catch (e) { console.error("Failed to load ufoBuffer:", e); }
      try {
        // Higher pitch, shorter, more impactful descending chord for nuke launch
        // Start high (1500Hz), end lower (200Hz), duration 700ms, with a dissonant chord
        nukeLaunchBuffer = await decodeAudio(generateHarmonicToneSweep(700, 1500, 200, [1, 1.122, 1.335, 1.5])); // Root, minor second, perfect fourth, perfect fifth (more dissonant)
      } catch (e) { console.error("Failed to load nukeLaunchBuffer:", e); }
      try {
        nukeExplosionBuffer = await decodeAudio(generateNoiseBurst(700, 1.2)); // Shorter duration for quicker nuke explosions
      } catch (e) { console.error("Failed to load nukeExplosionBuffer:", e); }
      try {
        sparkSoundBuffer = await decodeAudio(generateSparkSound(100)); // Load the new spark sound (100ms duration)
      } catch (e) { console.error("Failed to load sparkSoundBuffer:", e); }
      try {
        aggregationSoundBuffer = await decodeAudio(generateSparkSound(50)); // A very short spark/fizz for aggregation
      } catch (e) { console.error("Failed to load aggregationSoundBuffer:", e); }

      // Get references to the pre-defined SVG layers
      starsLayer = document.getElementById('starsLayer');
      gameplayLayer = document.getElementById('gameplayLayer');
      effectsLayer = document.getElementById('effectsLayer');

      // Pre-populate object pools
      for (let i = 0; i < MAX_LASERS; i++) {
          // Create a new Laser instance. Its constructor now handles creating the SVG elements
          // and setting them to hidden and off-screen.
          laserPool.push(new Laser()); 
      }
      for (let i = 0; i < MAX_NUKES; i++) { // Populate nuke pool
          nukePool.push(new Nuke());
      }
      for (let i = 0; i < MAX_FIREBALLS; i++) { // Populate fireball pool
          fireballPool.push(new FireballEffect());
      }
      for (let i = 0; i < MAX_PARTICLES; i++) {
          const particleElement = createSVGElement('circle');
          particleElement.style.display = 'none'; // Initially hidden
          particleElement.setAttribute('cx', -9999); // Move off-screen
          particleElement.setAttribute('cy', -9999); // Move off-screen
          // Do NOT append to effectsLayer here; append in createExplosion when activated
          particlePool.push(particleElement); // Store the element directly for particles
      }

      applyQualitySettings(); // Apply initial quality settings
      initDefenders(); // Renamed from initSatellites
      initAsteroids();

      // Initialize the full-screen nuke flash element (placed last to ensure it's on top)
      nukeFlashElement = createSVGElement('rect');
      nukeFlashElement.style.display = 'none'; // Initially hidden
      nukeFlashElement.style.pointerEvents = 'none'; // Allow clicks to pass through
      nukeFlashElement.setAttribute('x', 0);
      nukeFlashElement.setAttribute('y', 0);
      nukeFlashElement.setAttribute('width', width);
      nukeFlashElement.setAttribute('height', height);
      nukeFlashElement.setAttribute('fill', 'white');
      nukeFlashElement.style.opacity = 0; // Start transparent
      effectsLayer.appendChild(nukeFlashElement); // Append to effects layer

      // Initialize date/time display movement parameters
      dateTimeOrbitRadius = Math.min(width, height) * 0.2; // 20% of the smaller dimension
      dateTimeOrbitAngle = random(0, Math.PI * 2); // Start at a random point in orbit
      dateTimeOrbitCenterX = width / 2; // Start orbit center at screen center
      dateTimeOrbitCenterY = height / 2;
      lastDateTimeOrbitCenterDirectionChangeTime = Date.now();
      // Set initial random drift for the orbit center
      const initialAngle = random(0, Math.PI * 2);
      dateTimeOrbitCenterVx = Math.cos(initialAngle) * dateTimeOrbitCenterSpeedMax;
      dateTimeOrbitCenterVy = Math.sin(initialAngle) * dateTimeOrbitCenterSpeedMax;

      // Initial update for date/time display and set interval
      updateDateTimeDisplay(); // Populate content first

      // Calculate initial position for the clock
      const initialOrbitalX = dateTimeOrbitCenterX + dateTimeOrbitRadius * Math.cos(dateTimeOrbitAngle);
      const initialOrbitalY = dateTimeOrbitCenterY + dateTimeOrbitRadius * Math.sin(dateTimeOrbitAngle);
      dateTimeDisplay.style.transform = `translate(${initialOrbitalX}px, ${initialOrbitalY}px) translate(-50%, -50%)`;

      // Show the display if it's meant to be visible
      if (isDateTimeVisible) {
          dateTimeDisplay.style.display = 'block';
      }
      
      setInterval(updateDateTimeDisplay, 1000); // Update every second

      // Start the animation loop
      requestAnimationFrame(update);
    };
  </script>
</body>
</html>
