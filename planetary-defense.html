<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Planetary Defense</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" href="pd.svg" type="image/svg+xml">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
  /* Custom styles for UI elements, replacing Tailwind CSS */
  html {
    color-scheme: only light !important; /* Prevent browser auto dark mode */
  }
  body {
    margin: 0;
    overflow: hidden;
    background-color: black;
    font-family: 'Inter', sans-serif; /* Using Inter font */
    -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none;   /* Safari */
    -khtml-user-select: none;    /* Konqueror HTML */
    -moz-user-select: none;      /* Old versions of Firefox */
    -ms-user-select: none;       /* Internet Explorer/Edge */
    user-select: none;           /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
  }
  #spaceCanvas {
    display: block;
    position: absolute; /* Needed for z-index to work */
    top: 0;
    left: 0;
    width: 100%; /* Ensure SVG takes full width */
    height: 100%; /* Ensure SVG takes full height */
    background-color: black; /* Pure black space background */
    border-radius: 10px; /* Rounded corners for the canvas area */
    z-index: 1; /* Place above stars (z-index: 0) */
    touch-action: none; /* Prevent default gestures for smoother input */
  }
  /* Hint simpler rendering for star shapes */
  #starsLayer {
    shape-rendering: optimizeSpeed;
  }
  #dateTimeDisplay {
    position: absolute;
    top: 0; /* Set initial top */
    left: 0; /* Set initial left */
    display: none; /* Hide initially until positioned by JS */
    color: #00ff00; /* Bright green for techy feel */
    font-family: 'Space Mono', monospace; /* Cool techy font */
    font-size: 48px; /* Much larger font size */
    text-shadow: 0 0 10px rgba(0, 255, 0, 0.9), 0 0 20px rgba(0, 255, 0, 0.7); /* More intense glow for larger text */
    /* Removed background, padding, border-radius, and box-shadow for a transparent look */
    pointer-events: none; /* Allow clicks to pass through */
    z-index: 10; /* Place behind GUI elements */
  }
  /* Perf Stats is now inside the side menu, so its positioning changes */
  #perfStats {
    position: relative; /* Changed from absolute */
    top: auto; /* Reset top */
    left: auto; /* Reset left */
    color: #e0e0e0; /* Light grey for stats */
    font-size: 14px;
    background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
    padding: 8px 12px;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    z-index: 101; /* Ensure stats are on top */
    display: none; /* Hidden by default */
  }
  /* Laser beams are now SVG elements, so these CSS rules are less relevant for their shape,
     but might still apply for opacity transitions if the element itself is a div/g. */
  .laser-beam {
    position: absolute; /* Still needed for positioning the SVG group */
    pointer-events: none; /* Allow clicks to pass through */
    opacity: 1;
    z-index: 50; /* Lasers should be above stars/background */
  }
  /* #controls is removed, replaced by hamburger menu and controls-bottom */
  #controls-bottom {
    position: absolute; /* Ensure explicit positioning */
    bottom: 16px; /* 4 units from bottom */
    left: 16px;  /* 4 units from left */
    z-index: 9999; /* Ensure it's on top of almost everything */
    display: flex; /* Ensure flexbox layout */
    gap: 8px; /* space-x-2 equivalent */
    align-items: center; /* To vertically align buttons */
    background-color: rgba(0, 0, 0, 0.4); /* Semi-transparent dark background */
    padding: 10px;
    border-radius: 10px;
  }
  #controls-bottom button { /* Apply button styles to the new bottom controls */
    padding: 8px 10px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #e0e0e0; /* Base color for icons and text */
    background-color: rgba(50, 50, 50, 0.4);
    cursor: pointer;
    transition: background-color 0.2s, border-color 0.2s;
    display: flex; /* Use flexbox to center SVG icons */
    justify-content: center;
    align-items: center;
  }
  #controls-bottom button:hover {
    background-color: rgba(70, 70, 70, 0.6);
    border-color: rgba(255, 255, 255, 0.5);
  }
  /* Styles for SVG icons within buttons */
  #controls-bottom button svg {
    width: 24px; /* Adjust size as needed */
    height: 24px;
    fill: none; /* No fill for outlined look */
    stroke: currentColor; /* Inherit button's text color for stroke */
    stroke-width: 2; /* Adjust stroke thickness */
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  /* Hamburger Menu Icon Bar Styles */
  #hamburger-menu-icon .bar {
    width: 25px;
    height: 3px;
    background-color: #e0e0e0;
    margin: 5px 0;
    transition: 0.4s;
  }

  /* Hamburger Menu Icon Container Styles */
  .hamburger-menu-icon {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1000;
    cursor: pointer;
    padding: 8px; /* p-2 */
    border-radius: 6px; /* rounded-md */
    background-color: rgba(17, 24, 39, 0.5); /* bg-gray-900/50 */
    transition: background-color 0.2s, border-color 0.2s; /* transition-colors duration-200 */
  }
  .hamburger-menu-icon:hover {
    background-color: rgba(31, 41, 55, 0.7); /* hover:bg-gray-800/70 */
  }

  /* Side Menu Styles */
  .side-menu {
    position: fixed;
    top: 0;
    max-height: calc(100vh - 76px);
    width: 256px; /* w-64 */
    background-color: rgba(17, 24, 39, 0.9); /* bg-gray-900/90 */
    color: #d1d5db; /* text-gray-300 */
    z-index: 50;
    transform: translateX(-100%); /* -translate-x-full */
    transition: transform 0.3s ease-in-out; /* transition-transform duration-300 ease-in-out */
    padding: 16px; /* p-4 */
    display: flex; /* flex */
    flex-direction: column; /* flex-col */
    gap: 16px; /* space-y-4 */
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
  }

  .side-menu.open {
    transform: translateX(0); /* Slide in */
    left: 41px; /* Position after the hamburger icon (0px left-0 + 41px icon width) */
  }

  /* Side Menu Button Styles */
  .side-menu-button {
    padding: 8px 16px; /* px-4 py-2 */
    background-color: rgba(31, 41, 55, 0.5); /* bg-gray-800/50 */
    color: #d1d5db; /* text-gray-300 */
    border-radius: 8px; /* rounded-lg */
    box-shadow: none; /* shadow-none */
    transition: background-color 0.2s, border-color 0.2s; /* transition-colors duration-200 */
    text-align: left; /* text-left */
    border: 1px solid rgba(255, 255, 255, 0.3);
    cursor: pointer;
  }
  .side-menu-button:hover {
    background-color: rgba(55, 65, 81, 0.7); /* hover:bg-gray-700/70 */
  }

  /* Side Menu Slider Container */
  .side-menu-slider-container {
    display: flex; /* flex */
    align-items: center; /* items-center */
    gap: 8px; /* space-x-2 */
  }

  /* Side Menu Label */
  .side-menu-label {
    color: #d1d5db; /* text-gray-300 */
    font-size: 14px; /* text-sm */
  }

  /* Side Menu Slider Input */
  .side-menu-slider {
    width: 96px; /* w-24 */
    height: 8px; /* h-2 */
    background-color: #374151; /* bg-gray-700 */
    border-radius: 8px; /* rounded-lg */
    -webkit-appearance: none; /* appearance-none */
    appearance: none;
    cursor: pointer;
  }
  /* Specific styles for the slider thumb and track might be needed for full cross-browser consistency,
     but for now, the basic appearance-none should suffice. */

  /* Side Menu Value Span */
  .side-menu-value {
    color: #d1d5db; /* text-gray-300 */
    font-size: 14px; /* text-sm */
  }

  /* Perf Stats Div (inside side menu) */
  .side-menu-perf-stats {
    background-color: rgba(31, 41, 55, 0.7); /* bg-gray-800/70 */
    padding: 12px; /* p-3 */
    border-radius: 8px; /* rounded-lg */
    font-size: 14px; /* text-sm */
    overflow: auto; /* overflow-auto */
    max-height: 50%; /* max-h-1/2 */
  }

  /* Bottom Controls (remaining buttons) */
  #controls-bottom {
    position: absolute; /* Ensure explicit positioning */
    bottom: 16px; /* 4 units from bottom */
    left: 16px;  /* 4 units from left */
    z-index: 9999; /* Ensure it's on top of almost everything */
    display: flex; /* Ensure flexbox layout */
    gap: 8px; /* space-x-2 equivalent */
    align-items: center; /* To vertically align buttons */
    background-color: rgba(0, 0, 0, 0.4); /* Semi-transparent dark background */
    padding: 10px;
    border-radius: 10px;
  }
  /* New class for bottom control buttons */
  .bottom-controls-button {
    padding: 8px 16px; /* px-4 py-2 */
    border-radius: 8px; /* rounded-lg */
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #d1d5db; /* text-gray-300 */
    background-color: rgba(17, 24, 39, 0.5); /* bg-gray-900/50 */
    cursor: pointer;
    transition: background-color 0.2s, border-color 0.2s; /* transition-colors duration-200 */
    box-shadow: none; /* shadow-none */
  }
  .bottom-controls-button:hover {
    background-color: rgba(31, 41, 55, 0.7); /* hover:bg-gray-800/70 */
    border-color: rgba(255, 255, 255, 0.5);
  }

  /* Styles for the square nuke button */
  .nuke-button {
    position: absolute;
    bottom: 20px; /* Adjust as needed */
    right: 20px; /* Adjust as needed */
    width: 80px; /* Width of the square */
    height: 80px; /* Height of the square */
    border-radius: 8px; /* Slightly rounded corners for a modern look */
    background-color: rgba(255, 0, 0, 0.4); /* More transparent red background */
    color: white;
    font-size: 1em; /* Reduced font size */
    font-weight: bold;
    border: 2px solid rgba(255, 255, 255, 0.5);
    cursor: pointer;
    display: flex;
    flex-direction: column; /* Arrange items vertically */
    justify-content: center;
    align-items: center;
    text-align: center;
    line-height: 1.2; /* Adjust line height for vertical centering of text */
    box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); /* Initial subtle glow */
    transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
    z-index: 9999; /* Ensure it's on top */
  }

  .nuke-button:hover {
    background-color: rgba(255, 0, 0, 0.6); /* Slightly less transparent on hover */
    border-color: rgba(255, 255, 255, 0.8);
    box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
  }

  .nuke-button:disabled {
    background-color: rgba(50, 50, 50, 0.3); /* More transparent dark background when disabled */
    border-color: rgba(255, 255, 255, 0.3);
    color: #a0a0a0;
    cursor: not-allowed;
    box-shadow: none;
    animation: none; /* Stop pulsation when disabled */
  }

  @keyframes pulse-red {
    0% {
      box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
    }
    70% {
      box-shadow: 0 0 0 15px rgba(255, 0, 0, 0);
    }
    100% {
      box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
    }
  }

  .nuke-ready-pulse {
    animation: pulse-red 2s infinite;
  }
</style>
</head>
<body>
  <svg id="spaceCanvas" width="100%" height="100%">
    <defs>
      <linearGradient id="userLaserGradient" x1="0%" y1="50%" x2="100%" y2="50%">
        <stop offset="0%" stop-color="#00FF00" stop-opacity="0"/> <!-- Fully transparent at the tail -->
        <stop offset="50%" stop-color="#64FF64" stop-opacity="1"/> <!-- Bright center -->
        <stop offset="100%" stop-color="#00FF00" stop-opacity="1"/> <!-- Fully opaque green at the head -->
      </linearGradient>
      <linearGradient id="satelliteLaserGradient" x1="0%" y1="50%" x2="100%" y2="50%">
        <stop offset="0%" stop-color="#FF0000" stop-opacity="0.3"/> <!-- More transparent red at ends -->
        <stop offset="50%" stop-color="#FFFFFF" stop-opacity="1"/> <!-- Brightest white in center -->
        <stop offset="100%" stop-color="#FF0000" stop-opacity="0.3"/> <!-- More transparent red at ends -->
      </linearGradient>
      <!-- Generic glow filter for cracks -->
      <filter id="crackGlowFilter" x="-50%" y="-50%" width="200%" height="200%">
          <feDropShadow dx="0" dy="0" stdDeviation="15" flood-color="#FF0000" flood-opacity="0.8"/>
      </filter>
      <!-- Asteroid Gradients for varied appearance -->
      <radialGradient id="asteroidGradientGrey" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#b0b0b0"/>
        <stop offset="50%" stop-color="#707070"/>
        <stop offset="100%" stop-color="#202020"/>
      </radialGradient>
      <radialGradient id="asteroidGradientBrown" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#c0a080"/>
        <stop offset="50%" stop-color="#907050"/>
        <stop offset="100%" stop-color="#402000"/>
      </radialGradient>
      <radialGradient id="asteroidGradientRed" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#d09090"/>
        <stop offset="50%" stop-color="#a06060"/>
        <stop offset="100%" stop-color="#501010"/>
      </radialGradient>
      <!-- Nuke Projectile Gradient -->
      <radialGradient id="nukeGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#FFFF00" stop-opacity="1"/>
        <stop offset="30%" stop-color="#FFA500" stop-opacity="0.8"/>
        <stop offset="100%" stop-color="#FF0000" stop-opacity="0.1"/>
      </radialGradient>
      <!-- Nuke Fireball Gradient (More Transparent) -->
      <radialGradient id="fireballGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#FFFFC8" stop-opacity="0.6"/> <!-- Reduced opacity -->
        <stop offset="20%" stop-color="#FFC800" stop-opacity="0.5"/>  <!-- Reduced opacity -->
        <stop offset="50%" stop-color="#FF6400" stop-opacity="0.3"/>  <!-- Reduced opacity -->
        <stop offset="80%" stop-color="#C83200" stop-opacity="0.1"/>   <!-- Reduced opacity -->
        <stop offset="100%" stop-color="#640000" stop-opacity="0"/>
      </radialGradient>
      <!-- Brighter Fireball Gradient for UFO Explosions -->
      <radialGradient id="ufoExplosionFireballGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#FFFFFF" stop-opacity="1"/>    <!-- Pure white, fully opaque -->
        <stop offset="10%" stop-color="#FFFF96" stop-opacity="1"/>   <!-- Bright yellow, fully opaque -->
        <stop offset="30%" stop-color="#FFB400" stop-opacity="0.9"/>   <!-- Bright orange, high opacity -->
        <stop offset="60%" stop-color="#FF5000" stop-opacity="0.7"/>    <!-- Red-orange, medium opacity -->
        <stop offset="100%" stop-color="#640000" stop-opacity="0"/>      <!-- Transparent red -->
      </radialGradient>
      <!-- Crack Gradient (Bright Yellow center, Red edges) -->
      <radialGradient id="crackGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#FFFF00" stop-opacity="0.4"/>    <!-- Bright Yellow, more transparent -->
        <stop offset="50%" stop-color="#FFA500" stop-opacity="0.2"/> <!-- Orange, more transparent -->
        <stop offset="100%" stop-color="#FF0000" stop-opacity="0.05"/>  <!-- Red, more transparent -->
      </radialGradient>
      <!-- Defender Gradient (Purple-Blue - More Pronounced) -->
      <radialGradient id="defenderGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#E6E6FA"/> <!-- Lavender (brighter highlight) -->
        <stop offset="40%" stop-color="#9370DB"/> <!-- MediumPurple -->
        <stop offset="80%" stop-color="#6A5ACD"/> <!-- SlateBlue -->
        <stop offset="100%" stop-color="#362F6B"/> <!-- Darker SlateBlue (deeper shadow) -->
      </radialGradient>
      <!-- Main Thruster Fire Gradient (Yellow to Red) -->
      <radialGradient id="mainThrusterFireGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#FFFF00" stop-opacity="1"/>    <!-- Bright Yellow -->
        <stop offset="50%" stop-color="#FFA500" stop-opacity="0.8"/> <!-- Orange -->
        <stop offset="100%" stop-color="#FF0000" stop-opacity="0"/>    <!-- Transparent Red -->
      </radialGradient>
      <!-- Defender Thruster Pod Gradient (Blue to Black) -->
      <radialGradient id="defenderThrusterPodGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#00BFFF"/> <!-- Deep Sky Blue -->
        <stop offset="100%" stop-color="#000000"/> <!-- Black -->
      </radialGradient>
      <!-- RCS Thruster Fire Gradient (Light Blue to Transparent) -->
      <radialGradient id="rcsThrusterFireGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#ADD8E6" stop-opacity="0.8"/> <!-- Light Blue -->
        <stop offset="100%" stop-color="#ADD8E6" stop-opacity="0"/> <!-- Transparent Light Blue -->
      </radialGradient>
    </defs>
    <g id="starsLayer"></g>
    <g id="gameplayLayer"></g>
    <g id="effectsLayer"></g>
    <g id="nukeFlashLayer"></g> <!-- New layer specifically for the nuke flash -->
  </svg>
  <div id="dateTimeDisplay"></div> <!-- New div for date and time -->
  <!-- Hamburger Menu Icon -->
  <div id="hamburger-menu-icon" class="hamburger-menu-icon">
    <div class="bar"></div>
    <div class="bar"></div>
    <div class="bar"></div>
  </div>

  <!-- Side Menu -->
  <div id="side-menu" class="side-menu">
    <button id="qualityToggle" class="side-menu-button">Quality: High</button>
    <button id="qualityModeToggle" class="side-menu-button">Auto Quality: Off</button>
    <button id="ttsToggle" class="side-menu-button">TTS: Off</button>
    <div class="side-menu-slider-container">
      <label for="ttsVoiceSelect" class="side-menu-label">Voice:</label>
      <select id="ttsVoiceSelect" class="side-menu-slider" style="height:auto; padding:4px; width: 140px;"></select>
    </div>
    <div class="side-menu-slider-container">
      <span class="side-menu-label">TTS Voices:</span>
      <span id="ttsVoicesStatus" class="side-menu-value">0</span>
    </div>
    <button id="perfStatsToggleBtn" class="side-menu-button">Perf Stats: Off</button>
    <div class="side-menu-slider-container">
      <label for="speedSlider" class="side-menu-label">Speed:</label>
      <input type="range" id="speedSlider" min="0" max="100" value="100" class="side-menu-slider">
      <span id="speedValue" class="side-menu-value">100%</span>
    </div>
    <div class="side-menu-slider-container">
      <span class="side-menu-label">FPS:</span>
      <span id="fpsDisplayValue" class="side-menu-value">60</span>
    </div>
    <div class="side-menu-slider-container">
      <label for="defenderCountSlider" class="side-menu-label">Defenders:</label>
      <input type="range" id="defenderCountSlider" min="0" max="15" value="6" class="side-menu-slider">
      <input type="number" id="defenderCountInput" min="0" max="999" value="6" class="side-menu-value" style="width: 50px; text-align: center; background-color: #374151; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; color: #d1d5db;">
    </div>
    <div class="side-menu-slider-container">
      <label for="autoLowFps" class="side-menu-label">Auto Low FPS:</label>
      <input type="range" id="autoLowFps" min="30" max="59" value="45" class="side-menu-slider">
      <span id="autoLowFpsValue" class="side-menu-value">45</span>
    </div>
    <div class="side-menu-slider-container">
      <label for="autoLowStreak" class="side-menu-label">Low Streak s:</label>
      <input type="range" id="autoLowStreak" min="1" max="10" value="3" class="side-menu-slider">
      <span id="autoLowStreakValue" class="side-menu-value">3s</span>
    </div>
    <div class="side-menu-slider-container">
      <label for="autoHighFps" class="side-menu-label">Auto High FPS:</label>
      <input type="range" id="autoHighFps" min="40" max="60" value="57" class="side-menu-slider">
      <span id="autoHighFpsValue" class="side-menu-value">57</span>
    </div>
    <div class="side-menu-slider-container">
      <label for="autoHighStreak" class="side-menu-label">High Streak s:</label>
      <input type="range" id="autoHighStreak" min="1" max="10" value="5" class="side-menu-slider">
      <span id="autoHighStreakValue" class="side-menu-value">5s</span>
    </div>
    <div id="perfStats" class="side-menu-perf-stats"></div>
  </div>

  <!-- Bottom Controls (remaining buttons) -->
  <div id="controls-bottom">
    <button id="muteToggle" class="bottom-controls-button">
      <svg viewBox="0 0 24 24">
        <path id="speaker-icon" d="M11 5L6 9H2v6h4l5 4z"></path>
        <path id="muted-speaker-icon" d="M5 7L15 17" style="display: none;"></path>
      </svg>
    </button>
    <button id="pauseToggle" class="bottom-controls-button">
      <svg viewBox="0 0 24 24">
        <path id="play-icon" d="M5 3l14 9-14 9z"></path>
        <path id="pause-icon" d="M6 4h4v16H6zm8 0h4v16h-4z" style="display: none;"></path>
      </svg>
    </button>
    <button id="dateTimeToggleBtn" class="bottom-controls-button">
      <svg viewBox="0 0 24 24">
        <circle id="clock-face" cx="12" cy="12" r="10"></circle>
        <path id="clock-hands" d="M12 6v6l4 2"></path>
        <line id="no-clock-slash" x1="4" y1="4" x2="20" y2="20" style="display: none;"></line>
      </svg>
    </button>
  </div>

  <button id="nukeButton" class="nuke-button" disabled>Nuke</button>

  <script>
    const canvas = document.getElementById('spaceCanvas');
    const dateTimeDisplay = document.getElementById('dateTimeDisplay'); // New: Get date/time display div
    // Moved perfStatsDiv inside side-menu, so its reference needs to be updated
    const qualityToggleBtn = document.getElementById('qualityToggle');
    const qualityModeToggleBtn = document.getElementById('qualityModeToggle');
    const dateTimeToggleBtn = document.getElementById('dateTimeToggleBtn'); // New: Get date/time toggle button
    const muteToggleBtn = document.getElementById('muteToggle'); // Get the new mute button
    const speakerIcon = document.getElementById('speaker-icon');
    const mutedSpeakerIcon = document.getElementById('muted-speaker-icon');

    const pauseToggleBtn = document.getElementById('pauseToggle'); // Get the new pause button
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');

    // New: Clock icon elements
    const clockFace = document.getElementById('clock-face');
    const clockHands = document.getElementById('clock-hands');
    const noClockSlash = document.getElementById('no-clock-slash');

    const nukeButton = document.getElementById('nukeButton'); // Get the new nuke button
    const perfStatsToggleBtn = document.getElementById('perfStatsToggleBtn'); // New: Get perf stats toggle button
    const ttsToggleBtn = document.getElementById('ttsToggle');
    const speedSlider = document.getElementById('speedSlider'); // New: Get speed slider
    const speedValueSpan = document.getElementById('speedValue'); // New: Get speed value display
    // Auto-quality controls
    const autoLowFpsSlider = document.getElementById('autoLowFps');
    const autoLowFpsValue = document.getElementById('autoLowFpsValue');
    const autoLowStreakSlider = document.getElementById('autoLowStreak');
    const autoLowStreakValue = document.getElementById('autoLowStreakValue');
    const autoHighFpsSlider = document.getElementById('autoHighFps');
    const autoHighFpsValue = document.getElementById('autoHighFpsValue');
    const autoHighStreakSlider = document.getElementById('autoHighStreak');
    const autoHighStreakValue = document.getElementById('autoHighStreakValue');
    const ttsVoiceSelect = document.getElementById('ttsVoiceSelect');
    const ttsVoicesStatus = document.getElementById('ttsVoicesStatus');
    const fpsDisplayValueSpan = document.getElementById('fpsDisplayValue'); // New: FPS display span

    const defenderCountSlider = document.getElementById('defenderCountSlider'); // Defender count slider
    // The span is now an input field
    const defenderCountInput = document.getElementById('defenderCountInput'); // Defender count text input

    // New: Hamburger menu elements
    const hamburgerMenuIcon = document.getElementById('hamburger-menu-icon');
    const sideMenu = document.getElementById('side-menu');
    const perfStatsDiv = document.getElementById('perfStats'); // Now inside side-menu

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.setAttribute('viewBox', `0 0 ${width} ${height}`);

    // Define SVG layers
    let starsScrollGroup; // New: Parent group that scrolls the tiled star layers
    let starsLayer; // Base stars group (0,0)
    let starsLayerLeft; // Tiled copy translated by (-width, 0)
    let starsLayerUp; // Tiled copy translated by (0, -height)
    let starsLayerUpLeft; // Tiled copy translated by (-width, -height)
    let gameplayLayer; // Reference to the SVG group for gameplay elements
    let effectsLayer; // Reference to the SVG group for effects
    let nukeFlashLayer; // New: Reference to the SVG group for the nuke flash

    // The 'stars' array will now hold Star objects (SVG circle based)
    const stars = []; 
    const defenders = []; // Renamed from satellites
    const asteroids = [];
    const lasers = []; // Array to manage active laser beams
    const nukes = []; // New: Array to manage active nuke projectiles
    const ufos = []; // Changed: Array to manage active UFOs
    let nukeFlashElement = null; // New: Element for the full-screen nuke flash

    const ufoMessageQueue = []; // Queue for UFOs waiting to speak
    let currentSpeakingUFO = null; // The UFO currently speaking

    // Global variables for starfield movement
    let starfieldVx = 0;
    let starfieldVy = 0;
    let starfieldTargetVx = 0;
    let starfieldTargetVy = 0;
    // New: group translation offsets for stars layer
    let starfieldOffsetX = 0;
    let starfieldOffsetY = 0;
    const starfieldDirectionChangeInterval = 15000; // Change target direction every 15 seconds
    const starfieldDirectionChangeDuration = 5000; // Transition to new direction over 5 seconds
    let lastStarfieldDirectionChangeTime = 0; // When the *interval* timer last reset
    let starfieldDirectionTransitionStartTime = 0; // When the *transition* to the new target started

    // Global variables for date/time display movement
    let dateTimeOrbitCenterX; // Center X of the clock's orbit
    let dateTimeOrbitCenterY; // Center Y of the clock's orbit
    let dateTimeOrbitRadius; // Radius of the clock's orbit
    let dateTimeOrbitAngle = 0; // Current angle in radians for orbital movement
    const dateTimeOrbitSpeed = 0.00005; // Radians per millisecond (very slow orbit)

    let dateTimeOrbitCenterVx = 0; // Velocity X for the orbit center's drift
    let dateTimeOrbitCenterVy = 0; // Velocity Y for the orbit center's drift
    const dateTimeOrbitCenterSpeedMax = 0.01; // Max drift speed in pixels per millisecond
    const dateTimeOrbitCenterDirectionChangeInterval = 30000; // Change drift direction every 30 seconds
    let lastDateTimeOrbitCenterDirectionChangeTime = 0;

    let isDateTimeVisible = true; // Default to on
    let isPerfStatsVisible = false; // New: Default to off

    // Object Pools
    const laserPool = [];
    const nukePool = []; // New: Pool for nuke projectiles
    const particlePool = [];
    const fireballPool = []; // New: Pool for fireball effects
    const MAX_LASERS = 50; // Max concurrent lasers in pool
    const MAX_NUKES = 1; // Only one nuke projectile at a time
    const MAX_PARTICLES = 1000; // Max pooled particle SVGs we pre-create
    const MAX_FIREBALLS = 5; // Max concurrent fireball effects (should be low)

    const SCALE_FACTOR = 0.75; // All object sizes will be scaled by this factor

    // Global arrays for centralized animation
    const activeParticles = []; // New: To manage all active explosion/spark particles
    const activeFireballs = []; // New: To manage active fireball effects
    const explodingUfoParts = []; // New: To manage detached UFO parts during destruction
    const MAX_ACTIVE_PARTICLES = 2000; // Hard cap for simultaneous explosion/spark particles
    const PARTICLE_OVERFLOW_HEADROOM_RATIO = 0.1; // Trim a little extra when culling particles

    // Game state variables
    let isMuted = false;
    let isPaused = false; // New pause state variable
    let gameSpeedMultiplier = 0.75; // New: Global game speed multiplier (0.0 to 1.0)
    let gameStartTime = 0; // New: Timestamp when the game officially starts (after initial load)

    // Nuke specific variables
    let nukeAvailable = false; // Is a nuke ready to fire?
    const nukeCooldown = 15000; // 15 seconds cooldown after firing
    let nukeNextAvailableTime = Date.now() + nukeCooldown; // Initialize next available time
    const nukeGainInterval = 60000; // Gain a nuke every 60 seconds
    let lastNukeGainTime = Date.now(); // Initialize with current time

    // Browser detection for iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    // FPS counter variables
    let lastFrameTime = 0; // Time of the previous frame
    let lastFpsUpdateTime = 0; // Time when FPS was last updated
    let fps = 0;
    let frameCount = 0;

    // Web Speech API (TTS) state
    let ttsEnabled = false;
    let ttsVoice = null;
    let ttsVoices = [];
    let selectedVoiceURI = null;

    function selectAlienVoice(voices) {
        if (!voices || !voices.length) return null;
        // Prioritize voices that sound synthetic/alien on common platforms
        const preferredNames = [
            'Zarvox', 'Trinoids', 'Whisper', 'Bad News', 'Pipe Organ', 'Cellos', 'Fred', 'Boing', 'Junior'
        ];
        // Try exact preferred names first
        for (const name of preferredNames) {
            const v = voices.find(vo => (vo.name || '').toLowerCase() === name.toLowerCase());
            if (v) return v;
        }
        // Then any voice whose name hints at robot/alien
        const hinted = voices.find(vo => /alien|robot|whisper|electro|vocoder|trinoid|zarvox/i.test(vo.name));
        if (hinted) return hinted;
        // Fallback: an English voice if available
        const en = voices.find(vo => /en[-_]/i.test(vo.lang));
        if (en) return en;
        // Final fallback: first voice
        return voices[0];
    }

    function populateTtsVoiceList() {
        if (!('speechSynthesis' in window)) {
            const status = document.getElementById('ttsVoicesStatus');
            if (status) status.textContent = '0';
            const sel = document.getElementById('ttsVoiceSelect');
            if (sel) sel.disabled = true;
            return;
        }
        ttsVoices = window.speechSynthesis.getVoices() || [];
        const status = document.getElementById('ttsVoicesStatus');
        if (status) status.textContent = String(ttsVoices.length);
        const sel = document.getElementById('ttsVoiceSelect');
        if (!sel) return;

        // Rebuild options
        sel.innerHTML = '';
        ttsVoices.forEach(v => {
            const opt = document.createElement('option');
            opt.value = v.voiceURI || v.name || Math.random().toString(36).slice(2);
            opt.textContent = `${v.name || 'Voice'} (${v.lang || 'unknown'})`;
            sel.appendChild(opt);
        });
        sel.disabled = ttsVoices.length === 0;

        // Choose current voice
        let chosen = null;
        if (selectedVoiceURI) {
            chosen = ttsVoices.find(v => v.voiceURI === selectedVoiceURI);
        }
        if (!chosen) {
            chosen = selectAlienVoice(ttsVoices);
            selectedVoiceURI = chosen ? chosen.voiceURI : null;
        }
        ttsVoice = chosen || null;

        // Reflect selection in UI
        if (ttsVoice) sel.value = ttsVoice.voiceURI;
    }

    function speakUfoTextWithTTS(text) {
        if (!('speechSynthesis' in window)) return false;
        try {
            if (!ttsVoice) refreshTtsVoice();
            const utter = new SpeechSynthesisUtterance(text);
            if (ttsVoice) utter.voice = ttsVoice;
            utter.lang = (ttsVoice && ttsVoice.lang) ? ttsVoice.lang : 'en-US';
            // Make it sound eerie: slower rate, lower pitch, moderate volume
            utter.rate = Math.max(0.6, Math.min(1.0, 0.8 * gameSpeedMultiplier + 0.2));
            utter.pitch = 0.6; // lower for ominous tone
            utter.volume = 1.0;
            window.speechSynthesis.speak(utter);
            return true;
        } catch (e) {
            console.warn('TTS speak failed:', e);
            return false;
        }
    }

    // Performance monitoring variables
    const accumulatedPerformanceData = {
        overallUpdateTime: 0, // Total time spent in the JS update function
        stars: 0,
        defenders: 0,
        asteroids: 0,
        lasers: 0,
        nukes: 0,
        fireballs: 0,
        particles: 0,
        explodingUfoParts: 0,
        ufo: 0
    };
    let frameCounterForPerf = 0;
    let lastPerfStatsUpdateTime = 0; // When the perf stats were last *displayed*
    const PERF_UPDATE_INTERVAL = 5000; // Update every 5 seconds

    // Define target frame rate and duration for consistent movement
    const TARGET_FPS = 60;
    const TARGET_FRAME_DURATION = 1000 / TARGET_FPS; // Milliseconds per frame at target FPS
    const DEFENDER_LASER_SPEED_PX_PER_MS = 4.0; // Fixed speed for defender lasers (pixels per millisecond)
    const USER_LASER_SPEED_PX_PER_MS = 15.0; // Increased speed for user lasers (pixels per millisecond)
    const USER_LASER_INITIAL_PULSE_LENGTH = 450; // Initial length of the user laser pulse (large up close) - Further increased for longer tail
    const USER_LASER_POST_IMPACT_DURATION = 200; // Duration in ms the laser continues to be visible after impact
    const ASTEROID_FADE_DURATION = 1000; // ms, time for asteroid opacity to go from 1 to 0 (Doubled for 2x slower fade)
    const ASTEROID_POST_FADE_DURATION = 100; // ms, time asteroid remains in DOM after opacity is 0
    const FIREBALL_INITIAL_SIZE_FACTOR = 0.5; // Initial radius of fireball is this factor of its final radius (1/2 of final)
    const FIREBALL_EXPANSION_RATE_PX_PER_MS = 0.4; // Pixels per millisecond the fireball radius expands (Increased significantly for much faster expansion)
    const USER_LASER_OVERSHOOT_DISTANCE = 50 * SCALE_FACTOR; // How far the user laser visually extends past the click target

    let numTargetDefenders = 6; // New: Target number of defenders, replaces numInitialDefenders
    const numInitialAsteroids = 10;
    // Increased asteroid spawn interval for slower rate
    const asteroidSpawnInterval = 6000; // milliseconds (was 3000)
    const ufoSpawnInterval = 60000; // milliseconds (1 minute) - for a group of 3 UFOs
    let lastAsteroidSpawnTime = 0;
    let lastUfoSpawnTime = 0;

    const MIN_ASTEROID_SIZE = 40 * SCALE_FACTOR; // Minimum size before an asteroid vaporizes (increased)
    const MIN_ASTEROID_SIZE_FOR_SPLIT = 20 * SCALE_FACTOR; // Minimum size for an asteroid to split into smaller pieces (to split into 2)
    const MIN_ASTEROID_SIZE_FOR_SPLIT_INTO_THREE = 40 * SCALE_FACTOR; // Minimum size for an asteroid to split into 3 pieces
    const MAX_ASTEROID_SIZE = 100 * SCALE_FACTOR; // Maximum size (increased)
    const ASTEROID_MAX_IRREGULARITY = 0.15; // Max irregularity factor used in generateIrregularPolygon (reduced for rounder asteroids)
    const ASTEROID_STROKE_WIDTH = 2 * SCALE_FACTOR; // Stroke width used for asteroid body

    // Hardcoded list of UFO words for message construction
    const ufoWords = [
      "Greetings", "We", "Observe", "Pattern", "Detected", "Existence", "Is", "Query", "Purpose",
      "Signal", "Received", "Unidentified", "Life", "Analyzing", "Data", "Hello", "World",
      "Unknown", "Vessel", "Probe", "Contact", "Approach", "Warning", "Peace", "Binary",
      "Source", "Destination", "Energy", "Flux", "Anomaly", "Presence", "Listen", "Speak",
      "Future", "Past", "Present", "Void", "Cosmos", "Star", "Planet", "System", "Galaxy",
      "Dimension", "Shift", "Truth", "Seek", "Connect", "Vibrate", "Echo", "Silence", "Light",
      "Darkness", "Journey", "Home", "Away", "Code", "Structure", "Form", "Essence", "Flow",
      "Stasis", "Rhythm", "Pulse", "Mind", "Spirit", "Matter", "Wave", "Particle", "Field",
      "Singularity", "Expansion", "Contraction", "Balance", "Chaos", "Order", "Dream", "Awake",
      "Perceive", "Understand", "Evolve", "Adapt", "Transcend", "Beyond", "Within", "Always",
      "Never", "Now", "Then", "Here", "There", "All", "None", "One", "Many", "Self", "Other",
      "Annihilate", "Conquer", "Dominate", "Exterminate", "Invade", "Subjugate", "Threat", "Warning",
      "Obliterate", "Vaporize", "Assimilate", "Resistance", "Futile", "Destroy", "Ruin", "Devour",
      "Consume", "Terror", "Fear", "Despair", "Doom", "Suffering", "Pain", "Death", "Chaos",
      "Dread", "Horror", "Menace", "Perish", "Crumble", "Collapse", "Eradicate", "Devastate",
      "Invasion", "Hostile", "Eliminate", "Subdue", "Vengeance", "Enslave", "Decimate", "Ravage",
      "Scourge", "Plague", "Raze", "Rend", "Shatter", "Crush",
      "Annihilation", "Conquest", "Domination", "Extinction", "Infiltrate", "Terminate", "Suffocate",
      "Devastation", "Rupture", "Raze", "Oblivion", "Desolation", "Wipeout", "Eradication", "Genocide",
      "Cataclysm", "Apocalypse", "Armageddon", "Doomsday", "Calamity", "Disaster", "Ruinous", "Destructive",
      "Malevolent", "Sinister", "Ominous", "Grim", "Dire", "Fatal", "Lethal", "Deadly", "Poison",
      "Corrupt", "Infect", "Contaminate", "Decay", "Rot", "Wither", "Fade", "Silence", "Darkness",
      "Void", "Empty", "Nothing", "End", "Final", "Last", "Zero", "Null", "Gone", "Lost", "Forgotten"
    ];

    // Global AudioContext and AudioBuffers for sounds
    let audioCtx;
    let audioContextInitialized = false; // Track if context has been created
    let audioContextResumed = false; // Track if context has been successfully resumed

    let laserBuffer;
    let userLaserBuffer;
    let explosionBuffer;
    let ufoBuffer;
    let ufoExplosionHowlBuffer; // New: UFO explosion howl sound
    let ufoWarpInSoundBuffer; // New: Reversed UFO howl for warp-in
    let nukeLaunchBuffer; // New: Nuke launch sound
    let nukeExplosionBuffer; // New: Nuke explosion sound
    let sparkSoundBuffer; // New: Sparking sound for hits
    let aggregationSoundBuffer; // New: Sound for particle aggregation

    function getAudioContext() {
        if (!audioContextInitialized) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioContextInitialized = true;
            // Do not auto-resume here; many browsers require a user gesture.
            audioContextResumed = (audioCtx.state === 'running');
        }
        return audioCtx;
    }

    // Global listener for first user interaction to resume audio context
    function resumeAudioContextOnFirstInteraction() {
        // Ensure context exists
        if (!audioContextInitialized) {
            getAudioContext();
        }
        if (!audioContextResumed && audioCtx && audioCtx.state !== 'running') {
            audioCtx.resume().then(() => {
                console.log('AudioContext resumed by user gesture.');
                audioContextResumed = true;
                // Remove this listener once resumed
                document.body.removeEventListener('click', resumeAudioContextOnFirstInteraction);
                document.body.removeEventListener('touchstart', resumeAudioContextOnFirstInteraction);
            }).catch(e => {
                console.error('Failed to resume AudioContext on user gesture:', e);
            });
        }
    }

    // Add event listeners to the body to catch the first interaction
    document.body.addEventListener('click', resumeAudioContextOnFirstInteraction);
    document.body.addEventListener('touchstart', resumeAudioContextOnFirstInteraction, { passive: true });


    /**
     * Plays a sound with spatial positioning using Web Audio API.
     * @param {AudioBuffer} buffer - The AudioBuffer containing the sound data.
     * @param {number} sourceX - The X coordinate of the sound source on screen.
     * @param {number} [volume=1] - The volume of the sound (0 to 1).
     * @param {number} [pitchBend=1] - Multiplier for playback rate (1 for normal pitch).
     */
    function playSpatialSound(buffer, sourceX, volume = 1, pitchBend = 1) {
        if (isMuted || isPaused) return; // Do not play sound if muted or paused

        const ctx = getAudioContext();
        if (!buffer) {
            console.warn('Attempted to play sound but buffer is invalid.');
            return;
        }

        if (ctx.state !== 'running') {
            // If context is not running, warn but do not return.
            // This allows the sound source to be created and connected.
            // If the context resumes shortly after (e.g., due to a pending resume() call),
            // the sound might still play.
            console.warn('AudioContext not running, sound might not play immediately.');
        }

        const source = ctx.createBufferSource();
        source.buffer = buffer;
        // Apply gameSpeedMultiplier to playback rate
        source.playbackRate.value = gameSpeedMultiplier; // Scale overall speed by game speed multiplier
        // Apply pitch bend using detune (in cents), preserving duration.
        // 1200 cents equals one octave. Math.log2(pitchBend) converts a pitch multiplier to octaves.
        source.detune.value = 1200 * Math.log2(pitchBend);

        const panner = ctx.createPanner();
        panner.panningModel = 'HRTF'; // High-quality spatialization
        panner.distanceModel = 'linear';
        panner.refDistance = 1;
        panner.maxDistance = 10000;
        panner.rolloffFactor = 1;

        // Ensure width is not zero to prevent division by zero or NaN
        const currentWidth = width > 0 ? width : 1; // Use 1 if width is 0 to prevent division by zero

        // Map screen X (0 to width) to panner X (-1 to 1)
        // Listener is at (0, 0, 0). Source X is relative to listener.
        // Screen left (0) -> panner X -1
        // Screen right (width) -> panner X 1
        // Screen center (width/2) -> panner X 0
        const pannerX = (sourceX / currentWidth) * 2 - 1;
        panner.positionX.setValueAtTime(pannerX, ctx.currentTime);
        panner.positionY.setValueAtTime(0, ctx.currentTime); // Keep Y at 0 for side-to-side panning
        panner.positionZ.setValueAtTime(-0.5, ctx.currentTime); // Slightly behind the listener for a subtle 3D effect

        const gainNode = ctx.createGain();
        gainNode.gain.setValueAtTime(volume, ctx.currentTime);

        source.connect(panner);
        panner.connect(gainNode);
        gainNode.connect(ctx.destination);

        source.start(0); // Play immediately
        source.onended = () => {
            source.disconnect();
            panner.disconnect();
            gainNode.disconnect();
        };
    }

    /**
     * Plays the specific nuke explosion sound effect using Web Audio API nodes.
     * @param {number} sourceX - The X coordinate of the sound source on screen for panning.
     * @param {number} sourceY - The Y coordinate of the sound source on screen (not used for panning, but for consistency).
     */
    function playNukeExplosionEffect(sourceX, sourceY) {
        if (isMuted || isPaused) return;

        const ctx = getAudioContext();
        if (ctx.state !== 'running') {
            console.warn('AudioContext not running, nuke explosion sound might not play immediately.');
            return;
        }

        const now = ctx.currentTime;
        const duration = 3 / gameSpeedMultiplier; // 3 seconds base duration, scaled by game speed

        const gainNode = ctx.createGain();
        gainNode.gain.setValueAtTime(1, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);

        const filterNuke = ctx.createBiquadFilter();
        filterNuke.type = "lowpass";
        filterNuke.frequency.value = 800;

        const osc = ctx.createOscillator();
        osc.type = "sawtooth";
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(20, now + duration);

        // Spatialization (panning)
        const panner = ctx.createPanner();
        panner.panningModel = 'HRTF';
        panner.distanceModel = 'linear';
        panner.refDistance = 1;
        panner.maxDistance = 10000;
        panner.rolloffFactor = 1;
        const currentWidth = width > 0 ? width : 1;
        const pannerX = (sourceX / currentWidth) * 2 - 1;
        panner.positionX.setValueAtTime(pannerX, now);
        panner.positionY.setValueAtTime(0, now);
        panner.positionZ.setValueAtTime(-0.5, now); // Slightly behind listener for subtle 3D

        osc.connect(filterNuke);
        filterNuke.connect(panner);
        panner.connect(gainNode);
        gainNode.connect(ctx.destination);

        osc.start(now);
        osc.stop(now + duration);

        osc.onended = () => {
            osc.disconnect();
            filterNuke.disconnect();
            panner.disconnect();
            gainNode.disconnect();
        };
    }

    // --- Quality Control Settings ---
    const qualityLevels = ['high', 'medium', 'low'];
    let currentQualityIndex = 0; // Index for manual cycling
    let currentQualityLevel = qualityLevels[currentQualityIndex]; // Currently applied quality
    let qualityMode = 'manual'; // 'manual' | 'auto'

    // Auto-quality configuration
    let AUTO_LOW_THRESHOLD_FPS = 45; // downgrade if below for sustained seconds
    let AUTO_LOW_STREAK_SECONDS = 3;
    let AUTO_HIGH_THRESHOLD_FPS = 57; // upgrade if above for sustained seconds
    let AUTO_HIGH_STREAK_SECONDS = 5;
    const AUTO_ADJUST_MIN_INTERVAL_MS = 5000; // min dwell between adjustments
    let autoLowStreak = 0;
    let autoHighStreak = 0;
    let autoLastAdjustTime = 0;

    const qualitySettings = {
      'high': {
        starCount: 300, // Reverted to original star count
        asteroidNumParticles: 15,
        sparkNumParticles: 10, // Tuned for balanced debris
        defenderFireInterval: [1200, 4000],
        laserLifeDefender: 200 * TARGET_FRAME_DURATION, // This value is a base, scaled when used in Laser.reset
        laserTransitionDuration: '0.1s',
        laserGradient: true,
        laserShadow: true,
        ufoMessageTransparency: true,
        ufoMessageShadow: true,
        ufoMessageTransition: '3s ease-in-out',
        particleAggregationGridSize: 50,
        particleAggregationThreshold: 9999, // Effectively disable aggregation for richer particle trails
        aggregatedParticleEffectSize: 40,
        aggregatedParticleEffectDuration: 600 // Fixed game-time duration
      },
      'medium': {
        starCount: 150, // Reverted to original star count
        asteroidNumParticles: 10,
        sparkNumParticles: 7, // Moderated spark density
        defenderFireInterval: [2000, 6000],
        laserLifeDefender: 150 * TARGET_FRAME_DURATION, // This value is a base, scaled when used in Laser.reset
        laserTransitionDuration: '0.05s',
        laserGradient: true,
        laserShadow: true,
        ufoMessageTransparency: true,
        ufoMessageShadow: true,
        ufoMessageTransition: '2s ease-in-out',
        particleAggregationGridSize: 70,
        particleAggregationThreshold: 9999, // Effectively disable aggregation for richer particle trails
        aggregatedParticleEffectSize: 30,
        aggregatedParticleEffectDuration: 500 // Fixed game-time duration
      },
      'low': {
        starCount: 50, // Reverted to original star count
        asteroidNumParticles: 6,
        sparkNumParticles: 3, // Lightest setting for low quality
        defenderFireInterval: [3200, 8000],
        laserLifeDefender: 100 * TARGET_FRAME_DURATION, // This value is a base, scaled when used in Laser.reset
        laserTransitionDuration: '0s',
        laserGradient: false,
        laserShadow: false,
        ufoMessageTransparency: false,
        ufoMessageShadow: false,
        ufoMessageTransition: '0s',
        particleAggregationGridSize: 100,
        particleAggregationThreshold: 9999, // Effectively disable aggregation for richer particle trails
        aggregatedParticleEffectSize: 20,
        aggregatedParticleEffectDuration: 400 // Fixed game-time duration
      }
    };

    /**
     * Applies the current rendering quality settings to relevant game elements.
     */
    function applyQualitySettings() {
      const settings = qualitySettings[currentQualityLevel];

      // Reinitialize stars with new count
      initStars(); // Call initStars to handle star count and opacity updates

      // Update defender fire intervals and other time-based properties
      defenders.forEach(defender => {
        // Re-calculate fireInterval based on current quality settings and game speed
        defender.fireInterval = random(settings.defenderFireInterval[0], settings.defenderFireInterval[1]) / gameSpeedMultiplier;
        // Re-calculate other time-based properties as well
        defender.thrustCooldown = 500 / gameSpeedMultiplier;
        defender.rcsCooldown = 100 / gameSpeedMultiplier;
        defender.thrustOnDuration = 1000 * SCALE_FACTOR / gameSpeedMultiplier;
        defender.thrustOffDuration = 1000 * SCALE_FACTOR / gameSpeedMultiplier;
      });
      manageDefenders(); // Update defender count based on new quality settings if it affects them
      updateDefenderControls(); // Update the new input field too
    }

    /**
     * Cycles through the rendering quality levels.
     */
    function capitalizeWord(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

    function updateQualityButtonText() {
      if (qualityMode === 'auto') {
        qualityToggleBtn.textContent = `Quality: Auto (${capitalizeWord(currentQualityLevel)})`;
      } else {
        qualityToggleBtn.textContent = `Quality: ${capitalizeWord(currentQualityLevel)}`;
      }
    }

    function updateQualityModeButtonText() {
      const onOff = qualityMode === 'auto' ? 'On' : 'Off';
      qualityModeToggleBtn.textContent = `Auto Quality: ${onOff}`;
    }

    /**
     * Updates the defender count slider and input fields to reflect numTargetDefenders.
     */
    function updateDefenderControls() {
        if (defenderCountSlider) {
            // Slider value should be clamped by its min/max, input can go beyond
            defenderCountSlider.value = Math.min(defenderCountSlider.max, Math.max(defenderCountSlider.min, numTargetDefenders));
        }
        // Update the numeric input field
        if (defenderCountInput) {
            defenderCountInput.value = String(numTargetDefenders);
        }
    }

    function toggleQualityMode() {
      if (qualityMode === 'auto') {
        // Switching from auto to manual
        qualityMode = 'manual';
        autoLastAdjustTime = Date.now(); // avoid immediate toggles
        currentQualityIndex = 0; // Reset to high when returning to manual
        setQualityLevel(qualityLevels[currentQualityIndex]); // Apply and update text
        updateQualityModeButtonText(); // Ensure the mode button text is updated
      } else {
        // Switching from manual to auto
        qualityMode = 'auto';
        autoLastAdjustTime = Date.now(); // avoid immediate toggles
        updateQualityButtonText();
        updateQualityModeButtonText();
      }
    }

    function setQualityLevel(newLevel) {
      if (newLevel === currentQualityLevel) { updateQualityButtonText(); return; }
      currentQualityLevel = newLevel;
      applyQualitySettings();
      updateQualityButtonText();
    }

    function cycleQuality() {
      if (qualityMode === 'manual') {
        // Cycle through high, medium, low, wrapping back to high
        currentQualityIndex = (currentQualityIndex + 1) % qualityLevels.length;
        setQualityLevel(qualityLevels[currentQualityIndex]);
      } else { // qualityMode === 'auto'
        // If clicking 'Quality' button while in auto mode, switch to manual and set to high
        qualityMode = 'manual';
        currentQualityIndex = 0; // Go back to 'high'
        setQualityLevel(qualityLevels[currentQualityIndex]); // Apply 'high' and update text
        updateQualityModeButtonText(); // Turn off the Auto Quality button text
      }
    }

    /**
     * Toggles the mute state of the audio context.
     */
    function toggleMute() {
        const ctx = getAudioContext();
        if (ctx.state === 'running') {
            ctx.suspend().then(() => {
                console.log('AudioContext suspended.');
                isMuted = true;
                speakerIcon.style.display = ''; // Keep speaker visible
                mutedSpeakerIcon.style.display = ''; // Show slash
                if ('speechSynthesis' in window) { window.speechSynthesis.cancel(); }
            }).catch(e => {
                console.error('Failed to suspend AudioContext:', e);
            });
        } else if (ctx.state === 'suspended') {
            ctx.resume().then(() => {
                console.log('AudioContext resumed.');
                isMuted = false;
                speakerIcon.style.display = ''; // Keep speaker visible
                mutedSpeakerIcon.style.display = 'none'; // Hide slash
            }).catch(e => {
                console.error('Failed to resume AudioContext:', e);
            });
        }
    }

    /**
     * Toggles the pause state of the game.
     */
    function togglePause() {
        isPaused = !isPaused;
        if (isPaused) {
            playIcon.style.display = 'none';
            pauseIcon.style.display = '';
        } else {
            playIcon.style.display = '';
            pauseIcon.style.display = 'none';
        }
        const ctx = getAudioContext();
        if (isPaused) {
            if (ctx.state === 'running') {
                ctx.suspend();
            }
            if ('speechSynthesis' in window) { window.speechSynthesis.cancel(); }
        } else {
            if (ctx.state === 'suspended' && !isMuted) { // Only resume if not globally muted
                ctx.resume();
            }
        }
    }

    /**
     * Updates the date and time display.
     */
    function updateDateTimeDisplay() {
        if (!dateTimeDisplay) return; // Ensure element exists

        const now = new Date();
        const dateOptions = { year: 'numeric', month: 'short', day: 'numeric' };
        const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true }; // Changed to AM/PM format

        const dateStr = now.toLocaleDateString(undefined, dateOptions);
        const timeStr = now.toLocaleTimeString(undefined, timeOptions);

        dateTimeDisplay.innerHTML = `${dateStr}<br>${timeStr}`;
    }


    /**
     * Toggles the visibility of the performance stats display.
     */
    /**
     * Toggles the visibility of the date/time display.
     */
    function toggleDateTimeDisplay() {
        isDateTimeVisible = !isDateTimeVisible;
        if (isDateTimeVisible) {
            clockFace.style.display = '';
            clockHands.style.display = '';
            noClockSlash.style.display = 'none';
        } else {
            clockFace.style.display = ''; // Keep face visible
            clockHands.style.display = 'none'; // Hide hands
            noClockSlash.style.display = ''; // Show slash
        }
        dateTimeDisplay.style.display = isDateTimeVisible ? 'block' : 'none';
    }

    /**
     * Toggles the visibility of the performance stats display.
     */
    function togglePerfStatsDisplay() {
        isPerfStatsVisible = !isPerfStatsVisible;
        perfStatsToggleBtn.textContent = `Perf Stats: ${isPerfStatsVisible ? 'On' : 'Off'}`;
        perfStatsDiv.style.display = isPerfStatsVisible ? 'block' : 'none';
    }

    // --- Utility Functions ---
    /**
     * Generates a random number within a specified range.
     * @param {number} min - The minimum value (inclusive).
     * @param {number} max - The maximum value (exclusive).
     * @returns {number} A random number.
     */
    function random(min, max) {
      return Math.random() * (max - min) + min;
    }

    /**
     * Creates an SVG element with the given tag name.
     * @param {string} tag - The SVG tag name (e.g., 'circle', 'polygon').
     * @returns {SVGElement} The created SVG element.
     */
    function createSVGElement(tag) {
      return document.createElementNS("http://www.w3.org/2000/svg", tag);
    }

    /**
     * Generates a random HSL radial gradient and appends it to the SVG defs.
     * @returns {string} The ID of the newly created gradient.
     */
    function generateRandomUfoGradient() {
        const gradientId = `ufoGradient-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const gradient = createSVGElement('radialGradient');
        gradient.setAttribute('id', gradientId);
        // Center the radial gradient
        gradient.setAttribute('cx', '50%');
        gradient.setAttribute('cy', '50%');
        gradient.setAttribute('r', '50%');
        gradient.setAttribute('fx', '50%'); // Focal point at center
        gradient.setAttribute('fy', '50%'); // Focal point at center

        // Random base hue for the UFO (e.g., blue, purple, green, grey-blue)
        const baseHue = random(180, 300); // Range for blues, purples, magentas
        const saturation = random(50, 90); // High saturation
        const lightnessCenter = random(60, 90); // Lighter center
        const lightnessEdge = random(0, 15); // Even darker edge (closer to black)

        // Stop 1: Lighter color in the center
        const stop1 = createSVGElement('stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', `hsl(${baseHue}, ${saturation}%, ${lightnessCenter}%)`);
        gradient.appendChild(stop1);

        // Stop 2: Darker color at the edge
        const stop2 = createSVGElement('stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', `hsl(${baseHue}, ${saturation}%, ${lightnessEdge}%)`);
        gradient.appendChild(stop2);

        canvas.querySelector('defs').appendChild(gradient);
        return gradientId;
    }

    /**
     * Processes the UFO message queue, making UFOs speak in sequence.
     */
    function processUfoMessageQueue() {
        if (currentSpeakingUFO) {
            // A UFO is currently speaking, wait for it to finish
            return;
        }

        if (ufoMessageQueue.length > 0) {
            currentSpeakingUFO = ufoMessageQueue.shift(); // Get the next UFO from the queue
            if (currentSpeakingUFO && currentSpeakingUFO.displayMessage) {
                currentSpeakingUFO.displayMessage(() => {
                    // Callback when the UFO finishes speaking
                    currentSpeakingUFO = null; // Clear the current speaking UFO
                    processUfoMessageQueue(); // Process the next in queue
                });
            } else {
                // If for some reason the UFO or its displayMessage method is invalid,
                // clear it and try the next one.
                currentSpeakingUFO = null;
                processUfoMessageQueue();
            }
        }
    }

    /**
     * Aggregates overlapping particles into larger visual effects.
     * Uses a grid-based approach to find clusters of particles.
     */
    function aggregateParticles() {
        const settings = qualitySettings[currentQualityLevel];
        if (settings.particleAggregationThreshold <= 1) return; // Aggregation disabled or not meaningful

        const gridSize = settings.particleAggregationGridSize;
        const particleGrid = new Map(); // Map: "x_y" -> [particle1, particle2, ...]

        // Populate the grid with active particles
        for (const particle of activeParticles) {
            const gridX = Math.floor(particle.x / gridSize);
            const gridY = Math.floor(particle.y / gridSize);
            const key = `${gridX}_${gridY}`;

            if (!particleGrid.has(key)) {
                particleGrid.set(key, []);
            }
            particleGrid.get(key).push(particle);
        }

        const particlesToRemove = new Set();
        const newFireballsToSpawn = [];

        // Process cells for aggregation
        for (const [key, particlesInCell] of particleGrid.entries()) {
            if (particlesInCell.length >= settings.particleAggregationThreshold) {
                let sumX = 0;
                let sumY = 0;
                
                // Calculate average position and mark particles for removal
                particlesInCell.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                    particlesToRemove.add(p);
                });
                const avgX = sumX / particlesInCell.length;
                const avgY = sumY / particlesInCell.length;

                newFireballsToSpawn.push({ x: avgX, y: avgY });
            }
        }

        // Perform removals from activeParticles array and return to pool
        for (let i = activeParticles.length - 1; i >= 0; i--) {
            const particle = activeParticles[i];
            if (particlesToRemove.has(particle)) {
                particle.remove(); // This also returns the element to the pool
                activeParticles.splice(i, 1); // Remove from active list
            }
        }

        // Spawn new fireball effects for aggregated clusters
        newFireballsToSpawn.forEach(coords => {
            let fireball = fireballPool.pop();
            if (!fireball) {
                fireball = new FireballEffect();
            }
            const aggregatedFireballFinalSize = settings.aggregatedParticleEffectSize;
            // Pass duration as raw game-time milliseconds; scaling to real-time happens within FireballEffect.update
            fireball.reset(coords.x, coords.y, aggregatedFireballFinalSize * FIREBALL_INITIAL_SIZE_FACTOR, aggregatedFireballFinalSize, 'visual', settings.aggregatedParticleEffectDuration, 0.85, 2);
            activeFireballs.push(fireball);
            playSpatialSound(aggregationSoundBuffer, coords.x, 0.5); // Play subtle sound
        });
    }

    /**
     * Generates a base64 encoded WAV audio data URI for a frequency sweep.
     * @param {number} durationMs - Duration of the sound in milliseconds.
     * @param {number} startFreqHz - Starting frequency in Hz.
     * @param {number} endFreqHz - Ending frequency in Hz.
     * @returns {string} Data URI for the WAV audio.
     */
    function generateToneSweep(durationMs, startFreqHz, endFreqHz) {
      const sampleRate = 44100; // samples per second
      const numSamples = Math.floor(sampleRate * (durationMs / 1000));
      const buffer = new Float32Array(numSamples);

      for (let i = 0; i < numSamples; i++) {
        const t = i / sampleRate;
        const freq = startFreqHz + (endFreqHz - startFreqHz) * (i / numSamples);
        buffer[i] = Math.sin(2 * Math.PI * freq * t) * 0.5; // 0.5 amplitude
      }

      // Convert Float32Array to WAV format
      const wav = encodeWAV(buffer, sampleRate);
      return 'data:audio/wav;base64,' + btoa(wav);
    }


    /**
     * Generates a base64 encoded WAV audio data URI for a frequency sweep with harmonic chord components.
     * @param {number} durationMs - Duration of the sound in milliseconds.
     * @param {number} startFreqHz - Starting frequency in Hz.
     * @param {number} endFreqHz - Ending frequency in Hz.
     * @param {Array<number>} harmonics - Array of harmonic multipliers (e.g., [1, 1.25, 1.5] for a major chord).
     * @param {number} [amplitude=0.5] - Overall amplitude.
     * @returns {string} Data URI for the WAV audio.
     */
    function generateHarmonicToneSweep(durationMs, startFreqHz, endFreqHz, harmonics, amplitude = 0.5) {
        const sampleRate = 44100; // samples per second
        const numSamples = Math.floor(sampleRate * (durationMs / 1000));
        const buffer = new Float32Array(numSamples);

        for (let i = 0; i < numSamples; i++) {
            const t = i / sampleRate;
            const freq = startFreqHz + (endFreqHz - startFreqHz) * (i / numSamples);
            let sample = 0;

            harmonics.forEach(harmonic => {
                sample += Math.sin(2 * Math.PI * (freq * harmonic) * t) * (amplitude / harmonics.length);
            });
            buffer[i] = sample;
        }

        const wav = encodeWAV(buffer, sampleRate);
        return 'data:audio/wav;base64,' + btoa(wav);
    }


    /**
     * Generates a base64 encoded WAV audio data URI for a short burst of noise with decaying amplitude.
     * This simulates a white noise from medium to lower frequency, like an explosion.
     * @param {number} durationMs - Duration of the sound in milliseconds.
     * @param {number} [decayPower=2] - Power for the exponential amplitude decay (higher = faster decay).
     * @returns {string} Data URI for the WAV audio.
     */
    function generateNoiseBurst(durationMs, decayPower = 2) {
      const sampleRate = 44100;
      const numSamples = Math.floor(sampleRate * (durationMs / 1000));
      const buffer = new Float32Array(numSamples);

      for (let i = 0; i < numSamples; i++) {
        const t = i / numSamples; // Normalized time from 0 to 1
        let amplitude = 1 - t; // Linear decay from 1 to 0
        amplitude = Math.pow(amplitude, decayPower); // Exponential decay controlled by decayPower

        buffer[i] = (Math.random() * 2 - 1) * 0.5 * amplitude; // White noise, decaying amplitude
      }

      const wav = encodeWAV(buffer, sampleRate);
      return 'data:audio/wav;base64,' + btoa(wav);
    }

    /**
     * Generates a base64 encoded WAV audio data URI for a short, high-frequency sparking noise.
     * @param {number} durationMs - Duration of the sound in milliseconds.
     * @returns {string} Data URI for the WAV audio.
     */
    function generateSparkSound(durationMs) {
        const sampleRate = 44100;
        const numSamples = Math.floor(sampleRate * (durationMs / 1000));
        const buffer = new Float32Array(numSamples);

        for (let i = 0; i < numSamples; i++) {
            const t = i / numSamples; // Normalized time from 0 to 1
            let amplitude = 1 - t; // Linear decay from 1 to 0
            amplitude = Math.pow(amplitude, 2); // Reduced decay power for a slightly longer fizz

            // High-frequency noise
            buffer[i] = (Math.random() * 2 - 1) * 0.3 * amplitude; // Reduced amplitude
        }

        const wav = encodeWAV(buffer, sampleRate);
        return 'data:audio/wav;base64,' + btoa(wav);
    }

    /**
     * Generates a base64 encoded WAV audio data URI for a subtle, low hum.
     * @param {number} durationMs - Duration of the sound in milliseconds.
     * @param {number} freqHz - Frequency of the hum in Hz.
     * @returns {string} Data URI for the WAV audio.
     */
    function generateHum(durationMs, freqHz) {
      const sampleRate = 44100;
      const numSamples = Math.floor(sampleRate * (durationMs / 1000));
      const buffer = new Float32Array(numSamples);

      for (let i = 0; i < numSamples; i++) {
        const t = i / sampleRate;
        buffer[i] = Math.sin(2 * Math.PI * freqHz * t) * 0.2; // Low amplitude sine wave
      }

      const wav = encodeWAV(buffer, sampleRate);
      return 'data:audio/wav;base64,' + btoa(wav);
    }

    /**
     * Encodes a Float32Array audio buffer into a WAV format string.
     * @param {Float32Array} samples - Audio samples.
     * @param {number} sampleRate - Sample rate.
     * @returns {string} WAV formatted string.
     */
    function encodeWAV(samples, sampleRate) {
      const dataLength = samples.length * 2; // 16-bit PCM
      const buffer = new ArrayBuffer(44 + dataLength);
      const view = new DataView(buffer);

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      let offset = 0;
      /* RIFF identifier */
      writeString(view, offset, 'RIFF'); offset += 4;
      /* file length */
      view.setUint32(offset, 36 + dataLength, true); offset += 4;
      /* RIFF type */
      writeString(view, offset, 'WAVE'); offset += 4;
      /* format chunk identifier */
      writeString(view, offset, 'fmt '); offset += 4;
      /* format chunk length */
      view.setUint32(offset, 16, true); offset += 4;
      /* sample format (1 == PCM) */
      view.setUint16(offset, 1, true); offset += 2;
      /* channel count */
      view.setUint16(offset, 1, true); offset += 2;
      /* sample rate */
      view.setUint32(offset, sampleRate, true); offset += 4;
      /* byte rate (sampleRate * blockAlign) */
      view.setUint32(offset, sampleRate * 2, true); offset += 4;
      /* block align (channels * bytes per sample) */
      view.setUint16(offset, 2, true); offset += 2;
      /* bits per sample */
      view.setUint16(offset, 16, true); offset += 2;
      /* data chunk identifier */
      writeString(view, offset, 'data'); offset += 4;
      /* data chunk length */
      view.setUint32(offset, dataLength, true); offset += 4;

      // Write samples
      for (let i = 0; i < samples.length; i++) {
        let s = Math.max(-1, Math.min(1, samples[i]));
        s = s < 0 ? s * 0x8000 : s * 0x7FFF; // Convert to 16-bit PCM
        view.setInt16(offset, s, true);
        offset += 2;
      }

      return String.fromCharCode.apply(null, new Uint8Array(buffer));
    }

    /**
     * Plays a robotic-sounding voice for the given text using Web Audio API.
     * @param {string} text - The text to "speak".
     * @param {number} durationPerChar - Duration for each character's sound in ms.
     */
    function speakRoboticText(text, durationPerChar = 80) {
        if (isMuted || isPaused) return; // Do not play sound if muted or paused

        const ctx = getAudioContext();
        if (ctx.state !== 'running') { // Ensure context is running before attempting to play
            console.warn('Attempted to speak robotic text but AudioContext is not running.');
            return;
        }

        const words = text.split(/\s+/); // Split by whitespace to handle words
        let delay = 0;

        words.forEach((word) => {
            if (word.length === 0) {
                delay += durationPerChar * 2; // Longer pause for multiple spaces
                return;
            }

            // Generate a sound for each word or a segment of the word
            for (let i = 0; i < word.length; i++) {
                const char = word[i];
                if (char === '.' || char === ',' || char === '!' || char === '?') {
                    delay += durationPerChar * 1.5; // Longer pause for punctuation
                    continue;
                }

                setTimeout(() => {
                    const baseFreq = random(150, 900); // Base frequency for the chord (increased range for more variation)
                    const frequencies = [
                        baseFreq,              // Root
                        baseFreq * 1.25,       // Major Third (approx. 5/4 ratio)
                        baseFreq * 1.5         // Perfect Fifth (approx. 3/2 ratio)
                    ];

                    const gainNode = ctx.createGain();
                    gainNode.connect(ctx.destination);
                    gainNode.gain.setValueAtTime(0.6, ctx.currentTime); // Start volume (increased for loudness)
                    gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + (durationPerChar / 1000) * 0.8);

                    frequencies.forEach(freq => {
                        const oscillator = ctx.createOscillator();
                        oscillator.type = 'square'; // Square wave for robotic effect
                        oscillator.frequency.setValueAtTime(freq, ctx.currentTime);
                        oscillator.connect(gainNode);
                        oscillator.start(ctx.currentTime);
                        oscillator.stop(ctx.currentTime + (durationPerChar / 1000));
                    });
                }, delay);

                delay += durationPerChar;
            }
            delay += durationPerChar; // Small pause between words
        });
    }

    /**
     * Destroys all asteroids and the UFO within a given radius.
     * @param {number} centerX - The X coordinate of the center of the blast.
     * @param {number} centerY - The Y coordinate of the center of the blast.
     * @param {number} radius - The radius of the blast.
     */
    function destroyObjectsInRadius(centerX, centerY, radius, isNukeHit = false) {
        // Destroy UFOs if within radius
        for (let i = ufos.length - 1; i >= 0; i--) {
            const currentUfo = ufos[i];
            // Only destroy if not already in the process of being destroyed
            if (!currentUfo.isDestroyed && Math.hypot(currentUfo.x - centerX, currentUfo.y - centerY) < radius + currentUfo.size) {
                currentUfo.health = 0; // Ensure it's destroyed
                currentUfo.destroy(isNukeHit); // Pass isNukeHit to UFO destroy
            }
        }

        // Destroy asteroids within radius
        for (let i = asteroids.length - 1; i >= 0; i--) {
            const asteroid = asteroids[i];
            // Only destroy if not already in the process of being destroyed
            if (!asteroid.isDestroyed && Math.hypot(asteroid.x - centerX, asteroid.y - centerY) < radius + asteroid.size) {
                asteroid.health = 0; // Ensure it's destroyed
                asteroid.destroy(isNukeHit); // Pass isNukeHit to asteroid destroy
            }
        }
    }

    // --- Game Objects ---


    /**
     * Represents a star in the background (SVG circle based).
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} size - Radius of the star.
     * @param {SVGElement} [element=null] - Optional existing SVG element to reuse.
     */
    class Star {
      constructor(x, y, size, element = null) {
        this.x = x;
        this.y = y;
        this.size = size * SCALE_FACTOR; // This will be the radius for SVG circle
        this.element = element || createSVGElement('circle'); // Use createSVGElement
        this.element.setAttribute('class', 'star'); // Set SVG attribute
        this.element.setAttribute('r', this.size / 2); // Set radius
        this.element.style.display = ''; // Ensure visible if reused
        
        // Set initial color
        this.updateColor(); 
        
        // Initial position (will be updated by update() method)
        this.element.setAttribute('cx', this.x); // Set cx
        this.element.setAttribute('cy', this.y); // Set cy

        if (!element) { // Only append if new element
            starsLayer.appendChild(this.element); // Append to starsLayer (SVG group)
        }
      }

      update(deltaTime) {
        this.x += starfieldVx * deltaTime;
        this.y += starfieldVy * deltaTime;

        // Wrapping logic for all directions
        // Use this.size (radius) for boundary checks
        if (starfieldVx > 0 && this.x > width + this.size / 2) { // Moving right, off right edge
            this.x = -this.size / 2;
            this.y = random(0, height);
        } else if (starfieldVx < 0 && this.x < -this.size / 2) { // Moving left, off left edge
            this.x = width + this.size / 2;
            this.y = random(0, height);
        }

        if (starfieldVy > 0 && this.y > height + this.size / 2) { // Moving down, off bottom edge
            this.y = -this.size / 2;
            this.x = random(0, width); // New X when wrapping vertically
        } else if (starfieldVy < 0 && this.y < -this.size / 2) { // Moving up, off top edge
            this.y = height + this.size / 2;
            this.x = random(0, width); // New X when wrapping vertically
        }

        // Update SVG attributes for positioning
        this.element.setAttribute('cx', this.x);
        this.element.setAttribute('cy', this.y);
      }

      updateColor() {
        const hue = random(200, 240);
        const saturation = random(5, 15);
        const lightness = random(90, 100);
        this.element.setAttribute('fill', `hsl(${hue}, ${saturation}%, ${lightness}%)`); // Set SVG fill attribute
      }

      hide() {
        this.element.style.display = 'none';
      }

      show() {
        this.element.style.display = '';
      }

      remove() {
        if (this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
      }
    }

    /**
     * Represents a defender.
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     */
    class Defender { // Renamed from Satellite
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = random(20, 50) * SCALE_FACTOR; // Increased size variation for more distinct shape
        // Convert velocities to per-millisecond for delta time scaling
        this.vx = 0; // Initial velocity X (will be controlled by AI)
        this.vy = 0; // Initial velocity Y (will be controlled by AI)
        this.rotation = random(0, 360); // Initial rotation
        this.vRotation = 0; // Initial rotational velocity (will be controlled by AI)

        // New: Properties for Z-axis (scaling) oscillation for defenders
        this.scaleOscillationSpeed = random(0.0003, 0.0008); // Slower than UFOs
        this.scaleMin = 0.9; // Minimum scale factor (subtle)
        this.scaleMax = 1.1; // Maximum scale factor (subtle)
        this.scaleOffset = random(0, Math.PI * 2); // Random phase offset for desynchronized scaling
        
        const settings = qualitySettings[currentQualityLevel];
        // Scale fireInterval by gameSpeedMultiplier
        this.fireInterval = random(settings.defenderFireInterval[0], settings.defenderFireInterval[1]) / gameSpeedMultiplier;
        // Initialize lastFireTime to ensure a global 4-second delay from game start,
        // plus a random offset for individual staggering of the *first* shot.
        this.lastFireTime = gameStartTime + (4000 / gameSpeedMultiplier) + random(0, this.fireInterval);

        this.thrustForce = 0.005 / TARGET_FRAME_DURATION; // Acceleration per frame
        this.rotationForce = 0.05 / TARGET_FRAME_DURATION; // Increased rotational acceleration per frame (more aggressive)
        this.maxSpeed = 3.0 / TARGET_FRAME_DURATION; // Max linear speed
        this.maxRotationSpeed = 0.5 / TARGET_FRAME_DURATION; // Max rotational speed

        this.thrustCooldown = 500 / gameSpeedMultiplier; // Cooldown for main thruster (ms), scaled
        this.rcsCooldown = 100 / gameSpeedMultiplier; // Minimum time between RCS impulses (ms), scaled
        this.lastThrustTime = 0; // When main thrust was last *activated*
        this.lastRcsImpulseTime = 0; // When the last RCS impulse was applied

        this.isThrusting = false; // Is the main thruster currently active?
        this.thrustOnDuration = 1000 * SCALE_FACTOR / gameSpeedMultiplier; // How long main thruster stays on (ms), scaled
        this.thrustOffDuration = 1000 * SCALE_FACTOR / gameSpeedMultiplier; // How long main thruster stays off (ms) - Reduced for more frequent thrusting, scaled
        this.lastThrustToggleTime = 0; // When thrust state last changed (on to off, or off to on)

        this.roamingTargetX = random(width * 0.2, width * 0.8); // Initial roaming target
        this.roamingTargetY = random(height * 0.2, height * 0.8);
        this.roamingTargetReachedThreshold = this.size * 10 * SCALE_FACTOR; // Distance to consider target reached

        this.element = createSVGElement('g'); // Group for defender parts
        this.element.setAttribute('class', 'defender'); // Renamed class
        gameplayLayer.appendChild(this.element); // Append to gameplay layer

        this.mainThrusterLeftElement = null; // Will hold the SVG element for left main thruster fire
        this.mainThrusterRightElement = null; // Will hold the SVG element for right main thruster fire
        this.rcsLeftElement = null; // Will hold the SVG element for left RCS fire
        this.rcsRightElement = null; // Will hold the SVG element for right RCS fire

        this.drawDefender(); // Initial drawing, renamed from drawSatellite

        this.target = null; // Current target (asteroid or UFO) for firing
      }

      /**
       * Generates points for a symmetrical polygon, typically for UFO parts.
       * The shape is generated for the right half (positive X) and then mirrored to the left (negative X).
       * @param {number} numSegments - Number of segments for one half of the shape (e.g., 3 segments means 4 points).
       * @param {number} irregularity - How much points deviate from a smooth curve (0-1).
       * @param {number} baseWidth - The approximate maximum width of the shape.
       * @param {number} baseHeight - The approximate maximum height of the shape.
       * @param {number} [offsetX=0] - Horizontal offset from the UFO's center.
       * @param {number} [offsetY=0] - Vertical offset from the UFO's center.
       * @param {number} [rotationDegrees=0] - Rotation of the entire shape around its own center.
       * @returns {string} SVG points string.
       */
      generateSymmetricalShapePoints(numSegments, irregularity, baseWidth, baseHeight, offsetX = 0, offsetY = 0, rotationDegrees = 0) {
        let rightHalfPoints = [];
        // Generate random offsets for each segment point *once* to ensure perfect symmetry
        const xOffsets = Array.from({length: numSegments + 1}, () => random(-irregularity, irregularity));
        const yOffsets = Array.from({length: numSegments + 1}, () => random(-irregularity * 0.5, irregularity * 0.5)); // Less y irregularity

        // Generate points for the right half, from top to bottom
        for (let i = 0; i <= numSegments; i++) {
          const progress = i / numSegments; // Progress from 0 to 1 along the height
          
          // Use a sine wave for width variation to create a "waist" or "bulge" effect
          // This makes the shape more organic and less boxy.
          const currentWidthFactor = Math.sin(progress * Math.PI); // 0 at top/bottom, 1 in middle
          const currentWidth = (baseWidth / 2) * (0.2 + 0.8 * currentWidthFactor); // Min width 20% of max, max 100%
          
          const x = currentWidth * (1 + xOffsets[i]); // Use pre-generated offset for X
          const y = (progress - 0.5) * baseHeight * (1 + yOffsets[i]); // Use pre-generated offset for Y

          rightHalfPoints.push({ x: x, y: y });
        }

        let allPoints = [];
        // Add points for the right side (top to bottom)
        for (let i = 0; i < rightHalfPoints.length; i++) {
          allPoints.push(rightHalfPoints[i]);
        }
        // Add points for the left side (bottom to top, mirrored X)
        for (let i = rightHalfPoints.length - 1; i >= 0; i--) {
          allPoints.push({ x: -rightHalfPoints[i].x, y: rightHalfPoints[i].y });
        }

        // Apply rotation and offset to all points
        const radRotation = rotationDegrees * Math.PI / 180;
        const transformedPoints = allPoints.map(p => {
          const rotatedX = p.x * Math.cos(radRotation) - p.y * Math.sin(radRotation);
          const rotatedY = p.x * Math.sin(radRotation) + p.y * Math.cos(radRotation);
          return `${rotatedX + offsetX},${rotatedY + offsetY}`;
        });

        return transformedPoints.join(' ');
      }

      /**
       * Draws the defender's SVG elements (A-shaped with polygonal details).
       */
      drawDefender() {
        // Clear existing parts
        while (this.element.firstChild) {
          this.element.removeChild(this.element.firstChild);
        }

        // Main A-shaped body
        const bodyWidth = this.size * random(1.0, 1.2) * SCALE_FACTOR;
        const bodyHeight = this.size * random(1.5, 1.8) * SCALE_FACTOR;
        const tipY = -bodyHeight / 2;
        const baseY = bodyHeight / 2;
        const baseWidth = bodyWidth;
        const midHeight = bodyHeight * random(0.2, 0.4); // For the inner V-cut

        // Points for a more distinct 'A' shape
        const bodyPoints = [
          `0,${tipY}`, // Top point
          `${baseWidth / 2},${baseY}`, // Bottom right
          `${baseWidth / 2 * random(0.4, 0.6)},${midHeight}`, // Inner right point
          `${-baseWidth / 2 * random(0.4, 0.6)},${midHeight}`, // Inner left point
          `${-baseWidth / 2},${baseY}` // Bottom left
        ].join(' ');

        const body = createSVGElement('polygon');
        body.setAttribute('points', bodyPoints);
        body.setAttribute('fill', 'url(#defenderGradient)'); // Apply gradient fill
        body.removeAttribute('stroke'); // Remove stroke for a cleaner gradient look
        body.removeAttribute('stroke-width'); // Remove stroke-width
        this.element.appendChild(body);

        // Central polygonal "cockpit" or sensor array
        const cockpitSize = this.size * random(0.2, 0.3) * SCALE_FACTOR;
        const cockpitPoints = [
          `0,${-cockpitSize * 0.8}`,
          `${cockpitSize * 0.5},${-cockpitSize * 0.4}`,
          `${cockpitSize * 0.5},${cockpitSize * 0.4}`,
          `0,${cockpitSize * 0.8}`,
          `${-cockpitSize * 0.5},${cockpitSize * 0.4}`,
          `${-cockpitSize * 0.5},${-cockpitSize * 0.4}`
        ].join(' '); // Hexagon or diamond-like shape

        const cockpit = createSVGElement('polygon');
        cockpit.setAttribute('points', cockpitPoints);
        cockpit.setAttribute('fill', '#a9a9a9'); // Dark grey
        cockpit.removeAttribute('stroke'); // Remove stroke
        cockpit.removeAttribute('stroke-width'); // Remove stroke-width
        this.element.appendChild(cockpit);

        // Polygonal thruster exhausts (two symmetrical shapes at the back)
        const thrusterWidth = this.size * random(0.2, 0.3) * SCALE_FACTOR;
        const thrusterHeight = this.size * random(0.1, 0.15) * SCALE_FACTOR;
        const thrusterOffset = this.size * random(0.3, 0.4) * SCALE_FACTOR; // Distance from center

        // Left thruster
        const thruster1Points = [
          `${-thrusterOffset},${baseY - thrusterHeight * 0.5}`,
          `${-thrusterOffset - thrusterWidth * 0.5},${baseY + thrusterHeight * 0.5}`,
          `${-thrusterOffset + thrusterWidth * 0.5},${baseY + thrusterHeight * 0.5}`
        ].join(' '); // Simple triangle

        const thruster1 = createSVGElement('polygon');
        thruster1.setAttribute('points', thruster1Points);
        thruster1.setAttribute('fill', 'url(#defenderThrusterPodGradient)'); // Apply new gradient
        thruster1.removeAttribute('stroke'); // Remove stroke
        thruster1.removeAttribute('stroke-width'); // Remove stroke-width
        this.element.appendChild(thruster1);

        // Right thruster (mirrored)
        const thruster2Points = [
          `${thrusterOffset},${baseY - thrusterHeight * 0.5}`,
          `${thrusterOffset + thrusterWidth * 0.5},${baseY + thrusterHeight * 0.5}`,
          `${thrusterOffset - thrusterWidth * 0.5},${baseY + thrusterHeight * 0.5}`
        ].join(' '); // Simple triangle

        const thruster2 = createSVGElement('polygon');
        thruster2.setAttribute('points', thruster2Points);
        thruster2.setAttribute('fill', 'url(#defenderThrusterPodGradient)'); // Apply new gradient
        thruster2.removeAttribute('stroke'); // Remove stroke
        thruster2.removeAttribute('stroke-width'); // Remove stroke-width
        this.element.appendChild(thruster2);

        // --- Main Thruster Fire (Two Triangular, behind each thruster) ---
        const fireLength = this.size * 1.5 * SCALE_FACTOR; // Length of the fire effect
        const fireWidth = this.size * 0.8 * SCALE_FACTOR; // Width of the fire effect at its base
        const fireOffset = baseY + thrusterHeight * 0.5; // Position behind the thrusters

        // Left Main Thruster Fire
        this.mainThrusterLeftElement = createSVGElement('polygon');
        // Points relative to the left thruster's base
        this.mainThrusterLeftElement.setAttribute('points', `${-thrusterOffset},${fireOffset} ${-thrusterOffset + fireWidth / 2},${fireOffset + fireLength} ${-thrusterOffset - fireWidth / 2},${fireOffset + fireLength}`);
        this.mainThrusterLeftElement.setAttribute('fill', 'url(#mainThrusterFireGradient)');
        this.mainThrusterLeftElement.style.display = 'none'; // Hidden by default
        this.element.appendChild(this.mainThrusterLeftElement);

        // Right Main Thruster Fire
        this.mainThrusterRightElement = createSVGElement('polygon');
        // Points relative to the right thruster's base
        this.mainThrusterRightElement.setAttribute('points', `${thrusterOffset},${fireOffset} ${thrusterOffset + fireWidth / 2},${fireOffset + fireLength} ${thrusterOffset - fireWidth / 2},${fireOffset + fireLength}`);
        this.mainThrusterRightElement.setAttribute('fill', 'url(#mainThrusterFireGradient)');
        this.mainThrusterRightElement.style.display = 'none'; // Hidden by default
        this.element.appendChild(this.mainThrusterRightElement);

        // --- RCS Thruster Fire (Triangular) ---
        const rcsSize = this.size * 0.3 * SCALE_FACTOR; // Reverted to original size for RCS thruster jets
        // Position RCS thrusters closer to the top of the A-shape, on the "shoulders"
        const rcsOffsetFrontX = baseWidth / 2 * random(0.5, 0.7); // Closer to the center line
        const rcsOffsetFrontY = tipY + this.size * random(0.1, 0.3) * SCALE_FACTOR; // Slightly below the tip

        // Left RCS Thruster Fire (Triangular)
        this.rcsLeftElement = createSVGElement('polygon');
        // Points for a triangle pointing right (inwards) from its base
        const rcsLeftPoints = [
          `${-rcsOffsetFrontX},${rcsOffsetFrontY - rcsSize / 2}`,
          `${-rcsOffsetFrontX},${rcsOffsetFrontY + rcsSize / 2}`,
          `${-rcsOffsetFrontX + rcsSize},${rcsOffsetFrontY}` // Tip points inwards (right)
        ].join(' ');
        this.rcsLeftElement.setAttribute('points', rcsLeftPoints);
        this.rcsLeftElement.setAttribute('fill', 'url(#rcsThrusterFireGradient)');
        this.rcsLeftElement.style.display = 'none'; // Hidden by default
        this.element.appendChild(this.rcsLeftElement);

        // Right RCS Thruster Fire (Triangular)
        this.rcsRightElement = createSVGElement('polygon');
        // Points for a triangle pointing left (inwards) from its base
        const rcsRightPoints = [
          `${rcsOffsetFrontX},${rcsOffsetFrontY - rcsSize / 2}`,
          `${rcsOffsetFrontX},${rcsOffsetFrontY + rcsSize / 2}`,
          `${rcsOffsetFrontX - rcsSize},${rcsOffsetFrontY}` // Tip points inwards (left)
        ].join(' ');
        this.rcsRightElement.setAttribute('points', rcsRightPoints);
        this.rcsRightElement.setAttribute('fill', 'url(#rcsThrusterFireGradient)');
        this.rcsRightElement.style.display = 'none'; // Hidden by default
        this.element.appendChild(this.rcsRightElement);
      }

      update(scaledDeltaTime) {
        const now = Date.now();

        // --- Movement AI ---
        const distanceToRoamingTarget = Math.hypot(this.roamingTargetX - this.x, this.roamingTargetY - this.y);

        // If defender is close to its roaming target, pick a new one
        if (distanceToRoamingTarget < this.roamingTargetReachedThreshold) {
            this.roamingTargetX = random(width * 0.1, width * 0.9);
            this.roamingTargetY = random(height * 0.1, height * 0.9);
        }

        const desiredAngleToTarget = Math.atan2(this.roamingTargetY - this.y, this.roamingTargetX - this.x); // Radians

        // Convert current rotation (degrees) to radians for calculations.
        // The 'A' shape points upwards when rotation is 0.
        // So, the "nose" of the craft is at rotation + 270 degrees (or -90 degrees).
        const currentHeadingRad = (this.rotation + 270) * Math.PI / 180;

        // Calculate angle difference for rotation
        let angleDiff = desiredAngleToTarget - currentHeadingRad;
        // Normalize angle difference to be between -PI and PI
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        const rotationThreshold = 0.1; // Radians
        const thrustActivationThreshold = this.size * 2 * SCALE_FACTOR; // Distance to start thrusting if not already

        // --- Rotation Control (RCS Thrusters) ---
        // --- Rotation Control (RCS Thrusters) ---
        // Hide RCS visuals at the start of the frame
        this.rcsLeftElement.style.display = 'none';
        this.rcsRightElement.style.display = 'none';

        const rotationalBrakingThreshold = 0.05 / TARGET_FRAME_DURATION; // Small vRotation to consider "stopped"
        const rotationalAccelerationFactor = 1.0; // How much to accelerate rotation
        const rotationalBrakingFactor = 1.0; // How much to brake rotation

        let rcsImpulseAppliedThisFrame = false; // Flag to track if an RCS impulse was applied

        if (Math.abs(angleDiff) > rotationThreshold) {
            // Need to turn
            if (now - this.lastRcsImpulseTime > this.rcsCooldown) {
                if (angleDiff > 0) { // Turn clockwise
                    this.vRotation += this.rotationForce * rotationalAccelerationFactor;
                    this.rcsLeftElement.style.display = ''; // Fire left RCS
                } else { // Turn counter-clockwise
                    this.vRotation -= this.rotationForce * rotationalAccelerationFactor;
                    this.rcsRightElement.style.display = ''; // Fire right RCS
                }
                this.lastRcsImpulseTime = now;
                rcsImpulseAppliedThisFrame = true;
            }
        } else {
            // Aligned, now check if we need to stop spinning
            if (Math.abs(this.vRotation) > rotationalBrakingThreshold) {
                if (now - this.lastRcsImpulseTime > this.rcsCooldown) {
                    if (this.vRotation > 0) { // Spinning clockwise, need to brake counter-clockwise
                        this.vRotation -= this.rotationForce * rotationalBrakingFactor;
                        this.rcsRightElement.style.display = ''; // Fire right RCS
                    } else { // Spinning counter-clockwise, need to brake clockwise
                        this.vRotation += this.rotationForce * rotationalBrakingFactor;
                        this.rcsLeftElement.style.display = ''; // Fire left RCS
                    }
                    this.lastRcsImpulseTime = now;
                    rcsImpulseAppliedThisFrame = true;
                }
            }
        }

        // Passive dampening: if no active RCS impulse was applied this frame, slowly reduce rotation
        if (!rcsImpulseAppliedThisFrame) {
            this.vRotation *= 0.98; // Gentle decay
            // If rotation is very small, snap to zero to prevent infinite tiny rotations
            if (Math.abs(this.vRotation) < 0.001 / TARGET_FRAME_DURATION) {
                this.vRotation = 0;
            }
        }

        // Clamp rotational speed (important for stability)
        this.vRotation = Math.max(-this.maxRotationSpeed, Math.min(this.maxRotationSpeed, this.vRotation));

        // --- Thrust Control (Main Thrusters) ---
        this.mainThrusterLeftElement.style.display = 'none';
        this.mainThrusterRightElement.style.display = 'none';

        // Logic for continuous thrusting
        if (this.isThrusting) {
            if (now - this.lastThrustToggleTime < this.thrustOnDuration) {
                // Continue thrusting
                this.vx += Math.cos(currentHeadingRad) * this.thrustForce;
                this.vy += Math.sin(currentHeadingRad) * this.thrustForce;
                this.mainThrusterLeftElement.style.display = '';
                this.mainThrusterRightElement.style.display = '';
            } else {
                // Stop thrusting
                this.isThrusting = false;
                this.lastThrustToggleTime = now;
            }
        } else { // Not currently thrusting
            if (now - this.lastThrustToggleTime > this.thrustOffDuration) {
                // Decide to start thrusting if far from target and aligned
                if (distanceToRoamingTarget > thrustActivationThreshold && Math.abs(angleDiff) < rotationThreshold * 2) {
                    this.isThrusting = true;
                    this.lastThrustToggleTime = now;
                    // Apply initial thrust
                    this.vx += Math.cos(currentHeadingRad) * this.thrustForce;
                    this.vy += Math.sin(currentHeadingRad) * this.thrustForce;
                    this.mainThrusterLeftElement.style.display = '';
                    this.mainThrusterRightElement.style.display = '';
                }
            }
            // Removed: Dampen linear velocity if not thrusting (momentum is maintained)
            // this.vx *= 0.98;
            // this.vy *= 0.98;
        }

        // Clamp linear speed
        const currentSpeed = Math.hypot(this.vx, this.vy);
        if (currentSpeed > this.maxSpeed) {
            const ratio = this.maxSpeed / currentSpeed;
            this.vx *= ratio;
            this.vy *= ratio;
        }

        // Update position and rotation based on velocities
        this.x += this.vx * scaledDeltaTime; // Scaled by delta time
        this.y += this.vy * scaledDeltaTime; // Scaled by delta time
        this.rotation += this.vRotation * scaledDeltaTime; // Scaled by delta time

        // Wrap around horizontally
        if (this.x < -this.size) this.x = width + this.size;
        if (this.x > width + this.size) this.x = -this.size;

        // Wrap around vertically
        if (this.y < -this.size) this.y = height + this.size;
        if (this.y > height + this.size) this.y = -this.size;

        // Calculate Z-axis (scaling) oscillation
        // 'now' is already defined in the outer update function scope.
        const scaleProgress = (Math.sin(now * this.scaleOscillationSpeed + this.scaleOffset) + 1) / 2; // 0 to 1
        const zScale = this.scaleMin + (this.scaleMax - this.scaleMin) * scaleProgress;

        this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${this.rotation}) scale(${zScale})`);

        this.fire();
      }

      fire() {
        const now = Date.now();
        if (now - this.lastFireTime > this.fireInterval) {
          this.lastFireTime = now;

          // Prioritize UFOs if present and not destroyed
          const activeUFOs = ufos.filter(ufo => !ufo.isDestroyed);
          if (activeUFOs.length > 0) {
            // Target a random active UFO
            this.target = activeUFOs[Math.floor(random(0, activeUFOs.length))];
          } else {
            // Filter for on-screen asteroids that are well within the screen bounds and not destroyed.
            const onScreenAsteroids = asteroids.filter(a =>
                !a.isDestroyed && // Ensure asteroid is not destroyed
                a.x > a.size * 2 && a.x < width - a.size * 2 && // At least 2x asteroid size away from horizontal edges
                a.y > a.size * 2 && a.y < height - a.size * 2   // At least 2x asteroid size away from vertical edges
            );

            if (onScreenAsteroids.length > 0) {
              // Prioritize smaller and faster asteroids
              let bestTarget = null;
              let highestThreatScore = -1;

              onScreenAsteroids.forEach(asteroid => {
                const speed = Math.hypot(asteroid.vx, asteroid.vy);
                // Threat score: smaller size and higher speed contribute more
                // (MAX_ASTEROID_SIZE - asteroid.size + 1) ensures score is positive and smaller asteroids get higher scores
                const threatScore = (MAX_ASTEROID_SIZE - asteroid.size + 1) * speed;

                if (threatScore > highestThreatScore) {
                  highestThreatScore = threatScore;
                  bestTarget = asteroid;
                }
              });
              this.target = bestTarget;
            } else {
              this.target = null;
            }
          }

          if (this.target) {
            // Calculate distance to target
            const distanceToTarget = Math.hypot(this.target.x - this.x, this.target.y - this.y);
            // Estimate travel time based on fixed laser speed
            const estimatedTravelTime = distanceToTarget / DEFENDER_LASER_SPEED_PX_PER_MS;

            // Predict target's future position based on its velocity and estimated laser travel time
            const predictedTargetX = this.target.x + this.target.vx * estimatedTravelTime;
            const predictedTargetY = this.target.y + this.target.vy * estimatedTravelTime;

            const angle = Math.atan2(predictedTargetY - this.y, predictedTargetX - this.x);
            // Use laser pool
            let laser = laserPool.pop();
            if (!laser) { // If pool is empty, create a new one
                laser = new Laser();
            }
            // Pass the predicted target coordinates to the laser
            laser.reset(this.x, this.y, angle, 'defender', predictedTargetX, predictedTargetY, this.target);
            laser.element.style.display = ''; // Make visible
            laser.element.style.opacity = 1; // Ensure full opacity at start
            lasers.push(laser);
            // Play defender laser sound with spatial audio and an even wider pitch variation
            playSpatialSound(laserBuffer, this.x, 0.5, random(0.7, 1.3)); // Reduced volume to 0.5
          }
        }
      }

      remove() {
          if (this.element.parentNode) {
              gameplayLayer.removeChild(this.element);
          }
      }
    } // Closes Defender class

    /**
     * Manages the glowing and fading effect of a single crack element.
     * It animates the opacity of the glowing crack, which has a pre-defined glow filter applied.
     */
    class CrackEffect {
        constructor(glowingElement, shadedElement, durationMs) {
            // Defensive checks: Ensure elements are valid SVG elements
            if (!(glowingElement instanceof SVGElement)) {
                // Assign a dummy element or handle error appropriately if this is critical
                this.glowingElement = createSVGElement('g'); // Assign a dummy group to prevent further errors
            } else {
                this.glowingElement = glowingElement;
            }

            if (!(shadedElement instanceof SVGElement)) {
                this.shadedElement = createSVGElement('g'); // Assign a dummy group
            } else {
                this.shadedElement = shadedElement;
            }
            
            this.duration = durationMs; // Total duration for the glowing effect to fade out
            this.startTime = Date.now();
            this.isAlive = true;

            this.glowingElement.setAttribute('opacity', 1); // Starts fully opaque (gradient provides transparency)
            // shadedElement's initial opacity is set in Asteroid.addDamageCracks
            // this.shadedElement.setAttribute('opacity', 0.5); // Already set in addDamageCracks

            // Define when the shaded crack starts fading in and how long it takes
            this.shadedFadeInStartProgress = 0.7; // Start fading in when glowing crack is 70% faded
            this.shadedFadeInDurationFactor = 0.3; // Takes 30% of total duration to fade in
        }

        update() {
            const elapsed = Date.now() - this.startTime;
            let progress = elapsed / this.duration;

            if (progress >= 1) {
                this.glowingElement.setAttribute('opacity', 0); // Ensure glowing part is fully transparent
                this.shadedElement.setAttribute('opacity', 1); // Ensure shaded part is fully opaque
                this.isAlive = false; // Mark the *glowing effect* as complete
                return true; // Signal that the *effect* is complete (glowing part is gone)
            }

            // Fade out glowing crack
            const currentGlowingOpacity = 1 - progress;
            this.glowingElement.setAttribute('opacity', Math.max(0, currentGlowingOpacity));

            // Fade in shaded crack
            if (progress >= this.shadedFadeInStartProgress) {
                const fadeInProgress = (progress - this.shadedFadeInStartProgress) / this.shadedFadeInDurationFactor;
                // Fade from 0.5 to 1.0
                const currentShadedOpacity = 0.5 + (0.5 * fadeInProgress); 
                this.shadedElement.setAttribute('opacity', Math.min(1, Math.max(0.5, currentShadedOpacity)));
            }

            return false;
        }
    }

    /**
     * Represents an asteroid.
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} size - Size of the asteroid.
     * @param {number} [health] - Health of the asteroid (defaults to size).
     * @param {number} [vx=0] - Initial velocity X.
     * @param {number} [vy=0] - Initial velocity Y.
     * @param {number} [vRotation=0] - Initial rotational velocity.
     * @param {string} [inheritedGradientId=null] - Optional: Gradient ID to inherit from parent.
     */
    class Asteroid {
      constructor(x, y, size, health = size, vx = 0, vy = 0, vRotation = 0, inheritedGradientId = null, insertBeforeElement = null) {
        this.id = `asteroid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`; // Unique ID for clipping
        this.x = x;
        this.y = y;
        this.size = size;
        this.initialHealth = health; // Store initial health for crack calculation
        this.health = health;

        this.isDestroyed = false; // New flag: true when destruction animation starts
        this.destroyStartTime = 0; // New: Timestamp when destruction animation began
        this.animationDuration = 0; // New: Duration of the destruction animation

        this.vx = vx;
        this.vy = vy;

        this.rotation = random(0, 360);
        this.vRotation = vRotation === 0 ? random(-0.8, 0.8) / TARGET_FRAME_DURATION : vRotation;
        this.element = createSVGElement('g'); // Group for asteroid and craters
        this.element.setAttribute('class', 'asteroid');
        
        // Append to gameplayLayer, inserting before a specified element if provided
        if (insertBeforeElement && insertBeforeElement.parentNode === gameplayLayer) {
            gameplayLayer.insertBefore(this.element, insertBeforeElement);
        } else {
            gameplayLayer.appendChild(this.element); // Default to append if no specific element or parent mismatch
        }

        // Select asteroid gradient: inherit if provided, otherwise random
        const asteroidGradients = ['asteroidGradientGrey', 'asteroidGradientBrown', 'asteroidGradientRed'];
        this.gradientId = inheritedGradientId || asteroidGradients[Math.floor(random(0, asteroidGradients.length))];

        this.crackGroup = createSVGElement('g'); 
        // crackGroup is now appended in drawAsteroid for correct Z-order

        this.drawAsteroid(); 
        this.updatePosition(); 

        this.activeCrackEffects = []; // Will only hold the single starburst crack effect
        this.hasStarburstCrack = false; // New flag to track if starburst crack has been added
      }

      updatePosition() {
        // Transform changes here are immediate due to the default style.transition
        this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${this.rotation})`);
      }

      generateIrregularPolygon(centerX, centerY, radius, numPoints, irregularity) {
        let points = [];
        for (let i = 0; i < numPoints; i++) {
          const angle = (Math.PI * 2 / numPoints) * i;
          const r = radius * (1 + random(-irregularity, irregularity));
          const x = centerX + r * Math.cos(angle);
          const y = centerY + r * Math.sin(angle);
          points.push(`${x},${y}`);
        }
        return `M${points[0]} L${points.slice(1).join(' ')} Z`;
      }

      drawAsteroid() {
        const children = Array.from(this.element.children);
        children.forEach(child => {
            if (child !== this.crackGroup) {
                this.element.removeChild(child);
            }
        });

        const asteroidPath = createSVGElement('path');
        const asteroidPathData = this.generateIrregularPolygon(0, 0, this.size, random(10, 15), ASTEROID_MAX_IRREGULARITY);
        asteroidPath.setAttribute('d', asteroidPathData);
        asteroidPath.setAttribute('fill', `url(#${this.gradientId})`); // Use the selected gradient
        // Removed stroke and stroke-width for asteroid body
        this.element.appendChild(asteroidPath); 

        // Create and apply clipping path based on the asteroid's main shape
        const clipPathId = `asteroidClip-${this.id}`;
        let clipPath = document.getElementById(clipPathId);
        if (!clipPath) {
            clipPath = createSVGElement('clipPath');
            clipPath.setAttribute('id', clipPathId);
            canvas.querySelector('defs').appendChild(clipPath); // Append to main defs
        } else {
            // Clear existing path if reusing clipPath (though asteroids are not pooled, this is good practice)
            while(clipPath.firstChild) {
                clipPath.removeChild(clipPath.firstChild);
            }
        }
        const clipShape = createSVGElement('path');
        clipShape.setAttribute('d', asteroidPathData); // Use the same path data as the asteroid body
        clipPath.appendChild(clipShape);
        this.element.setAttribute('clip-path', `url(#${clipPathId})`); // Apply clipping to the main asteroid group

        // Store all placed features (craters and pockmarks) to prevent overlap
        const placedFeatures = []; 
        // Calculate the effective radius for feature placement, considering asteroid irregularity
        const effectiveAsteroidRadius = this.size * (1 - ASTEROID_MAX_IRREGULARITY * 0.8); // Slightly less than min for better spread

        // Scale the number of craters and pockmarks based on asteroid size
        const sizeRatio = this.size / MAX_ASTEROID_SIZE;
        const minCraters = 2; // Always draw at least this many craters
        const maxCraters = 15;
        const numCraters = Math.floor(random(minCraters, maxCraters * sizeRatio)); 

        for (let i = 0; i < numCraters; i++) {
            let craterX, craterY, craterSize;
            let attempts = 0;
            const maxAttempts = 50; // Increased attempts to find non-overlapping position

            let foundPosition = false;
            do {
                craterSize = random(this.size * 0.05, this.size * 0.15); // Smaller craters
                // Max distance from center for crater placement, ensuring it fits within the asteroid
                const maxCraterCenterDist = effectiveAsteroidRadius - craterSize;
                
                if (maxCraterCenterDist <= 0) {
                    attempts = maxAttempts; // Force exit loop if crater is too large to fit
                    break;
                } 

                const craterAngle = random(0, Math.PI * 2);
                // Spread craters more towards the edges, away from the very center
                const craterCenterDist = random(maxCraterCenterDist * 0.3, maxCraterCenterDist); 
                craterX = craterCenterDist * Math.cos(craterAngle);
                craterY = craterCenterDist * Math.sin(craterAngle);

                // Check for overlap with already placed features (craters or pockmarks)
                let overlaps = false;
                for (const existingFeature of placedFeatures) {
                    const dist = Math.hypot(craterX - existingFeature.x, craterY - existingFeature.y);
                    if (dist < craterSize + existingFeature.r) { // Overlap detected
                        overlaps = true;
                        break;
                    }
                }

                if (!overlaps) {
                    foundPosition = true;
                }
                attempts++;
            } while (!foundPosition && attempts < maxAttempts);

            if (!foundPosition) {
                continue; // Could not find a non-overlapping position, skip this crater
            }

            // Define common properties for both ovals
            const craterOvalRadiusX = craterSize * random(0.7, 0.9); // Oval shape
            const craterOvalRadiusY = craterSize * random(0.7, 0.9);
            const craterRotation = random(0, 360); // Common rotation for both ovals

            // Crater shadow (darker oval)
            const shadowCrater = createSVGElement('ellipse');
            const shadowOffsetX = craterSize * random(0.05, 0.15); // Offset for shadow (bottom-right)
            const shadowOffsetY = craterSize * random(0.05, 0.15);

            shadowCrater.setAttribute('cx', craterX + shadowOffsetX);
            shadowCrater.setAttribute('cy', craterY + shadowOffsetY);
            shadowCrater.setAttribute('rx', craterOvalRadiusX);
            shadowCrater.setAttribute('ry', craterOvalRadiusY);
            shadowCrater.setAttribute('transform', `rotate(${craterRotation} ${craterX + shadowOffsetX} ${craterY + shadowOffsetY})`);
            shadowCrater.setAttribute('fill', this.getDarkenedColorForCrater(this.gradientId, random(0.1, 0.25))); // Less dark fill
            this.element.appendChild(shadowCrater);

            // Crater highlight (lighter oval)
            const lightCrater = createSVGElement('ellipse');
            const lightOffsetX = craterSize * random(-0.05, -0.15); // Offset for light (top-left)
            const lightOffsetY = craterSize * random(-0.05, -0.15);

            lightCrater.setAttribute('cx', craterX + lightOffsetX);
            lightCrater.setAttribute('cy', craterY + lightOffsetY);
            lightCrater.setAttribute('rx', craterOvalRadiusX); // Same size as shadow
            lightCrater.setAttribute('ry', craterOvalRadiusY); // Same size as shadow
            lightCrater.setAttribute('transform', `rotate(${craterRotation} ${craterX + lightOffsetX} ${craterY + lightOffsetY})`); // Same rotation as shadow
            lightCrater.setAttribute('fill', this.getDarkenedColorForCrater(this.gradientId, random(0.05, 0.15))); // Use darker color for light part
            lightCrater.setAttribute('opacity', random(0.6, 0.9)); // Semi-transparent for subtle effect
            this.element.appendChild(lightCrater);

            // Add the newly placed crater to the list of all features for overlap checking
            placedFeatures.push({ x: craterX, y: craterY, r: Math.max(craterOvalRadiusX, craterOvalRadiusY) });
        }

        // Add small circular pockmarks
        const minPockmarks = 3; // Always draw at least this many pockmarks
        const maxPockmarks = 25;
        const numPockmarks = Math.floor(random(minPockmarks, maxPockmarks * sizeRatio)); // Scale pockmarks by size
        for (let i = 0; i < numPockmarks; i++) {
            let pockmarkX, pockmarkY, pockmarkRadius;
            let attempts = 0;
            const maxAttempts = 50; // Increased attempts

            let foundPosition = false;
            do {
                pockmarkRadius = random(this.size * 0.01, this.size * 0.04); // Very small circles, slightly smaller max
                // Max distance from center for pockmark placement
                const maxPockmarkCenterDist = effectiveAsteroidRadius - pockmarkRadius;
                
                if (maxPockmarkCenterDist <= 0) {
                    attempts = maxAttempts; // Force exit loop
                    break;
                }

                const pockmarkAngle = random(0, Math.PI * 2);
                // Spread pockmarks more towards the edges
                const pockmarkCenterDist = random(maxPockmarkCenterDist * 0.2, maxPockmarkCenterDist);
                pockmarkX = pockmarkCenterDist * Math.cos(pockmarkAngle);
                pockmarkY = pockmarkCenterDist * Math.sin(pockmarkAngle);

                // Check for overlap with already placed features
                let overlaps = false;
                for (const existingFeature of placedFeatures) {
                    const dist = Math.hypot(pockmarkX - existingFeature.x, pockmarkY - existingFeature.y);
                    if (dist < pockmarkRadius + existingFeature.r) { // Overlap detected
                        overlaps = true;
                        break;
                    }
                }

                if (!overlaps) {
                    foundPosition = true;
                }
                attempts++;
            } while (!foundPosition && attempts < maxAttempts);

            if (!foundPosition) {
                continue; // Could not find a non-overlapping position, skip this pockmark
            }

            const pockmarkCircle = createSVGElement('circle');
            pockmarkCircle.setAttribute('cx', pockmarkX);
            pockmarkCircle.setAttribute('cy', pockmarkY);
            pockmarkCircle.setAttribute('r', pockmarkRadius);
            
            // Make pockmark color match asteroid's base color, but darker
            const pockmarkFillColor = this.getDarkenedColorForCrater(this.gradientId, random(0.1, 0.3)); // Less dark
            pockmarkCircle.setAttribute('fill', pockmarkFillColor);
            this.element.appendChild(pockmarkCircle);

            // Add the newly placed pockmark to the list of all features for overlap checking
            placedFeatures.push({ x: pockmarkX, y: pockmarkY, r: pockmarkRadius });
        }

        // Append crackGroup here, after craters and pockmarks, to ensure cracks are on top.
        if (this.crackGroup.parentNode) { // If it was already a child (e.g., from previous draw), remove it first
            this.element.removeChild(this.crackGroup);
        }
        this.element.appendChild(this.crackGroup);
      }

      /**
       * Returns a darker RGB color based on the asteroid's gradient ID.
       * @param {string} gradientId - The ID of the gradient used for the asteroid.
       * @param {number} darkenFactor - How much to darken (0 to 1, 0 means no change, 1 means black).
       * @returns {string} An RGB color string.
       */
      getDarkenedColorForCrater(gradientId, darkenFactor) {
          let baseColorRgb;
          switch (gradientId) {
              case 'asteroidGradientGrey':
                  baseColorRgb = [96, 96, 96]; // RGB for #606060 (middle of grey gradient)
                  break;
              case 'asteroidGradientBrown':
                  baseColorRgb = [128, 96, 64]; // RGB for #806040 (middle of brown gradient)
                  break;
              case 'asteroidGradientRed':
                  baseColorRgb = [144, 80, 80]; // RGB for #905050 (middle of red gradient)
                  break;
              default:
                  baseColorRgb = [50, 50, 50]; // Default dark grey
          }

          const r = Math.max(0, Math.floor(baseColorRgb[0] * (1 - darkenFactor)));
          const g = Math.max(0, Math.floor(baseColorRgb[1] * (1 - darkenFactor)));
          const b = Math.max(0, Math.floor(baseColorRgb[2] * (1 - darkenFactor)));

          return `rgb(${r},${g},${b})`;
      }

      /**
       * Returns a lighter RGB color based on the asteroid's gradient ID.
       * @param {string} gradientId - The ID of the gradient used for the asteroid.
       * @param {number} lightenFactor - How much to lighten (0 to 1, 0 means no change, 1 means max white).
       * @returns {string} An RGB color string.
       */
      getLightenedColorForCrater(gradientId, lightenFactor) {
          let baseColorRgb;
          switch (gradientId) {
              case 'asteroidGradientGrey':
                  baseColorRgb = [160, 160, 160]; // RGB for #a0a0a0 (top of grey gradient)
                  break;
              case 'asteroidGradientBrown':
                  baseColorRgb = [176, 144, 112]; // RGB for #b09070 (top of brown gradient)
                  break;
              case 'asteroidGradientRed':
                  baseColorRgb = [192, 128, 128]; // RGB for #c08080 (top of red gradient)
                  break;
              default:
                  baseColorRgb = [100, 100, 100]; // Default light grey
          }

          const r = Math.min(255, Math.floor(baseColorRgb[0] * (1 + lightenFactor)));
          const g = Math.min(255, Math.floor(baseColorRgb[1] * (1 + lightenFactor)));
          const b = Math.min(255, Math.floor(baseColorRgb[2] * (1 + lightenFactor)));

          return `rgb(${r},${g},${b})`;
      }

      /**
       * Converts local coordinates (relative to asteroid's center) to global screen coordinates.
       * @param {number} localX - Local X coordinate.
       * @param {number} localY - Local Y coordinate.
       * @returns {{x: number, y: number}} Global X and Y coordinates.
       */
      getGlobalCoordinates(localX, localY) {
          const radRotation = this.rotation * Math.PI / 180;
          const rotatedX = localX * Math.cos(radRotation) - localY * Math.sin(radRotation);
          const rotatedY = localX * Math.sin(radRotation) + localY * Math.cos(radRotation);
          return {
              x: this.x + rotatedX,
              y: this.y + rotatedY
          };
      }

      addDamageCracks(impactX = null, impactY = null) { // Removed numNewCracks and crackType parameters
          if (!this.crackGroup) return;
          // Determine the final color for the crack, which is the darkest part of the asteroid
          const finalCrackColor = this.getDarkenedColorForCrater(this.gradientId, random(0.4, 0.6)); // Use a higher darken factor for the "darkest part"

          // Convert global impact coordinates to asteroid's local coordinates
          // This is crucial because the asteroid's group is translated and rotated.
          // We need to reverse the asteroid's current transform to get the local impact point.
          let localImpactX = 0;
          let localImpactY = 0;
          if (impactX !== null && impactY !== null) {
              // Translate back to origin
              const translatedX = impactX - this.x;
              const translatedY = impactY - this.y;

              // Rotate back (inverse rotation)
              const radRotation = -this.rotation * Math.PI / 180; // Convert to radians and negate
              localImpactX = translatedX * Math.cos(radRotation) - translatedY * Math.sin(radRotation);
              localImpactY = translatedX * Math.sin(radRotation) + translatedY * Math.cos(radRotation);
          }

          // The final shaded color for the crack, which will be visible after the glow fades
          const shadedCrackColor = this.getDarkenedColorForCrater(this.gradientId, random(0.4, 0.6)); 
          const glowingCrackFadeDuration = 5000 / gameSpeedMultiplier; // Duration for the glowing crack to fade out, scaled

          // Define offsets for 3D effect, scaling with asteroid size for a more shallow 3D effect
          const offsetMagnitude = this.size * random(0.005, 0.015); // Offset scales with asteroid size
          const offsetX = offsetMagnitude;
          const offsetY = offsetMagnitude;

          let pathData = '';

          // Starburst crack logic: create a filled polygon
          const numRays = Math.floor(random(10, 20)); // Increased number of rays for more spikes
          const maxRayLength = this.size * random(0.2, 0.5); // Max length of a ray
          const innerRadiusFactor = random(0.3, 0.5); // How far in the "valley" points are
          const starburstOffsetMagnitude = this.size * random(0.05, 0.1); // Offset from impact point towards center
          
          // Calculate the starburst origin: slightly offset from impact point towards asteroid center (0,0)
          const distImpactToCenter = Math.hypot(localImpactX, localImpactY);
          let starburstOriginX = localImpactX;
          let starburstOriginY = localImpactY;

          if (distImpactToCenter > 0) { // Avoid division by zero if impact is at (0,0)
              const angleImpactToCenter = Math.atan2(localImpactY, localImpactX);
              starburstOriginX = localImpactX - starburstOffsetMagnitude * Math.cos(angleImpactToCenter);
              starburstOriginY = localImpactY - starburstOffsetMagnitude * Math.sin(angleImpactToCenter);
          }

          pathData = `M${starburstOriginX},${starburstOriginY}`; // Start at the center
          const initialOffsetAngle = random(0, Math.PI * 2); // Random initial rotation for the starburst
          const irregularityFactor = random(0.1, 0.3); // How much to offset points for irregularity

          for (let k = 0; k < numRays; k++) {
              // Outer point (peak of the ray)
              const angleOuter = (2 * Math.PI / numRays) * k + initialOffsetAngle;
              const outerX = starburstOriginX + maxRayLength * Math.cos(angleOuter);
              const outerY = starburstOriginY + maxRayLength * Math.sin(angleOuter);
              
              // Add random offset to outer points
              const outerOffsetX = random(-maxRayLength * irregularityFactor, maxRayLength * irregularityFactor);
              const outerOffsetY = random(-maxRayLength * irregularityFactor, maxRayLength * irregularityFactor);
              pathData += ` L${outerX + outerOffsetX},${outerY + outerOffsetY}`;

              // Inner point (valley between rays)
              const angleInner = (2 * Math.PI / numRays) * k + (Math.PI / numRays) + initialOffsetAngle;
              const innerX = starburstOriginX + (maxRayLength * innerRadiusFactor) * Math.cos(angleInner);
              const innerY = starburstOriginY + (maxRayLength * innerRadiusFactor) * Math.sin(angleInner);
              
              // Add random offset to inner points
              const innerOffsetX = random(-maxRayLength * irregularityFactor * 0.5, maxRayLength * irregularityFactor * 0.5); // Smaller offset for inner points
              const innerOffsetY = random(-maxRayLength * irregularityFactor * 0.5, maxRayLength * irregularityFactor * 0.5);
              pathData += ` L${innerX + innerOffsetX},${innerY + innerOffsetY}`;
          }
          pathData += ` Z`; // Close the polygon

          // Shaded crack (bottom layer)
          const shadedCrack = createSVGElement('path');
          shadedCrack.setAttribute('d', pathData);
          shadedCrack.setAttribute('fill', shadedCrackColor); // Solid shaded color
          shadedCrack.setAttribute('stroke', 'none');
          shadedCrack.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
          shadedCrack.setAttribute('opacity', 0.5); // Start 50% transparent
          this.crackGroup.appendChild(shadedCrack);

          // Glowing crack (top layer)
          const glowingCrack = createSVGElement('path');
          glowingCrack.setAttribute('d', pathData);
          glowingCrack.setAttribute('fill', 'url(#crackGradient)'); // Gradient fill
          glowingCrack.setAttribute('stroke', 'none');
          glowingCrack.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
          glowingCrack.setAttribute('filter', 'url(#crackGlowFilter)'); // Apply the shared glow filter
          // Opacity is managed by CrackEffect
          this.crackGroup.appendChild(glowingCrack);

          // Create sparks at the starburst origin
          const globalStarburstOrigin = this.getGlobalCoordinates(starburstOriginX, starburstOriginY);
          createExplosion(globalStarburstOrigin.x, globalStarburstOrigin.y, this.size * 0.1, 'spark');

          this.activeCrackEffects.push(new CrackEffect(
              glowingCrack,
              shadedCrack, // Pass the shaded crack element
              glowingCrackFadeDuration
          ));
      }

      update(deltaTime) {
        // Always update position and rotation based on velocity, regardless of destruction state
        this.x += this.vx * deltaTime; 
        this.y += this.vy * deltaTime; 
        this.rotation += this.vRotation * deltaTime; 

        // Update and clean up crack effects (only one, the starburst glow)
        // This loop will run for the single starburst crack effect.
        for (let i = this.activeCrackEffects.length - 1; i >= 0; i--) {
            const effect = this.activeCrackEffects[i];
            // Defensive check: ensure 'effect' itself is a valid object with an update method
            if (!effect || typeof effect.update !== 'function') {
                this.activeCrackEffects.splice(i, 1);
                continue; // Skip to the next iteration
            }

            if (effect.update()) { // If the effect is dead
                // Defensive check: ensure 'glowingElement' exists and is a valid SVGElement
                // before attempting to access its parentNode.
                if (effect.glowingElement instanceof SVGElement) {
                    // Check if it's still a child of the expected crackGroup
                    // parentNode can be null if the element was already removed from DOM
                    if (effect.glowingElement.parentNode === this.crackGroup) {
                        this.crackGroup.removeChild(effect.glowingElement);
                    }
                }
                this.activeCrackEffects.splice(i, 1);
            }
        }

        if (this.isDestroyed) {
            const elapsed = Date.now() - this.destroyStartTime;
            let effectiveGameSpeedMultiplier = gameSpeedMultiplier;
            if (effectiveGameSpeedMultiplier === 0) {
                effectiveGameSpeedMultiplier = 0.001; // Prevent division by zero
            }

            // Calculate fade progress (0 to 1 over fadeDuration)
            const fadeProgress = Math.min(1, elapsed / (this.fadeDuration));
            // Calculate overall animation progress (0 to 1 over totalAnimationDuration)
            const totalProgress = elapsed / (this.totalAnimationDuration);

            if (totalProgress >= 1) {
                // Animation complete, remove from DOM and mark for array removal
                if (this.element.parentNode) {
                    gameplayLayer.removeChild(this.element);
                }
                return true; // Mark for removal from asteroids array
            }

            // Update opacity based on fadeProgress
            this.element.style.opacity = Math.max(0, 1 - fadeProgress);
            // Update scale based on fadeProgress (scale should complete when fade completes)
            const currentScale = 1 + (0.5 * fadeProgress); // Scale from 1 to 1.5

            // Apply transform including current position, rotation, and scaling
            this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${this.rotation}) scale(${currentScale})`);
            return false; // Still alive for animation purposes
        } else {
            // Normal wrapping logic if not destroyed
            if (this.x < -this.size) {
              this.x = width + this.size;
            }
            else if (this.x > width + this.size) {
              this.x = -this.size;
            }
            
            if (this.y < -this.size) {
              this.y = height + this.size;
            }
            else if (this.y > height + this.size) {
              this.y = -this.size;
            }

            this.updatePosition(); // Apply normal transform

            // Return true if the asteroid is far off-screen and should be removed
            const removalBuffer = this.size * 2;
            if (this.x < -removalBuffer || this.x > width + removalBuffer ||
                this.y < -removalBuffer || this.y > height + removalBuffer) {
                return true; // Mark for removal
            }
            return false; // Still alive and on-screen or within buffer
        }
      }

      takeDamage(damage, laserAngle, impactX, impactY) { // Added impactX, impactY
        if (this.isDestroyed) {
            return; // Do not apply damage or effects if already destroyed
        }
        this.health -= damage;

        // Create sparks at the impact point, inheriting asteroid's velocity, and flying back along the laser angle
        createExplosion(impactX, impactY, this.size * SCALE_FACTOR, 'spark', this.vx, this.vy, laserAngle);

        // Only add the starburst crack on the first hit
        if (!this.hasStarburstCrack) {
            this.addDamageCracks(impactX, impactY); // Call without numNewCracks or crackType
            this.hasStarburstCrack = true; // Mark that the starburst crack has been added
        }

        const deflectionForce = 0.5 / TARGET_FRAME_DURATION; 
        this.vx += Math.cos(laserAngle) * deflectionForce;
        this.vy += Math.sin(laserAngle) * deflectionForce;
        this.vRotation += random(-1, 1) / TARGET_FRAME_DURATION; 

        if (this.health <= 0) {
          this.destroy();
        }
      }

      destroy(isNukeHit = false) { 
        // Calculate pitch based on asteroid size: smaller asteroids get higher pitch
        const minOverallSize = MIN_ASTEROID_SIZE;
        const maxOverallSize = MAX_ASTEROID_SIZE;
        const minTargetPitch = 0.025; // Pitch for largest objects (even bassier)
        const maxTargetPitch = 0.25; // Pitch for smallest objects (deeper)

        const normalizedSize = (this.size - minOverallSize) / (maxOverallSize - minOverallSize);
        const clampedNormalizedSize = Math.max(0, Math.min(1, normalizedSize)); // Ensure value is between 0 and 1
        const basePitch = maxTargetPitch - (clampedNormalizedSize * (maxTargetPitch - minTargetPitch));
        // Add a random multiplier to basePitch for more pronounced variation
        const finalPitch = basePitch * random(0.7, 1.3); 

        // Set flags for destruction animation first, so totalAnimationDuration is available
        this.isDestroyed = true;
        this.destroyStartTime = Date.now();
        
        // Calculate durations based on constants and game speed
        let effectiveGameSpeedMultiplier = gameSpeedMultiplier;
        if (effectiveGameSpeedMultiplier === 0) {
            effectiveGameSpeedMultiplier = 0.001; // Prevent division by zero
        }
        this.fadeDuration = ASTEROID_FADE_DURATION / effectiveGameSpeedMultiplier;
        this.postFadeDuration = ASTEROID_POST_FADE_DURATION / effectiveGameSpeedMultiplier;
        this.totalAnimationDuration = this.fadeDuration + this.postFadeDuration;

        // Create a fireball effect for the asteroid explosion
        let fireball = fireballPool.pop();
        if (!fireball) {
            fireball = new FireballEffect();
        }
        const asteroidExplosionFireballFinalSize = this.size * 2.5; // Starting size reduced to 50% of previous value
        // Pass the asteroid's total animation duration to the fireball to ensure it lasts as long as the asteroid fades
        fireball.reset(
            this.x,
            this.y,
            asteroidExplosionFireballFinalSize, // Start at the larger calculated size
            asteroidExplosionFireballFinalSize * FIREBALL_INITIAL_SIZE_FACTOR, // End at a smaller fraction of the initial size
            'visual',
            this.totalAnimationDuration,
            0.85,
            2
        );
        activeFireballs.push(fireball);

        playSpatialSound(explosionBuffer, this.x, 1, finalPitch); 
        // Explosion particles should inherit asteroid's velocity
        createExplosion(this.x, this.y, this.size * SCALE_FACTOR, 'explosion', this.vx, this.vy);


        // IMPORTANT: Do NOT remove from asteroids array here.
        // It will be removed by the main loop when update() returns true after animation.

        // Do not explicitly remove crack elements here.
        // They are children of this.element and will fade/scale with it.
        // The activeCrackEffects array will be cleaned up by Asteroid.update()
        // as the glowing cracks fade out.

        // Remove the clipPath definition from defs to prevent memory leaks
        const clipPathElement = document.getElementById(`asteroidClip-${this.id}`);
        if (clipPathElement && clipPathElement.parentNode) {
            clipPathElement.parentNode.removeChild(clipPathElement);
        }

        const newSize = this.size * 0.6; // Asteroids split into 60% of their original size

        // Only split if not hit by nuke and the new resulting asteroids are large enough to be 'splittable' themselves.
        if (!isNukeHit && newSize >= MIN_ASTEROID_SIZE_FOR_SPLIT) {
          const spawnOffsetMagnitude = newSize * 0.8; // Offset by a factor of the new asteroid's size
          const initialSpawnAngle = random(0, Math.PI * 2); // Random angle for the first asteroid's offset

          const inheritedSpeedFactor = random(0.8, 1.2);
          const inheritedRotationFactor = random(0.8, 1.2);
          const kickSpeedMagnitude = random(0.2, 0.6) / TARGET_FRAME_DURATION;

          const spawnAsteroid = (angleOffset) => {
            const spawnX = this.x + Math.cos(initialSpawnAngle + angleOffset) * spawnOffsetMagnitude;
            const spawnY = this.y + Math.sin(initialSpawnAngle + angleOffset) * spawnOffsetMagnitude;
            const angle = random(0, Math.PI * 2);
            const newVx = this.vx * inheritedSpeedFactor + Math.cos(angle) * kickSpeedMagnitude;
            const newVy = this.vy * inheritedSpeedFactor + Math.sin(angle) * kickSpeedMagnitude;
            const newVRotation = this.vRotation * inheritedRotationFactor + random(-0.3, 0.3) / TARGET_FRAME_DURATION; // Individual random rotation kick

            asteroids.push(new Asteroid(
              spawnX,
              spawnY,
              newSize,
              newSize,
              newVx, newVy, newVRotation,
              this.gradientId,
              this.element
            ));
          };

          if (newSize >= MIN_ASTEROID_SIZE_FOR_SPLIT_INTO_THREE) {
            // Split into 3
            spawnAsteroid(0);
            spawnAsteroid(2 * Math.PI / 3);
            spawnAsteroid(4 * Math.PI / 3);
          } else {
            // Split into 2 (for 2nd to smallest tier)
            spawnAsteroid(0);
            spawnAsteroid(Math.PI); // Opposite direction
          }
        }

        // If on iOS, just remove the element immediately after splitting.
        // Otherwise, set flags for the expand and fade animation.
        if (isIOS) {
            if (this.element.parentNode) {
                gameplayLayer.removeChild(this.element); // Remove from gameplay layer
            }
        } else {
            // Opacity and transform (including scale) will be updated continuously in the update method
            // No CSS transitions are applied to ensure smooth JS control.
        }
      }
    }

    /**
     * Represents a laser beam.
     * @param {number} startX - Starting X coordinate.
     * @param {number} startY - Starting Y coordinate.
     * @param {number} angle - Angle of the laser in radians.
     * @param {string} type - Type of laser ('defender' or 'user'). // Renamed from 'satellite'
     * @param {number} [targetX] - Target X coordinate for user lasers.
     * @param {number} [targetY] - Target Y coordinate for user lasers.
     * @param {SVGElement} [element=null] - Optional existing SVG element to reuse.
     */
    class Laser {
      constructor() { // Constructor no longer takes initial position/angle
        this.element = createSVGElement('g');
        this.element.setAttribute('class', 'laser-beam');
        // Do NOT append to gameplayLayer here; append in reset() when activated.

        // shapeElement will be created dynamically in reset() based on laser type
        this.shapeElement = null; 

        // Ensure it's hidden and off-screen initially
        this.element.style.display = 'none';
        this.element.setAttribute('transform', 'translate(-9999,-9999)');
      }

      // Reset method now takes all parameters and configures the laser for use
      reset(startX, startY, angle, type, predictedTargetX, predictedTargetY, actualTarget = null, commonCollisionTimeMs = null, commonTotalVisualDurationMs = null) {
        // Append to gameplayLayer here to ensure it's in the DOM when active
        if (!this.element.parentNode) { // Only append if not already in DOM
            gameplayLayer.appendChild(this.element);
        }

        // Remove existing shapeElement if it's the wrong type or doesn't exist
        if (this.shapeElement && 
            ((type === 'user' && this.shapeElement.tagName !== 'polygon') || 
             (type === 'defender' && this.shapeElement.tagName !== 'rect'))) {
            this.element.removeChild(this.shapeElement);
            this.shapeElement = null;
        }

        // Create shapeElement if it doesn't exist or was removed
        if (!this.shapeElement) {
            if (type === 'user') {
                this.shapeElement = createSVGElement('polygon');
            } else { // defender
                this.shapeElement = createSVGElement('rect');
            }
            this.element.appendChild(this.shapeElement);
        }

        this.shapeElement.removeAttribute('filter'); // Ensure no lingering filter from previous use
        this.x = startX; // Current leading edge X
        this.y = startY; // Current leading edge Y
        this.startX = startX; // Store initial start X for distance calculation
        this.startY = startY; // Store initial start Y for distance calculation
        this.predictedTargetX = predictedTargetX; // Store predicted coordinates
        this.predictedTargetY = predictedTargetY;
        this.actualTarget = actualTarget; // Store actual target object (for defender lasers)
        this.angle = angle;
        this.type = type;
        this.hasDamaged = false;
        this.impactTriggered = false; // Flag to indicate if the impact logic has been triggered (hit or miss)

        const settings = qualitySettings[currentQualityLevel];
        this.damage = type === 'user' ? 10 : 10;

        // Update shapeElement attributes based on type
        if (this.type === 'user') {
            this.initialWidth = 120 * SCALE_FACTOR; // Max width of the pulse (increased for wider look)
            this.finalWidth = 1 * SCALE_FACTOR; // Min width of the pulse (tapered end)
            // The maxLength is the distance to the target PLUS the overshoot distance for visual effect.
            this.maxLength = Math.hypot(this.predictedTargetX - this.startX, this.predictedTargetY - this.startY) + USER_LASER_OVERSHOOT_DISTANCE;

            // Calculate velocity for the pulse based on individual distance and common collision time
            // This ensures all user lasers arrive at the target simultaneously.
            const individualLaserSpeed = this.maxLength / commonCollisionTimeMs;
            this.vx = Math.cos(angle) * individualLaserSpeed;
            this.vy = Math.sin(angle) * individualLaserSpeed;

            // Set collision and total visual durations from the common calculated values
            this.collisionTimeMs = commonCollisionTimeMs;
            this.totalVisualDurationMs = commonTotalVisualDurationMs;
            this.totalTravelDistance = individualLaserSpeed * this.totalVisualDurationMs; // Total distance leading edge travels

            this.lifeRemaining = this.totalVisualDurationMs; // Initialize remaining life
            this.startTime = Date.now(); // For reference, not directly used for progress

            this.initialPulseLength = USER_LASER_INITIAL_PULSE_LENGTH * SCALE_FACTOR; // Initial visual length
            // this.finalPulseLength is no longer used for length, but width will taper to this.finalWidth

            this.shapeElement.setAttribute('fill', settings.laserGradient ? 'url(#userLaserGradient)' : 'rgb(0, 255, 0)');
            this.shapeElement.removeAttribute('stroke');
            this.shapeElement.removeAttribute('stroke-width');
            // Removed rx and ry as they are for rect, not polygon
            this.shapeElement.removeAttribute('filter'); // Ensure no filter from previous use
            // No initial dimensions for polygon here; points will be set in update()
        } else { // Defender laser
            this.initialWidth = 4.5 * SCALE_FACTOR; // Fixed width for defender (half current width)
            this.initialLength = 250 * SCALE_FACTOR; // Fixed length for defender (increased)
            
            // Defender lasers travel at a fixed speed
            this.vx = Math.cos(angle) * DEFENDER_LASER_SPEED_PX_PER_MS;
            this.vy = Math.sin(angle) * DEFENDER_LASER_SPEED_PX_PER_MS;

            // Calculate total distance to target for life calculation
            this.totalDistance = Math.hypot(predictedTargetX - startX, predictedTargetY - startY);
            // Calculate collision time and total visual duration for defender lasers
            this.collisionTimeMs = this.totalDistance / DEFENDER_LASER_SPEED_PX_PER_MS; // Time for leading edge to reach target
            this.totalVisualDurationMs = this.collisionTimeMs; // Total time laser is visible (disappears on impact)

            this.lifeRemaining = this.totalVisualDurationMs; // Initialize remaining life
            this.startTime = Date.now(); // For reference, used for elapsed time calculation

            this.shapeElement.setAttribute('fill', settings.laserGradient ? 'url(#satelliteLaserGradient)' : 'rgb(255, 0, 0)');
            this.shapeElement.removeAttribute('stroke');
            this.shapeElement.removeAttribute('stroke-width');
            this.shapeElement.setAttribute('rx', 3);
            this.shapeElement.setAttribute('ry', 3);
            // Set dimensions for defender laser
            this.shapeElement.setAttribute('x', 0);
            this.shapeElement.setAttribute('y', -this.initialWidth / 2);
            this.shapeElement.setAttribute('width', this.initialLength);
            this.shapeElement.setAttribute('height', this.initialWidth);
            this.shapeElement.removeAttribute('filter'); // Ensure no filter from previous use
        }
        // Visibility and opacity are handled by the caller when retrieving from pool
        this.updatePosition(); // Initial position and size
      }

      update(scaledDeltaTime) {
        const now = Date.now();

        if (this.type === 'user') {
            // effectiveGameSpeedMultiplier is already defined in the outer scope of update()
            
            // User lasers should scale with game speed.
            // All time-related values for user lasers (speed, duration) are now in game-time.
            const collisionTimeGameMs = this.collisionTimeMs; // This is now game-time
            const totalVisualDurationGameMs = this.totalVisualDurationMs; // This is now game-time

            this.x += this.vx * scaledDeltaTime; // Use scaledDeltaTime for game-speed movement
            this.y += this.vy * scaledDeltaTime; // Use scaledDeltaTime for game-speed movement

            // The laser's tip should not overshoot its target in game units.
            // Check if the laser's current tip (this.x, this.y) has reached or passed the predicted target.
            // This is a more robust way to handle collision and post-impact state than just using `elapsed`.
            const distTravelledSq = (this.x - this.startX) * (this.x - this.startX) + (this.y - this.startY) * (this.y - this.startY);
            const distToTargetSq = (this.predictedTargetX - this.startX) * (this.predictedTargetX - this.startX) + (this.predictedTargetY - this.startY) * (this.predictedTargetY - this.startY);
            
            let effectivePulseLength;
            let taperedWidth;

            if (distTravelledSq < distToTargetSq) { // Before impact
                const travelProgress = Math.sqrt(distTravelledSq) / Math.sqrt(distToTargetSq);
                effectivePulseLength = this.initialPulseLength + (this.maxLength - this.initialPulseLength) * travelProgress;
                taperedWidth = this.initialWidth + (this.finalWidth - this.initialWidth) * travelProgress;
            } else { // After impact (or reached target)
                // Lock the laser's tip to the predicted target position
                this.x = this.predictedTargetX;
                this.y = this.predictedTargetY;

                // Collision logic for impact event (only trigger once)
                if (!this.impactTriggered) {
                    this.impactTriggered = true; // Mark that impact logic has been triggered

                    let hitObject = null;
                    const hitDetectionRadius = 10 * SCALE_FACTOR; // Radius around the actual target point

                    // Check UFOs at the actual predicted target point
                    for (let j = ufos.length - 1; j >= 0; j--) {
                        const currentUfo = ufos[j];
                        if (Math.hypot(this.predictedTargetX - currentUfo.x, this.predictedTargetY - currentUfo.y) < currentUfo.size + hitDetectionRadius) {
                            hitObject = currentUfo;
                            break;
                        }
                    }

                    if (!hitObject) {
                        // Check asteroids at the actual predicted target point
                        for (let j = asteroids.length - 1; j >= 0; j--) {
                            const asteroid = asteroids[j];
                            if (Math.hypot(this.predictedTargetX - asteroid.x, this.predictedTargetY - asteroid.y) < asteroid.size + hitDetectionRadius) {
                                hitObject = asteroid;
                                break;
                            }
                        }
                    }

                    if (hitObject) {
                        // Pass the actual predicted target coordinates for damage and explosion
                        hitObject.takeDamage(this.damage, this.angle, this.predictedTargetX, this.predictedTargetY);
                        createExplosion(this.predictedTargetX, this.predictedTargetY, hitObject.size, 'spark');
                        this.hasDamaged = true; // Set flag
                    }
                }

                // Fade out after impact
                const postImpactGameTimeElapsed = totalVisualDurationGameMs - this.lifeRemaining;
                const postImpactProgress = Math.min(1, postImpactGameTimeElapsed / USER_LASER_POST_IMPACT_DURATION);
                
                effectivePulseLength = this.maxLength * (1 - postImpactProgress); 
                taperedWidth = this.finalWidth; 
            }

            // Ensure effective length doesn't go negative (laser should disappear when base passes tip)
            effectivePulseLength = Math.max(0, effectivePulseLength);
            taperedWidth = Math.max(this.finalWidth, taperedWidth); // Ensure width doesn't go below finalWidth

            // Define points for the triangular pulse relative to the group's local origin (0,0)
            // The group's origin (this.x, this.y) is now the tip of the laser.
            // The laser extends backwards along the local X-axis.
            const points = `0,0 ` + // Tip point (at the group's origin)
                           `${-effectivePulseLength},${taperedWidth / 2} ` + // Base point 1 (bottom-left)
                           `${-effectivePulseLength},${-taperedWidth / 2}`; // Base point 2 (top-left)
            this.shapeElement.setAttribute('points', points);
            
            // Opacity: full until impact, then fade out over USER_LASER_POST_IMPACT_DURATION
            if (distTravelledSq < distToTargetSq) {
                this.element.style.opacity = 1; // Fully opaque before impact point
            } else {
                // Calculate fade progress from impact point to end of post-impact duration
                const fadeProgress = (totalVisualDurationGameMs - this.lifeRemaining) / USER_LASER_POST_IMPACT_DURATION;
                this.element.style.opacity = Math.max(0, 1 - fadeProgress); // Fade from 1 to 0
            }

            // Update lifeRemaining for removal check
            this.lifeRemaining -= scaledDeltaTime; // Decrement life by scaledDeltaTime

        } else { // Defender laser
            this.x += this.vx * scaledDeltaTime; // Defender laser's origin moves
            this.y += this.vy * scaledDeltaTime;

            // Calculate the tip of the defender laser for collision detection
            const tipX = this.x + Math.cos(this.angle) * this.initialLength;
            const tipY = this.y + Math.sin(this.angle) * this.initialLength;

            // effectiveGameSpeedMultiplier is already defined in the outer scope of update()

            // Continuous collision check for defender lasers as they travel
            // Use a larger collision radius for defender lasers to make them more effective
            const collisionRadius = 20 * SCALE_FACTOR; // Increased from 10
            // Collision check happens when the real-time distance travelled is sufficient,
            // or when the scaled game-time has progressed enough.
            // Simplified: check if tip overlaps target
            if (!this.impactTriggered && this.actualTarget && Math.hypot(tipX - this.actualTarget.x, tipY - this.actualTarget.y) < (this.actualTarget.size / 2) + collisionRadius) {
                this.impactTriggered = true; // Mark that impact logic has been triggered
                // The target object is already known: this.actualTarget
                // For defender lasers hitting UFOs, force impact to the UFO's center for visual consistency
                const impactX = this.actualTarget.x;
                const impactY = this.actualTarget.y;
                this.actualTarget.takeDamage(this.damage, this.angle, impactX, impactY); // Pass UFO's center as impact coordinates
                createExplosion(impactX, impactY, this.actualTarget.size, 'spark', 0, 0, this.angle); // UFOs don't have parentVx/Vy for sparks
                this.hasDamaged = true;
            }

            // Opacity and life management for defender lasers
            if (this.impactTriggered) { // If impact has occurred, disappear immediately
                this.lifeRemaining = 0; // Set game-time life remaining to 0
                this.element.style.opacity = 0;
            } else {
                this.element.style.opacity = 1; // Fully opaque until impact
                this.shapeElement.setAttribute('x', 0); // Ensure full length
                this.shapeElement.setAttribute('width', this.initialLength); // Ensure full length
                // lifeRemaining is in game-time. Decrease by scaledDeltaTime.
                this.lifeRemaining -= scaledDeltaTime;
            }
        }

        this.updatePosition();

        return this.lifeRemaining <= 0; // Return true if laser's time is up
      }

      remove() {
        this.element.style.display = 'none'; // Hide the element
        this.element.setAttribute('transform', 'translate(-9999,-9999)'); // Move off-screen
        this.shapeElement.removeAttribute('filter'); // Explicitly remove filter
        
        // Explicitly remove from DOM when returning to pool
        if (this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
        // Return to pool only if the pool is not full, otherwise allow for garbage collection
        if (laserPool.length < MAX_LASERS) {
            laserPool.push(this);
        }
      }

      updatePosition() {
        // Defensive check to prevent errors if x or y become undefined/NaN unexpectedly
        if (typeof this.x !== 'number' || isNaN(this.x) || typeof this.y !== 'number' || isNaN(this.y)) {
            console.error("Laser position (x or y) is invalid:", this.x, this.y, "Laser instance:", this);
            this.x = 0; 
            this.y = 0;
        }

        let rotationDegrees = this.angle * 180 / Math.PI;
        
        // For both user and defender lasers, the group's origin is the laser's start point.
        // The rect within the group is then drawn from that origin, extending along the angle.
        this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${rotationDegrees})`);
      }
    }

    /**
     * Represents a nuke projectile.
     */
    class Nuke {
        constructor() {
            this.element = createSVGElement('g');
            this.element.setAttribute('class', 'nuke-projectile');
            // Do NOT append to gameplayLayer here; append in reset() to ensure it's on top.

            this.shapeElement = createSVGElement('circle');
            this.element.appendChild(this.shapeElement);

            // Ensure it's hidden and off-screen initially
            this.element.style.display = 'none';
            this.element.setAttribute('transform', 'translate(-9999,-9999)');
        }

        reset(startX, startY, targetX, targetY) {
            this.x = startX;
            this.y = startY;
            this.targetX = targetX;
            this.targetY = targetY;
            this.hasExploded = false;

            this.initialProjectileSize = 80 * SCALE_FACTOR; // Start large
            this.finalProjectileSize = 1 * SCALE_FACTOR; // Shrink to this size
            this.explosionRadius = 1000 * SCALE_FACTOR; // Increased radius of destruction for the nuke
            this.speed = 5.0 / TARGET_FRAME_DURATION; // Speed remains the same

            this.vx = Math.cos(Math.atan2(targetY - startY, targetX - startX)) * this.speed;
            this.vy = Math.sin(Math.atan2(targetY - startY, targetX - startX)) * this.speed;

            // Store initial Y for progress calculation
            this.initialY = startY;

            // No initial life calculation needed for projectile flight; movement is determined by target position.
            // Explosion fade-out life is set upon explosion.

            this.shapeElement.setAttribute('fill', 'url(#nukeGradient)'); // Use radial gradient
            this.shapeElement.removeAttribute('stroke'); // Remove stroke
            this.shapeElement.removeAttribute('stroke-width'); // Remove stroke-width
            this.shapeElement.removeAttribute('filter'); // Remove glow filter

            // Append to gameplayLayer here to ensure it's on top of other elements when activated
            gameplayLayer.appendChild(this.element);
            this.element.style.display = ''; // Make visible
            this.element.style.opacity = 1; // Ensure full opacity at start
            this.updatePosition(); // Initial position
        }

        update(scaledDeltaTime) {
            // effectiveGameSpeedMultiplier is now defined in the main update loop and ensures scaledDeltaTime is never 0.
            // Local definition is no longer needed here for this purpose.

            if (this.hasExploded) {
                this.explosionFadeLifeRemaining -= scaledDeltaTime; // Just fade out if already exploded, scaled
                // Use the stored initial fade life, which was calculated with the appropriate effective speed.
                this.element.style.opacity = this.explosionFadeLifeRemaining / this.initialExplosionFadeLife;
                return this.explosionFadeLifeRemaining <= 0; // Return true if completely faded
            }

            this.x += this.vx * scaledDeltaTime;
            this.y += this.vy * scaledDeltaTime;

            // Calculate progress for scaling (0 at startY, 1 at targetY)
            // Since it moves upwards, y decreases.
            const travelRange = this.initialY - this.targetY;
            let progress = 0;
            if (travelRange > 0) { // Avoid division by zero
                progress = (this.initialY - this.y) / travelRange;
                progress = Math.max(0, Math.min(1, progress)); // Clamp between 0 and 1
            }
            
            // Interpolate size based on progress
            const currentRadius = this.initialProjectileSize + (this.finalProjectileSize - this.initialProjectileSize) * progress;
            this.shapeElement.setAttribute('r', currentRadius);

            // Check if reached or passed target (since it moves upwards)
            if (this.y <= this.targetY) {
                this.explode();
                this.hasExploded = true;
                // Calculate fade life using the current gameSpeedMultiplier for consistency
                // If gameSpeedMultiplier is 0, this will effectively make fade duration very long (1000 / 0.001)
                this.explosionFadeLifeRemaining = 1000 / (gameSpeedMultiplier === 0 ? 0.001 : gameSpeedMultiplier); // Doubled for longer fade
                this.initialExplosionFadeLife = this.explosionFadeLifeRemaining; // Store for opacity calculation
                this.element.style.display = ''; // Ensure display is not 'none' for fade-out to be visible
            }

            this.updatePosition();
            return false; // Nuke is active either as a projectile or during explosion fade
        }

        explode() {
            playNukeExplosionEffect(this.x, this.y); // Play nuke explosion sound

            // Trigger full-screen white flash
            if (nukeFlashElement) {
                nukeFlashElement.setAttribute('x', 0);
                nukeFlashElement.setAttribute('y', 0);
                nukeFlashElement.setAttribute('width', width);
                nukeFlashElement.setAttribute('height', height);
                nukeFlashElement.setAttribute('fill', 'white');
                nukeFlashElement.style.transition = 'none'; // Disable transition for instant flash
                nukeFlashElement.style.opacity = 1;
                nukeFlashElement.style.display = ''; // Make visible

                // Use gameSpeedMultiplier directly for flash timings, handling 0 case with ternary
                const flashDelay = 10 / (gameSpeedMultiplier === 0 ? 0.001 : gameSpeedMultiplier);
                const fadeDuration = 6000 / (gameSpeedMultiplier === 0 ? 0.001 : gameSpeedMultiplier); // Doubled for longer fade

                // Trigger fade after a very short delay to ensure opacity 1 is rendered
                setTimeout(() => {
                    nukeFlashElement.style.transition = `opacity ${fadeDuration / 1000}s ease-out`;
                    nukeFlashElement.style.opacity = 0;
                }, flashDelay);

                // Hide element after transition
                setTimeout(() => {
                    nukeFlashElement.style.display = 'none';
                }, flashDelay + fadeDuration); // Total duration scaled live
            }

            // Create the main expanding fireball visual effect
            let fireball = fireballPool.pop();
            if (!fireball) {
                fireball = new FireballEffect();
            }
            // Nuke fireball, type is 'nuke'
            const nukeFireballFinalSize = this.explosionRadius * SCALE_FACTOR;
            fireball.reset(this.x, this.y, nukeFireballFinalSize * FIREBALL_INITIAL_SIZE_FACTOR, nukeFireballFinalSize, 'nuke');
            activeFireballs.push(fireball);
            
            destroyObjectsInRadius(this.x, this.y, this.explosionRadius * SCALE_FACTOR, true);
            // DO NOT set display: 'none' here. Let the update() method handle fading opacity.
        }

        remove() {
            this.element.style.display = 'none'; // Hide the element
            this.element.setAttribute('transform', 'translate(-9999,-9999)'); // Move off-screen
            this.shapeElement.removeAttribute('filter'); // Explicitly remove filter
            
            // Explicitly remove from DOM when returning to pool
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            // Return to pool only if the pool is not full, otherwise allow for garbage collection
            if (nukePool.length < MAX_NUKES) {
                nukePool.push(this);
            }
        }

        updatePosition() {
            this.element.setAttribute('transform', `translate(${this.x}, ${this.y})`);
            this.shapeElement.setAttribute('cx', 0); // Center circle within its group
            this.shapeElement.setAttribute('cy', 0);
        }
    }

    /**
     * Represents an expanding circular fireball effect.
     */
    class FireballEffect {
        constructor() {
            this.element = createSVGElement('circle');
            this.element.setAttribute('class', 'fireball-effect');

            // Ensure it's hidden and off-screen initially
            this.element.style.display = 'none';
            this.element.setAttribute('cx', -9999);
            this.element.setAttribute('cy', -9999);
        }

        reset(
            x,
            y,
            initialRadius,
            finalRadius,
            type = 'visual',
            explicitDurationMs = null,
            fadeStartProgress = 0.7,
            fadeCurveExponent = 1
        ) {
            this.x = x;
            this.y = y;
            this.initialRadius = initialRadius; // Initial radius of the fireball
            this.finalRadius = finalRadius; // Final radius the fireball expands to
            this.explicitDurationMs = explicitDurationMs; // Store explicit duration if provided
            this.fadeStartProgress = Math.min(1, Math.max(0, fadeStartProgress)); // Clamp fade start within [0,1]
            this.fadeCurveExponent = Math.max(0.01, fadeCurveExponent); // Prevent zero or negative exponent

            // Calculate originalDuration based on the expansion rate and total expansion amount
            // This is used if no explicitDurationMs is provided.
            this.calculatedDuration = (this.finalRadius - this.initialRadius) / FIREBALL_EXPANSION_RATE_PX_PER_MS;
            // Ensure a minimum duration to prevent instant disappearance for very small expansions
            if (this.calculatedDuration < 10) this.calculatedDuration = 10; // Minimum 10ms
            
            this.startTime = Date.now();
            this.isAlive = true;
            this.type = type; // Store the type
            this.hasAppliedDamage = false; // Flag to ensure damage is applied only once

            this.element.setAttribute('cx', this.x);
            this.element.setAttribute('cy', this.y);
            // Append to effectsLayer here to ensure it's on top of other elements when activated
            effectsLayer.appendChild(this.element);
            this.element.setAttribute('r', this.initialRadius); // Start with the specified initial radius
            // Fill is set in reset, but can be overridden by destroy() for UFOs
            this.element.setAttribute('fill', 'url(#fireballGradient)'); // Default to standard fireball gradient
            this.element.style.opacity = 1; // Start fully opaque
            this.element.style.display = ''; // Make visible
        }

        update() {
            const elapsed = Date.now() - this.startTime;
            let effectiveGameSpeedMultiplier = gameSpeedMultiplier;
            if (effectiveGameSpeedMultiplier === 0) {
                effectiveGameSpeedMultiplier = 0.001; // Prevent division by zero, make it extremely slow
            }

            // Use explicit duration if provided, otherwise use calculated duration
            const baseDuration = this.explicitDurationMs !== null ? this.explicitDurationMs : this.calculatedDuration;
            const effectiveDuration = baseDuration / effectiveGameSpeedMultiplier;
            let progress = elapsed / effectiveDuration;

            if (progress >= 1) {
                this.isAlive = false;
                this.element.style.display = 'none'; // Hide when dead
                return true; // Mark for removal
            }

            // Calculate current radius: expands from initialRadius to finalRadius
            const currentRadius = this.initialRadius + (this.finalRadius - this.initialRadius) * progress;
            this.element.setAttribute('r', currentRadius);

            // Apply damage only once when the fireball reaches a significant size
            // The damage radius is the current visual radius of the fireball.
            if (this.type === 'nuke' && !this.hasAppliedDamage && progress >= 0.2) {
                destroyObjectsInRadius(this.x, this.y, currentRadius, true);
                this.hasAppliedDamage = true;
            }

            // Fade out towards the end
            if (progress > this.fadeStartProgress) {
                const fadeDenominator = 1 - this.fadeStartProgress;
                let fadeProgress = fadeDenominator <= 0 ? 1 : (progress - this.fadeStartProgress) / fadeDenominator;
                fadeProgress = Math.min(1, Math.max(0, fadeProgress));
                const easedFade = Math.pow(fadeProgress, this.fadeCurveExponent);
                this.element.style.opacity = 1 - easedFade;
            } else {
                this.element.style.opacity = 1;
            }
            return false;
        }

        remove() {
            this.element.style.display = 'none';
            this.element.setAttribute('cx', -9999);
            this.element.setAttribute('cy', -9999);
            
            // Explicitly remove from DOM when returning to pool
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            // Return to pool only if the pool is not full, otherwise allow for garbage collection
            if (fireballPool.length < MAX_FIREBALLS) {
                fireballPool.push(this);
            }
        }
    }

    /**
     * Represents a UFO.
     */
    class UFO {
      constructor() {
        this.x = random(width * 0.2, width * 0.8);
        this.y = random(height * 0.2, height * 0.8);
        this.size = random(60, 100) * SCALE_FACTOR; // Increased size range for UFOs
        this.currentVisualScale = 0.01; // Start very small for warp-in effect
        this.warpInStartTime = Date.now();
        this.warpInDuration = 1000 * SCALE_FACTOR / gameSpeedMultiplier; // 1 second warp-in duration, scaled

        this.initialHealth = 1000 * SCALE_FACTOR; // Increased UFO health
        this.health = 1000 * SCALE_FACTOR; // UFOs start with full health
        // Convert velocities to per-millisecond for delta time scaling
        this.vx = random(-1.5, 1.5) / TARGET_FRAME_DURATION; // Increased speed
        this.vy = random(-1.5, 1.5) / TARGET_FRAME_DURATION; // Increased speed
        this.rotation = random(0, 360);
        // Convert rotational velocity to per-millisecond for delta time scaling
        this.vRotation = random(-0.2, 0.2) / TARGET_FRAME_DURATION;
        this.isDestroyed = false; // New flag: true when destruction animation starts

        // New: Properties for Z-axis (scaling) oscillation
        this.scaleOscillationSpeed = random(0.0005, 0.0015); // How fast it scales (radians per ms)
        this.scaleMin = 0.7; // Minimum scale factor
        this.scaleMax = 1.3; // Maximum scale factor
        this.scaleOffset = random(0, Math.PI * 2); // Random phase offset for desynchronized scaling
        this.elapsedGameTime = 0; // New: Track game-time elapsed for oscillation

        this.element = createSVGElement('g');
        this.element.setAttribute('class', 'ufo');
        // No initial opacity transition on the main group for the break-apart effect
        gameplayLayer.appendChild(this.element); // Append to gameplay layer

        this.parts = []; // To store references to individual SVG elements
        this.healthBarGroup = createSVGElement('g'); // New: Group for health bar
        gameplayLayer.appendChild(this.healthBarGroup); // Append health bar group directly to gameplay layer

        this.messageGroup = null; // New: Group for UFO message (rect + text)
        this.gradientIds = []; // Track gradient defs created for this UFO

        this.drawUFO(); // Initial drawing - populates this.parts and message elements
        this.drawHealthBar(); // Draw health bar (appends health bar elements to healthBarGroup)

        // Append messageGroup to healthBarGroup so it moves and positions relative to the health bar
        this.healthBarGroup.appendChild(this.messageGroup);

        // Play UFO warp-in sound (reversed howl)
        playSpatialSound(ufoWarpInSoundBuffer, this.x, 1.0, 1.0);
      }

      /**
       * Generates points for a symmetrical polygon, typically for UFO parts.
       * The shape is generated for the right half (positive X) and then mirrored to the left (negative X).
       * @param {number} numSegments - Number of segments for one half of the shape (e.g., 3 segments means 4 points).
       * @param {number} irregularity - How much points deviate from a smooth curve (0-1).
       * @param {number} baseWidth - The approximate maximum width of the shape.
       * @param {number} baseHeight - The approximate maximum height of the shape.
       * @param {number} [offsetX=0] - Horizontal offset from the UFO's center.
       * @param {number} [offsetY=0] - Vertical offset from the UFO's center.
       * @param {number} [rotationDegrees=0] - Rotation of the entire shape around its own center.
       * @returns {string} SVG points string.
       */
      generateSymmetricalShapePoints(numSegments, irregularity, baseWidth, baseHeight, offsetX = 0, offsetY = 0, rotationDegrees = 0) {
        let rightHalfPoints = [];
        // Generate points for the right half, from top to bottom
        for (let i = 0; i <= numSegments; i++) {
          const progress = i / numSegments; // Progress from 0 to 1 along the height
          
          // Use a sine wave for width variation to create a "waist" or "bulge" effect
          // This makes the shape more organic and less boxy.
          const currentWidthFactor = Math.sin(progress * Math.PI); // 0 at top/bottom, 1 in middle
          const currentWidth = (baseWidth / 2) * (0.2 + 0.8 * currentWidthFactor); // Min width 20% of max, max 100%
          
          const x = currentWidth * (1 + random(-irregularity, irregularity));
          const y = (progress - 0.5) * baseHeight * (1 + random(-irregularity * 0.5, irregularity * 0.5)); // Y from -baseHeight/2 to +baseHeight/2

          rightHalfPoints.push({ x: x, y: y });
        }

        let allPoints = [];
        // Add points for the right side (top to bottom)
        for (let i = 0; i < rightHalfPoints.length; i++) {
          allPoints.push(rightHalfPoints[i]);
        }
        // Add points for the left side (bottom to top, mirrored X)
        for (let i = rightHalfPoints.length - 1; i >= 0; i--) {
          allPoints.push({ x: -rightHalfPoints[i].x, y: rightHalfPoints[i].y });
        }

        // Apply rotation and offset to all points
        const radRotation = rotationDegrees * Math.PI / 180;
        const transformedPoints = allPoints.map(p => {
          const rotatedX = p.x * Math.cos(radRotation) - p.y * Math.sin(radRotation);
          const rotatedY = p.x * Math.sin(radRotation) + p.y * Math.cos(radRotation);
          return `${rotatedX + offsetX},${rotatedY + offsetY}`;
        });

        return transformedPoints.join(' ');
      }

      /**
       * Draws the UFO's SVG elements with procedural variations while ensuring symmetry.
       */
      drawUFO() {
        // Clear existing parts (excluding crackGroup and health bars)
        const children = Array.from(this.element.children);
        children.forEach(child => {
            if (child !== this.crackGroup && child !== this.healthBarBg && child !== this.healthBarFg) {
                this.element.removeChild(child);
            }
        });
        this.parts = []; // Reset parts array

        // --- Main Body ---
        const mainBodyWidth = this.size * random(1.5, 2.5) * SCALE_FACTOR; // Wider main body
        const mainBodyHeight = this.size * random(0.4, 0.8) * SCALE_FACTOR; // Made flatter (reduced height range)
        const mainBodySegments = Math.floor(random(4, 8)); // More segments for main body
        const mainBodyIrregularity = random(0.1, 0.3);

        const mainBodyPoints = this.generateSymmetricalShapePoints(
            mainBodySegments, mainBodyIrregularity, mainBodyWidth, mainBodyHeight
        );
        const mainBody = createSVGElement('polygon');
        mainBody.setAttribute('points', mainBodyPoints);
        {
          const gid = generateRandomUfoGradient();
          this.gradientIds.push(gid);
          mainBody.setAttribute('fill', `url(#${gid})`);
        }
        this.element.appendChild(mainBody);
        this.parts.push(mainBody);

        // --- Cockpit / Top Dome ---
        const cockpitWidth = mainBodyWidth * random(0.3, 0.6) * SCALE_FACTOR;
        const cockpitHeight = mainBodyHeight * random(0.2, 0.4) * SCALE_FACTOR;
        const cockpitSegments = Math.floor(random(3, 5));
        const cockpitIrregularity = random(0.05, 0.15);
        const cockpitOffsetY = -mainBodyHeight * random(0.2, 0.4) * SCALE_FACTOR; // Position above center

        const cockpitPoints = this.generateSymmetricalShapePoints(
            cockpitSegments, cockpitIrregularity, cockpitWidth, cockpitHeight, 0, cockpitOffsetY
        );
        const cockpit = createSVGElement('polygon');
        cockpit.setAttribute('points', cockpitPoints);
        {
          const gid = generateRandomUfoGradient();
          this.gradientIds.push(gid);
          cockpit.setAttribute('fill', `url(#${gid})`);
        }
        this.element.appendChild(cockpit);
        this.parts.push(cockpit);

        // --- Side Wings / Appendages ---
        const numWingPairs = Math.floor(random(1, 3)); // 1 to 2 pairs of wings
        for (let i = 0; i < numWingPairs; i++) {
            const wingWidth = mainBodyWidth * random(0.4, 0.7) * SCALE_FACTOR;
            const wingHeight = mainBodyHeight * random(0.1, 0.3) * SCALE_FACTOR;
            const wingSegments = Math.floor(random(2, 4));
            const wingIrregularity = random(0.1, 0.25);
            const wingOffsetX = mainBodyWidth * random(0.4, 0.6) * SCALE_FACTOR; // Position further out
            const wingOffsetY = mainBodyHeight * random(-0.2, 0.2) * SCALE_FACTOR; // Vertical position relative to main body

            // Right Wing
            const rightWingPoints = this.generateSymmetricalShapePoints(
                wingSegments, wingIrregularity, wingWidth, wingHeight, wingOffsetX, wingOffsetY, random(-15, 15) // Slight rotation
            );
            const rightWing = createSVGElement('polygon');
            rightWing.setAttribute('points', rightWingPoints);
            {
              const gid = generateRandomUfoGradient();
              this.gradientIds.push(gid);
              rightWing.setAttribute('fill', `url(#${gid})`);
            }
            this.element.appendChild(rightWing);
            this.parts.push(rightWing);

            // Left Wing (mirrored)
            const leftWingPoints = this.generateSymmetricalShapePoints(
                wingSegments, wingIrregularity, wingWidth, wingHeight, -wingOffsetX, wingOffsetY, random(-15, 15) // Slight rotation
            );
            const leftWing = createSVGElement('polygon');
            leftWing.setAttribute('points', leftWingPoints);
            {
              const gid = generateRandomUfoGradient();
              this.gradientIds.push(gid);
              leftWing.setAttribute('fill', `url(#${gid})`);
            }
            this.element.appendChild(leftWing);
            this.parts.push(leftWing);
        }

        // --- Rear Thrusters ---
        const numThrusters = Math.floor(random(2, 4)); // 2 to 3 thrusters
        const thrusterSpacing = mainBodyWidth * 0.15 * SCALE_FACTOR;
        const thrusterBaseY = mainBodyHeight * random(0.4, 0.6) * SCALE_FACTOR; // Position at the rear

        for (let i = 0; i < numThrusters; i++) {
            const thrusterWidth = this.size * random(0.1, 0.2) * SCALE_FACTOR;
            const thrusterHeight = this.size * random(0.2, 0.4) * SCALE_FACTOR;
            const thrusterSegments = Math.floor(random(2, 3));
            const thrusterIrregularity = random(0.05, 0.1);

            const thrusterOffsetX = (i - (numThrusters - 1) / 2) * thrusterSpacing; // Center thrusters
            
            const thrusterPoints = this.generateSymmetricalShapePoints(
                thrusterSegments, thrusterIrregularity, thrusterWidth, thrusterHeight, thrusterOffsetX, thrusterBaseY, 180 // Point downwards
            );
            const thruster = createSVGElement('polygon');
            thruster.setAttribute('points', thrusterPoints);
            {
              const gid = generateRandomUfoGradient();
              this.gradientIds.push(gid);
              thruster.setAttribute('fill', `url(#${gid})`);
            }
            this.element.appendChild(thruster);
            this.parts.push(thruster);
        }

        // --- Symmetrical "Eyes" / "Sensors" (Glowing circles) ---
        const numEyePairs = Math.floor(random(1, 2)); // 1 pair of eyes
        const eyeRadius = this.size * random(0.05, 0.1) * SCALE_FACTOR;
        const eyeAttachY = -mainBodyHeight * random(0.3, 0.5) * SCALE_FACTOR; // Attach near the top of the main body
        const eyeAttachXOffset = mainBodyWidth * random(0.15, 0.25) * SCALE_FACTOR; // Offset from center

        for (let i = 0; i < numEyePairs; i++) {
            const currentEyeAttachX = eyeAttachXOffset * random(0.9, 1.1);
            const currentEyeRadius = eyeRadius * random(0.8, 1.2);

            // Right Eye
            const eyeRight = createSVGElement('circle');
            eyeRight.setAttribute('cx', currentEyeAttachX);
            eyeRight.setAttribute('cy', eyeAttachY);
            eyeRight.setAttribute('r', currentEyeRadius);
            eyeRight.setAttribute('fill', `hsl(${random(180, 240)}, 100%, ${random(60, 90)}%)`); // Blueish glow
            this.element.appendChild(eyeRight);
            this.parts.push(eyeRight);

            // Left Eye (mirrored)
            const eyeLeft = createSVGElement('circle');
            eyeLeft.setAttribute('cx', -currentEyeAttachX);
            eyeLeft.setAttribute('cy', eyeAttachY);
            eyeLeft.setAttribute('r', currentEyeRadius);
            eyeLeft.setAttribute('fill', `hsl(${random(180, 240)}, 100%, ${random(60, 90)}%)`);
            this.element.appendChild(eyeLeft);
            this.parts.push(eyeLeft);
        }

        // --- UFO Message (SVG rect + text) ---
        this.messageGroup = createSVGElement('g');
        this.messageGroup.style.display = 'none'; // Hidden by default

        this.messageBg = createSVGElement('rect');
        this.messageBg.setAttribute('rx', 5); // Rounded corners
        this.messageBg.setAttribute('ry', 5);
        this.messageGroup.appendChild(this.messageBg);

        this.messageText = createSVGElement('text');
        this.messageText.setAttribute('text-anchor', 'middle'); // Center text horizontally
        this.messageText.setAttribute('dominant-baseline', 'hanging'); // Align text to top for easier background sizing
        this.messageText.setAttribute('font-family', 'Space Mono, monospace'); // Techy font
        this.messageText.setAttribute('font-size', `${1.2 * SCALE_FACTOR}em`); // Relative font size
        this.messageText.setAttribute('fill', '#aaffaa'); // Default text color
        this.messageGroup.appendChild(this.messageText);
      }


      /**
       * Draws the UFO's health bar.
       */
      drawHealthBar() {
          // Health bar background
          this.healthBarBg = createSVGElement('rect');
          this.healthBarBg.setAttribute('x', -this.size * 0.7 * SCALE_FACTOR); // Relative to UFO center
          this.healthBarBg.setAttribute('y', this.size + 10 * SCALE_FACTOR); // Below UFO
          this.healthBarBg.setAttribute('width', this.size * 1.4 * SCALE_FACTOR);
          this.healthBarBg.setAttribute('height', 8 * SCALE_FACTOR);
          this.healthBarBg.setAttribute('fill', '#333');
          this.healthBarBg.setAttribute('rx', 3 * SCALE_FACTOR);
          this.healthBarBg.setAttribute('ry', 3 * SCALE_FACTOR);
          this.healthBarGroup.appendChild(this.healthBarBg); // Append to healthBarGroup

          // Health bar foreground
          this.healthBarFg = createSVGElement('rect');
          this.healthBarFg.setAttribute('x', -this.size * 0.7 * SCALE_FACTOR);
          this.healthBarFg.setAttribute('y', this.size + 10 * SCALE_FACTOR);
          this.healthBarFg.setAttribute('height', 8 * SCALE_FACTOR);
          this.healthBarFg.setAttribute('rx', 3 * SCALE_FACTOR);
          this.healthBarFg.setAttribute('ry', 3 * SCALE_FACTOR);
          this.healthBarGroup.appendChild(this.healthBarFg); // Append to healthBarGroup

          this.updateHealthBar(); // Initial update
      }

      /**
       * Updates the visual representation of the health bar.
       */
      updateHealthBar() {
          if (!this.healthBarFg) return;
          const totalBarWidth = this.size * 1.4 * SCALE_FACTOR;
          const healthWidth = (this.health / this.initialHealth) * totalBarWidth;
          this.healthBarFg.setAttribute('width', Math.max(0, healthWidth)); // Ensure width doesn't go negative

          // Color change based on health
          let healthColor;
          if (this.health > 70) {
              healthColor = '#00FF00'; // Green
          } else if (this.health > 30) {
              healthColor = '#FFFF00'; // Yellow
          } else {
              healthColor = '#FF0000'; // Red
          }
          this.healthBarFg.setAttribute('fill', healthColor);
      }


      update(deltaTime) {
        const now = Date.now();

        // Handle warp-in scaling
        if (now < this.warpInStartTime + this.warpInDuration) {
          const progress = (now - this.warpInStartTime) / this.warpInDuration;
          // Cubic ease-out for smoother acceleration at the beginning and deceleration at the end
          const easedProgress = 1 - Math.pow(1 - progress, 3);
          this.currentVisualScale = 0.01 + (1 - 0.01) * easedProgress;
        } else {
          this.currentVisualScale = 1; // Ensure it's at full scale after warp-in
        }

        this.x += this.vx * deltaTime; // Scaled by delta time
        this.y += this.vy * deltaTime; // Scaled by delta time
        this.rotation += this.vRotation * deltaTime; // Scaled by delta time

        this.elapsedGameTime += deltaTime; // Increment elapsed game time
        // Calculate Z-axis (scaling) oscillation using elapsedGameTime
        const scaleProgress = (Math.sin(this.elapsedGameTime * this.scaleOscillationSpeed + this.scaleOffset) + 1) / 2; // 0 to 1
        const zScale = this.scaleMin + (this.scaleMax - this.scaleMin) * scaleProgress;

        // Combine warp-in scale with Z-axis oscillation scale
        const combinedScale = this.currentVisualScale * zScale;

        // Update health bar position (independent of UFO rotation)
        this.healthBarGroup.setAttribute('transform', `translate(${this.x}, ${this.y})`);

        // Wrap around - use the actual rendered size for boundary checks
        // The effective size for boundary checks should consider the current Z-scale
        const actualRenderedSize = this.size * combinedScale;
        if (this.x < -actualRenderedSize * 2) this.x = width + actualRenderedSize * 2;
        if (this.x > width + actualRenderedSize * 2) this.x = -actualRenderedSize * 2;
        if (this.y < -actualRenderedSize * 2) this.y = height + actualRenderedSize * 2;
        if (this.y > height + actualRenderedSize * 2) this.y = -actualRenderedSize * 2;

        // Apply translation, rotation, and combined scale
        this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${this.rotation}) scale(${combinedScale})`);
      }

      /**
       * Applies damage to the UFO.
       * @param {number} damage - Amount of damage to apply.
       * @param {number} laserAngle - Angle of the incoming laser for deflection.
       */
      takeDamage(damage, laserAngle, impactX, impactY) { // Added impactX, impactY
        if (this.isDestroyed) {
            return; // Do not apply damage or effects if already destroyed
        }
        this.health -= damage;

        this.updateHealthBar(); // Update health bar on damage

        // Calculate health ratio to determine resistance
        const healthRatio = Math.max(0, this.health / this.initialHealth); // Clamp to 0 to prevent negative health issues
        // deflectionMultiplier is 0 when health is full, and 1 when health is zero.
        const deflectionMultiplier = 1 - healthRatio;

        // Apply deflection based on laser angle, scaled by health
        const baseDeflectionForce = 0.2 / TARGET_FRAME_DURATION; // Increased base deflection force
        const actualDeflectionForce = baseDeflectionForce * deflectionMultiplier;

        this.vx += Math.cos(laserAngle) * actualDeflectionForce;
        this.vy += Math.sin(laserAngle) * actualDeflectionForce;

        // Apply rotational deflection, scaled by health
        const baseVRotationMagnitude = 0.5 / TARGET_FRAME_DURATION; // Max random rotation magnitude
        const actualVRotation = random(-baseVRotationMagnitude, baseVRotationMagnitude) * deflectionMultiplier;
        this.vRotation += actualVRotation;

        if (this.health <= 0) {
          this.destroy();
        }
      }

      destroy() {
        if (this.isDestroyed) {
            return; // Already destroyed, prevent re-triggering
        }
        this.isDestroyed = true; // Mark as destroyed immediately
        // Calculate pitch based on UFO size: larger UFOs get lower pitch
        const minOverallSize = MIN_ASTEROID_SIZE; // Use asteroid min size as a reference for the smallest possible object
        const maxOverallSize = MAX_ASTEROID_SIZE; // Use asteroid max size as a reference for the largest possible object
        const minTargetPitch = 0.05; // Pitch for largest objects (very bassy)
        const maxTargetPitch = 0.5; // Pitch for smallest objects (even deeper)

        const normalizedSize = (this.size - minOverallSize) / (maxOverallSize - minOverallSize);
        const clampedNormalizedSize = Math.max(0, Math.min(1, normalizedSize)); // Ensure value is between 0 and 1
        const basePitch = maxTargetPitch - (clampedNormalizedSize * (maxTargetPitch - minTargetPitch));
        const finalPitch = basePitch * random(0.9, 1.1); // Add +/- 10% random variation

        // Create a fireball effect for the UFO explosion BEFORE parts are detached/removed
        // This ensures the fireball appears on top of the UFO as it's being destroyed.
        let fireball = fireballPool.pop();
        if (!fireball) {
            fireball = new FireballEffect();
        }
        const ufoExplosionFireballFinalSize = this.size * 4.0 * SCALE_FACTOR; // Increased radius for UFO fireball to expand further
        fireball.reset(this.x, this.y, ufoExplosionFireballFinalSize * FIREBALL_INITIAL_SIZE_FACTOR, ufoExplosionFireballFinalSize, 'visual');
        // Override the fill for the UFO explosion fireball to use the brighter gradient
        fireball.element.setAttribute('fill', 'url(#ufoExplosionFireballGradient)');
        activeFireballs.push(fireball);

        playSpatialSound(ufoExplosionHowlBuffer, this.x, 1.5, finalPitch); // Play UFO howl explosion sound, louder
        playSpatialSound(explosionBuffer, this.x, 0.5, 0.1); // Overlay a deep explosion sound, quieter
        createExplosion(this.x, this.y, this.size * 1.8, 'explosion'); // Larger initial explosion
        createExplosion(this.x + random(-this.size*0.2, this.size*0.2), this.y + random(-this.size*0.2, this.size*0.2), this.size * 1.0, 'explosion'); // Second, slightly offset explosion
        createExplosion(this.x, this.y, this.size * 1.5, 'spark'); // Add sparks to the UFO explosion

        // Remove this UFO instance from the global ufos array
        const index = ufos.indexOf(this);
        if (index > -1) {
            ufos.splice(index, 1);
        }

        // If this UFO had a message group, remove it and its filter
        if (this.messageGroup && this.messageGroup.parentNode) {
            this.messageGroup.parentNode.removeChild(this.messageGroup);
            // Also remove the associated filter from defs to prevent leaks
            const filterId = `ufoMessageShadow-${this.id}`;
            const filterElement = document.getElementById(filterId);
            if (filterElement && filterElement.parentNode) {
                filterElement.parentNode.removeChild(filterElement);
            }
        }

        // Cleanup any gradients created for this UFO to prevent defs bloating
        if (this.gradientIds && this.gradientIds.length) {
            this.gradientIds.forEach(gid => {
                const grad = document.getElementById(gid);
                if (grad && grad.parentNode) {
                    grad.parentNode.removeChild(grad);
                }
            });
            this.gradientIds = [];
        }

        // Remove health bar group from DOM
        if (this.healthBarGroup && this.healthBarGroup.parentNode) {
            this.healthBarGroup.parentNode.removeChild(this.healthBarGroup);
        }


        // Conditional part animation for quality levels
        if (currentQualityLevel === 'low') {
            // For low quality, just fade out the main element
            if (this.element.parentNode) {
                const animationDuration = 250 / gameSpeedMultiplier; // ms, scaled by game speed - Reduced for quicker fade
                this.element.style.transition = `opacity ${animationDuration/1000}s ease-out`;
                this.element.style.opacity = 0; // Trigger fade out

                setTimeout(() => {
                    if (this.element.parentNode) {
                        gameplayLayer.removeChild(this.element); // Remove from gameplay layer after fade
                    }
                }, animationDuration);
            }
        } else {
            // Detach and animate individual parts for medium/high quality
            const ufoAbsoluteX = this.x;
            const ufoAbsoluteY = this.y;
            const ufoCurrentRotation = this.rotation;
            const ufoCurrentScale = this.currentVisualScale;

            this.parts.forEach(part => {
                const bbox = part.getBBox();
                let initialPartX = bbox.x + bbox.width / 2;
                let initialPartY = bbox.y + bbox.height / 2;

                if (part.parentNode === this.element) {
                    this.element.removeChild(part);
                }
                gameplayLayer.appendChild(part); // Now it's a direct child of the gameplay layer

                const rotatedScaledX = initialPartX * Math.cos(ufoCurrentRotation * Math.PI / 180) * ufoCurrentScale - initialPartY * Math.sin(ufoCurrentRotation * Math.PI / 180) * ufoCurrentScale;
                const rotatedScaledY = initialPartX * Math.sin(ufoCurrentRotation * Math.PI / 180) * ufoCurrentScale + initialPartY * Math.cos(ufoCurrentRotation * Math.PI / 180) * ufoCurrentScale;

                // Calculate the part's absolute position at the moment of destruction
                // This is the UFO's absolute position + the part's rotated and scaled local offset
                let currentPartAbsoluteX = ufoAbsoluteX + rotatedScaledX;
                let currentPartAbsoluteY = ufoAbsoluteY + rotatedScaledY;
                let currentPartRotation = ufoCurrentRotation; // Initial rotation of the detached part

                // Calculate the part's local center relative to the UFO's local origin (0,0)
                const partLocalCenterX = bbox.x + bbox.width / 2;
                const partLocalCenterY = bbox.y + bbox.height / 2;

                // Calculate the direction vector from UFO's local center (0,0) to part's local center
                const directionX = partLocalCenterX;
                const directionY = partLocalCenterY;
                const magnitude = Math.hypot(directionX, directionY);

                let outwardVx = 0;
                let outwardVy = 0;
                const outwardKickForce = random(0.01, 0.05) / TARGET_FRAME_DURATION; // Significantly reduced force for minimal separation

                if (magnitude > 0) { // Avoid division by zero if part is exactly at (0,0)
                    outwardVx = (directionX / magnitude) * outwardKickForce;
                    outwardVy = (directionY / magnitude) * outwardKickForce;
                }

                // Combine UFO's current velocity, a very small random component, and the outward kick
                const randomAngle = Math.random() * 2 * Math.PI;
                const randomSpeed = random(0.01, 0.05); // Very small random component for slight variety
                const combinedVx = this.vx + randomSpeed * Math.cos(randomAngle) + outwardVx;
                const combinedVy = this.vy + randomSpeed * Math.sin(randomAngle) + outwardVy;
                
                const rotationSpeed = this.vRotation + random(-0.1, 0.1); // Inherit UFO's rotation + very slight random spin

                const partFadeDuration = 2000 / gameSpeedMultiplier; // Increased duration for slower fade and fly apart

                explodingUfoParts.push(new UFOExplodingPart(
                    part,
                    currentPartAbsoluteX,
                    currentPartAbsoluteY,
                    currentPartRotation,
                    combinedVx, combinedVy, rotationSpeed,
                    partFadeDuration, partFadeDuration
                ));
            });

            // Fade out the main UFO group element after all parts have been detached
            if (this.element.parentNode) {
                const animationDuration = 500 / gameSpeedMultiplier; // ms, scaled by game speed - Reverted to original speed
                this.element.style.transition = `opacity ${animationDuration/1000}s ease-out`;
                this.element.style.opacity = 0; // Trigger fade out

                setTimeout(() => {
                    if (this.element.parentNode) {
                        gameplayLayer.removeChild(this.element); // Remove from gameplay layer after fade
                    }
                }, animationDuration);
            }
        }
      }

      /**
       * Displays a random hardcoded message from the UFO.
       */
      displayMessage = (callback) => { // Changed to arrow function for consistent 'this' binding, added callback
        const settings = qualitySettings[currentQualityLevel];
        // Construct a 2-3 word message from the ufoWords list
        let message = "";
        const numWords = Math.floor(random(2, 4)); // 2 or 3 words
        for (let i = 0; i < numWords; i++) {
          const word = ufoWords[Math.floor(random(0, ufoWords.length))];
          message += (i > 0 ? " " : "") + word;
        }

        this.messageText.textContent = `"${message}"`; // Add double quotes around the message
        
        // Position the message group below the health bar
        const messageYOffset = this.size + 10 * SCALE_FACTOR + 8 * SCALE_FACTOR + 10 * SCALE_FACTOR; // UFO size + health bar offset + health bar height + padding
        this.messageGroup.setAttribute('transform', `translate(0, ${messageYOffset})`);

        // Get text bounding box to size the background rectangle
        // Must be visible to get accurate bbox
        this.messageGroup.style.display = ''; 
        const bbox = this.messageText.getBBox();
        const padding = 5 * SCALE_FACTOR; // Reduced padding for a smaller border
        const bgWidth = bbox.width + padding * 2;
        const bgHeight = bbox.height + padding * 2;
        const bgX = bbox.x - padding;
        const bgY = bbox.y - padding;

        this.messageBg.setAttribute('x', bgX);
        this.messageBg.setAttribute('y', bgY);
        this.messageBg.setAttribute('width', bgWidth);
        this.messageBg.setAttribute('height', bgHeight);

        // Center the text within its background
        this.messageText.setAttribute('x', bbox.x + bbox.width / 2); // Center X of text relative to its own bbox
        this.messageText.setAttribute('y', bbox.y + bbox.height / 2); // Center Y of text relative to its own bbox
        this.messageText.setAttribute('dominant-baseline', 'middle'); // Re-align to middle for centering

        // Apply styling based on quality settings
        if (settings.ufoMessageTransparency) {
            this.messageBg.setAttribute('fill', '#141428');
            this.messageBg.setAttribute('fill-opacity', '0.9');
            this.messageText.setAttribute('fill', '#aaffaa');
            this.messageBg.setAttribute('stroke', '#66bb66');
            this.messageBg.setAttribute('stroke-width', 1);
        } else {
            this.messageBg.setAttribute('fill', 'rgb(20, 20, 40)'); // Solid dark background
            this.messageText.setAttribute('fill', 'rgb(170, 255, 170)'); // Solid green text
            this.messageBg.setAttribute('stroke', 'rgb(102, 187, 102)'); // Solid green border
            this.messageBg.setAttribute('stroke-width', 1);
        }

        if (settings.ufoMessageShadow) {
            // SVG filters for shadow
            const filterId = `ufoMessageShadow-${this.id}`; // Unique filter ID per UFO
            let filter = document.getElementById(filterId);
            if (!filter) {
                filter = createSVGElement('filter');
                filter.setAttribute('id', filterId);
                filter.setAttribute('x', '-50%');
                filter.setAttribute('y', '-50%');
                filter.setAttribute('width', '200%');
                filter.setAttribute('height', '200%');
                const feDropShadow = createSVGElement('feDropShadow');
                feDropShadow.setAttribute('dx', '0');
                feDropShadow.setAttribute('dy', '0');
                feDropShadow.setAttribute('stdDeviation', '5'); // Blur radius
                feDropShadow.setAttribute('flood-color', '#64C864'); // Shadow color
                feDropShadow.setAttribute('flood-opacity', '0.5');
                filter.appendChild(feDropShadow);
                canvas.querySelector('defs').appendChild(filter);
            }
            this.messageBg.setAttribute('filter', `url(#${filterId})`);
        } else {
            this.messageBg.removeAttribute('filter');
        }

        this.messageGroup.style.transition = `opacity ${settings.ufoMessageTransition}`;
        this.messageGroup.style.opacity = 1; // Show message
        // Speak message via Web Speech API (optional), fallback to robotic synth
        if (!(isMuted || isPaused) && ttsEnabled && ('speechSynthesis' in window)) {
            const ok = speakUfoTextWithTTS(message);
            if (!ok) {
                speakRoboticText(message, 50 / gameSpeedMultiplier);
            }
        } else {
            speakRoboticText(message, 50 / gameSpeedMultiplier);
        }

        setTimeout(() => {
          this.messageGroup.style.opacity = 0; // Fade out after 0.5 seconds
          setTimeout(() => {
              this.messageGroup.style.display = 'none'; // Hide after fade
              if (callback) callback(); // Signal completion
          }, parseFloat(settings.ufoMessageTransition) * 1000 / gameSpeedMultiplier); // Wait for transition to complete, scaled
        }, 500 / gameSpeedMultiplier); // Reduced from 1000ms to 500ms, scaled
      }
    }

    /**
     * Represents an individual particle for explosions/sparks.
     */
    class Particle {
        constructor(element, x, y, vx, vy, life, initialLife) {
            this.element = element;
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.lifeRemaining = life;
            this.initialLife = initialLife;
            this.element.style.display = ''; // Make visible
            this.element.style.opacity = 1; // Start full opacity
            this.element.style.pointerEvents = 'none'; // Ensure clicks pass through
        }

        update(scaledDeltaTime) { // Changed parameter name for clarity
            this.x += this.vx * scaledDeltaTime;
            this.y += this.vy * scaledDeltaTime;
            this.element.setAttribute('cx', this.x);
            this.element.setAttribute('cy', this.y);
            this.lifeRemaining -= scaledDeltaTime; // Scaled
            this.element.style.opacity = this.lifeRemaining / this.initialLife;
            return this.lifeRemaining <= 0; // True if dead
        }

        remove() {
            this.element.style.display = 'none';
            this.element.setAttribute('cx', -9999); // Move off-screen
            this.element.setAttribute('cy', -9999); // Move off-screen
            this.element.removeAttribute('filter'); // Explicitly remove filter
            
            // Explicitly remove from DOM when returning to pool
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            particlePool.push(this.element); // Return the SVG element to the pool
        }
    }

    /**
     * Represents a detached UFO part during destruction.
     */
    class UFOExplodingPart {
        constructor(element, x, y, rotation, vx, vy, vRotation, life, initialLife) {
            this.element = element;
            this.x = x;
            this.y = y;
            this.rotation = rotation; // Initial rotation
            this.vx = vx;
            this.vy = vy;
            this.vRotation = vRotation; // Rotational velocity
            this.lifeRemaining = life;
            this.initialLife = initialLife;
            this.element.style.opacity = 1; // Start full opacity
        }

        update(scaledDeltaTime) { // Changed parameter name for clarity
            this.x += this.vx * scaledDeltaTime;
            this.y += this.vy * scaledDeltaTime;
            this.rotation += this.vRotation * scaledDeltaTime; // Re-added: pieces should rotate around their own axis, scaled
            this.lifeRemaining -= scaledDeltaTime; // Scaled
            this.element.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${this.rotation})`); // Apply current rotation
            this.element.style.opacity = this.lifeRemaining / this.initialLife;
            return this.lifeRemaining <= 0; // True if dead
        }

        remove() {
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
        }
    }

    function enforceParticleBudget(reserveSlots = 0) {
      const desiredReserve = Math.max(0, Math.ceil(reserveSlots));
      const allowedCount = Math.max(0, MAX_ACTIVE_PARTICLES - desiredReserve);
      if (activeParticles.length <= allowedCount) {
        return;
      }
      const overflow = activeParticles.length - allowedCount;
      const buffer = Math.ceil(MAX_ACTIVE_PARTICLES * PARTICLE_OVERFLOW_HEADROOM_RATIO);
      const removeCount = Math.min(activeParticles.length, overflow + buffer);
      if (removeCount <= 0) {
        return;
      }
      for (let i = 0; i < removeCount; i++) {
        const particle = activeParticles[i];
        if (particle) {
          particle.remove();
        }
      }
      activeParticles.splice(0, removeCount);
    }

    /**
     * Creates explosion or spark particles for visual effect.
     * @param {number} x - X coordinate of explosion/sparks.
     * @param {number} y - Y coordinate of explosion/sparks.
     * @param {number} baseSize - Base size for particles.
     * @param {string} type - Type of particles ('explosion' or 'spark').
     * @param {number} [parentVx=0] - Inherited velocity X from the parent object.
     * @param {number} [parentVy=0] - Inherited velocity Y from the parent object.
     * @param {number} [incomingAngle=null] - The angle of the incoming shot (for sparks).
     */
    function createExplosion(x, y, baseSize, type = 'explosion', parentVx = 0, parentVy = 0, incomingAngle = null) {
      const settings = qualitySettings[currentQualityLevel];
      let numParticles;
      let particleSizeMin, particleSizeMax;
      let particleSpeedMin, particleSpeedMax;
      let particleLife; // This will now be in milliseconds

      if (type === 'explosion') {
        numParticles = settings.asteroidNumParticles;
        particleSizeMin = baseSize * 0.05 * SCALE_FACTOR; // Reduced min size
        particleSizeMax = baseSize * 0.1 * SCALE_FACTOR; // Reduced max size
        particleSpeedMin = 1.5 / TARGET_FRAME_DURATION; // Retained speed
        particleSpeedMax = 8 / TARGET_FRAME_DURATION; // Doubled max speed for explosion debris to travel further
        particleLife = 140 * TARGET_FRAME_DURATION; // Doubled again for 2x slower fade
      } else if (type === 'spark') {
        numParticles = settings.sparkNumParticles;
        particleSizeMin = baseSize * 0.02 * SCALE_FACTOR; // Reduced min size
        particleSizeMax = baseSize * 0.07 * SCALE_FACTOR; // Reduced max size
        particleSpeedMin = 0.75 / TARGET_FRAME_DURATION; // Reduced speed
        particleSpeedMax = 2 / TARGET_FRAME_DURATION; // Reduced speed
        particleLife = 25 * TARGET_FRAME_DURATION; // Fixed game-time duration for spark fade
      } else if (type === 'nukeFireball') { // New: Nuke explosion particles
        numParticles = 30; // Further reduced number of particles for nuke explosion
        particleSizeMin = baseSize * 0.03 * SCALE_FACTOR; // Reduced min size
        particleSizeMax = baseSize * 0.07 * SCALE_FACTOR; // Reduced max size
        particleSpeedMin = 0.3 / TARGET_FRAME_DURATION; // Reduced outward drift
        particleSpeedMax = 2.4 / TARGET_FRAME_DURATION; // Doubled max speed for nuke haze particles to travel further
        particleLife = 70 * TARGET_FRAME_DURATION; // Fixed game-time duration for nuke haze fade
      }

      let spawnCount = numParticles;
      if (type === 'explosion') {
        const sizeScale = Math.max(0.5, Math.min(4, baseSize / (45 * SCALE_FACTOR)));
        spawnCount = Math.ceil(spawnCount * sizeScale * 0.8);
      } else if (type === 'spark') {
        spawnCount = Math.ceil(spawnCount * 0.8);
      } else if (type === 'nukeFireball') {
        spawnCount = Math.ceil(spawnCount * 1.2);
      }
      spawnCount = Math.max(1, spawnCount);

      enforceParticleBudget(spawnCount);

      const currentActiveParticles = activeParticles.length;
      const availableCapacity = Math.max(0, MAX_ACTIVE_PARTICLES - currentActiveParticles);
      if (availableCapacity <= 0) {
        return;
      }
      spawnCount = Math.min(spawnCount, availableCapacity);

      for (let i = 0; i < spawnCount; i++) {
        let particleElement = particlePool.pop();
        if (!particleElement) {
            particleElement = createSVGElement('circle');
        }
        // Append to effectsLayer here to ensure it's on top of other elements when activated
        effectsLayer.appendChild(particleElement);
        
        const size = random(particleSizeMin, particleSizeMax);
        particleElement.setAttribute('r', size / 2);
        particleElement.setAttribute('cx', x);
        particleElement.setAttribute('cy', y);

        if (type === 'spark') {
            const hue = random(0, 60);
            const saturation = random(80, 100);
            const lightness = random(40, 70);
            particleElement.setAttribute('fill', `hsl(${hue}, ${saturation}%, ${lightness}%)`);
        } else if (type === 'nukeFireball') {
            // Orange to yellow gradient for nuke fireball
            const hue = random(30, 60); // Yellow to orange
            const saturation = random(80, 100);
            const lightness = random(50, 80);
            particleElement.setAttribute('fill', `hsl(${hue}, ${saturation}%, ${lightness}%)`);
        }
        else { // Default explosion
            particleElement.setAttribute('fill', `rgb(255, 165, 0)`);
        }
        
        let angle, speed;
        if (type === 'spark' && incomingAngle !== null) {
            // Sparks fly mostly towards the incoming angle
            angle = incomingAngle + random(-Math.PI / 8, Math.PI / 8); // Towards incoming direction with some spread
            speed = random(particleSpeedMin, particleSpeedMax);
        } else {
            // Random angle for other particle types
            angle = random(0, Math.PI * 2);
            speed = random(particleSpeedMin, particleSpeedMax);
        }

        const vx = Math.cos(angle) * speed + parentVx; // Add parent's velocity
        const vy = Math.sin(angle) * speed + parentVy; // Add parent's velocity

        // Add to global activeParticles array for centralized animation
        activeParticles.push(new Particle(particleElement, x, y, vx, vy, particleLife, particleLife));
      }
      enforceParticleBudget();
    }

  // --- Initialization Functions ---

    function clearChildren(node) {
      while (node && node.firstChild) node.removeChild(node.firstChild);
    }

    // Rebuild tiled clones so that stars cover the viewport during group translation
    function rebuildStarClones() {
      if (!starsLayer || !starsLayerLeft || !starsLayerUp || !starsLayerUpLeft) return;
      // Clear previous clones
      clearChildren(starsLayerLeft);
      clearChildren(starsLayerUp);
      clearChildren(starsLayerUpLeft);

      // Clone base stars into tile groups
      const baseChildren = Array.from(starsLayer.children);
      for (let i = 0; i < baseChildren.length; i++) {
        const base = baseChildren[i];
        const a = base.cloneNode(false);
        const b = base.cloneNode(false);
        const c = base.cloneNode(false);
        starsLayerLeft.appendChild(a);
        starsLayerUp.appendChild(b);
        starsLayerUpLeft.appendChild(c);
      }

      // Update clone transforms to current width/height
      starsLayerLeft.setAttribute('transform', `translate(${-width}, 0)`);
      starsLayerUp.setAttribute('transform', `translate(0, ${-height})`);
      starsLayerUpLeft.setAttribute('transform', `translate(${-width}, ${-height})`);
    }

    function initStars() {
      const settings = qualitySettings[currentQualityLevel];
      const targetStarCount = settings.starCount; // Star count is not scaled, but their size is handled in Star constructor

      // Adjust existing stars or add new ones
      while (stars.length < targetStarCount) {
        // Add new stars if needed
        const newStar = new Star(random(0, width), random(0, height), random(0.5, 2));
        stars.push(newStar);
      }

      while (stars.length > targetStarCount) {
        // Remove excess stars from DOM and array
        const starToRemove = stars.pop();
        starToRemove.remove(); // Remove element from DOM
      }

      // Update color for all existing stars based on current quality settings
      stars.forEach(star => star.updateColor());

      // Reset scroll offsets
      starfieldOffsetX = 0;
      starfieldOffsetY = 0;
      if (starsScrollGroup) {
        starsScrollGroup.setAttribute('transform', `translate(0, 0)`);
      }

      // Rebuild tiled clones so the starfield covers the viewport for any offset
      rebuildStarClones();

      // Initialize starfield direction
      setNewStarfieldTargetDirection(); // Sets targetVx/Vy and starfieldDirectionTransitionStartTime
      lastStarfieldDirectionChangeTime = Date.now(); // Set initial interval timer
    }

    /**
     * Sets a new random target direction for the starfield.
     */
    function setNewStarfieldTargetDirection() {
        const baseSpeed = random(0.1, 0.5) / TARGET_FRAME_DURATION; // Revert to original speed
        const angle = random(0, Math.PI * 2); // Random angle
        starfieldTargetVx = Math.cos(angle) * baseSpeed;
        starfieldTargetVy = Math.sin(angle) * baseSpeed;
        starfieldDirectionTransitionStartTime = Date.now(); // Reset start time for the *new* transition
    }

    /**
     * Manages the number of defenders on screen, adding or removing them as needed.
     */
    function manageDefenders() {
        while (defenders.length < numTargetDefenders) {
            // Add new defenders
            defenders.push(new Defender(random(width * 0.1, width * 0.9), random(height * 0.1, height * 0.9)));
        }
        while (defenders.length > numTargetDefenders) {
            // Remove excess defenders
            const defenderToRemove = defenders.pop();
            defenderToRemove.remove(); // Ensure its SVG element is removed from DOM
        }
    }

    function initDefenders() {
      // Initialize defenders based on the initial numTargetDefenders value
      manageDefenders();
    }

    function initAsteroids() {
      for (let i = 0; i < numInitialAsteroids; i++) {
        spawnOnscreenAsteroid(); // Initial asteroids can appear anywhere on screen
      }
    }

    /**
     * Spawns a new asteroid from off-screen and directs it towards the center.
     */
    function spawnOffscreenAsteroid() {
      const size = random(MIN_ASTEROID_SIZE, MAX_ASTEROID_SIZE);
      const speed = random(0.5, 1.0) / TARGET_FRAME_DURATION;
      
      let x, y;
      const edge = Math.floor(random(0, 4)); // 0: top, 1: right, 2: bottom, 3: left
      const offset = size * 1.5 * SCALE_FACTOR; // Spawn a bit further off-screen

      switch (edge) {
        case 0: // Top
          x = random(-offset, width + offset);
          y = -offset;
          break;
        case 1: // Right
          x = width + offset;
          y = random(-offset, height + offset);
          break;
        case 2: // Bottom
          x = random(-offset, width + offset);
          y = height + offset;
          break;
        case 3: // Left
          x = -offset;
          y = random(-offset, height + offset);
          break;
      }

      // Calculate velocity towards a random point within the screen
      const targetX = random(width * 0.2, width * 0.8);
      const targetY = random(height * 0.2, height * 0.8);
      
      let angle = Math.atan2(targetY - y, targetX - x);
      // Add some randomness to the angle to vary trajectories
      angle += random(-Math.PI / 6, Math.PI / 6); // +/- 30 degrees

      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;

      asteroids.push(new Asteroid(x, y, size, size, vx, vy));
    }

    /**
     * Spawns a new asteroid directly on-screen with random position and velocity.
     */
    function spawnOnscreenAsteroid() {
      const size = random(MIN_ASTEROID_SIZE, MAX_ASTEROID_SIZE);
      const speed = random(0.5, 1.0) / TARGET_FRAME_DURATION;
      // Random on-screen position
      const x = random(size * SCALE_FACTOR, width - size * SCALE_FACTOR);
      const y = random(size * SCALE_FACTOR, height - size * SCALE_FACTOR);
      // Random velocity in any direction
      const angle = random(0, Math.PI * 2);
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      asteroids.push(new Asteroid(x, y, size, size, vx, vy));
    }

    /**
     * Spawns a new group of UFOs (3 at a time).
     */
    function spawnUFO() {
      // Only spawn a new group if no UFOs are currently active
      if (ufos.length > 0) {
        return;
      }

      const numUFOsToSpawn = 1; // Changed to spawn only one UFO at a time
      // Only spawn a new UFO if there are no active UFOs
      if (ufos.length === 0) {
        const newUFO = new UFO();
        ufos.push(newUFO);
        
        // Delay adding the UFO to the message queue
        const delayBeforeSpeech = newUFO.warpInDuration + (2000 / gameSpeedMultiplier); // Warp-in duration + 2 seconds (scaled)
        setTimeout(() => {
            ufoMessageQueue.push(newUFO); // Add new UFO to the message queue after delay
            processUfoMessageQueue(); // Start processing the queue (will pick up this UFO)
        }, delayBeforeSpeech);
      }
    }

    // --- Game Loop ---

    function update(time) {
      // Calculate delta time for consistent movement regardless of frame rate
      const deltaTime = time - lastFrameTime;
      lastFrameTime = time;

      const settings = qualitySettings[currentQualityLevel]; // Define settings here for broader scope

      // Increment frame counter for FPS calculation
      frameCount++;

      // Update FPS every second
      if (time - lastFpsUpdateTime >= 1000) {
        fps = frameCount; // Number of frames in the last second
        frameCount = 0; // Reset frame count for the next second
        lastFpsUpdateTime = time; // Reset the time for the next FPS calculation period

        // Auto-quality management based on sustained FPS
        if (qualityMode === 'auto') {
          const nowMs = Date.now();
          if (fps < AUTO_LOW_THRESHOLD_FPS) {
            autoLowStreak++;
            autoHighStreak = 0;
            if (autoLowStreak >= AUTO_LOW_STREAK_SECONDS && (nowMs - autoLastAdjustTime) >= AUTO_ADJUST_MIN_INTERVAL_MS) {
              if (currentQualityLevel === 'high') {
                setQualityLevel('medium');
                autoLastAdjustTime = nowMs;
                autoLowStreak = 0;
              } else if (currentQualityLevel === 'medium') {
                setQualityLevel('low');
                autoLastAdjustTime = nowMs;
                autoLowStreak = 0;
              }
            }
          } else if (fps >= AUTO_HIGH_THRESHOLD_FPS) {
            autoHighStreak++;
            autoLowStreak = 0;
            if (autoHighStreak >= AUTO_HIGH_STREAK_SECONDS && (nowMs - autoLastAdjustTime) >= AUTO_ADJUST_MIN_INTERVAL_MS) {
              if (currentQualityLevel === 'low') {
                setQualityLevel('medium');
                autoLastAdjustTime = nowMs;
                autoHighStreak = 0;
              } else if (currentQualityLevel === 'medium') {
                setQualityLevel('high');
                autoLastAdjustTime = nowMs;
                autoHighStreak = 0;
              }
            }
          } else {
            autoLowStreak = 0;
            autoHighStreak = 0;
          }
        }
        // Update FPS display in the side menu
        if (fpsDisplayValueSpan) {
            fpsDisplayValueSpan.textContent = String(fps);
        }
      }

      const now = Date.now();
      const shouldMeasure = isPerfStatsVisible; // Only measure when stats are visible
      const frameStart = shouldMeasure ? performance.now() : 0; // Start measuring total frame time for this frame

      // If paused, only update FPS and stats, then request next frame and return
      if (isPaused) {
          requestAnimationFrame(update);
          return;
      }

      // Define effective game speed multiplier for the main loop
      let effectiveGameSpeedMultiplier = gameSpeedMultiplier;
      if (effectiveGameSpeedMultiplier === 0) {
          effectiveGameSpeedMultiplier = 0.001; // Prevent scaledDeltaTime from being zero, allow minimal progress
      }

      // Apply game speed multiplier to deltaTime
      const scaledDeltaTime = deltaTime * effectiveGameSpeedMultiplier; // Use effective multiplier

      // Check if it's time to set a new target direction for the starfield
      if (now - lastStarfieldDirectionChangeTime >= starfieldDirectionChangeInterval / effectiveGameSpeedMultiplier) { // Scale interval
          setNewStarfieldTargetDirection();
          lastStarfieldDirectionChangeTime = now; // Reset the interval timer
      }

      // Smoothly interpolate current starfield velocity towards target velocity
      const transitionProgress = Math.min(1, (now - starfieldDirectionTransitionStartTime) / (starfieldDirectionChangeDuration / effectiveGameSpeedMultiplier)); // Scale duration
      // Linear interpolation: current = start + (end - start) * progress
      starfieldVx = starfieldVx + (starfieldTargetVx - starfieldVx) * transitionProgress;
      starfieldVy = starfieldVy + (starfieldTargetVy - starfieldVy) * transitionProgress;

      // Update stars via group translation (significantly fewer DOM writes)
      let sectionStart; if (shouldMeasure) sectionStart = performance.now();
      starfieldOffsetX += starfieldVx * scaledDeltaTime;
      starfieldOffsetY += starfieldVy * scaledDeltaTime;

      // Keep offsets within a tile and translate the scroll group
      // Using modulo to avoid unbounded values and rely on tiling for coverage
      if (width > 0) {
        starfieldOffsetX = ((starfieldOffsetX % width) + width) % width;
      }
      if (height > 0) {
        starfieldOffsetY = ((starfieldOffsetY % height) + height) % height;
      }

      if (starsScrollGroup) {
        starsScrollGroup.setAttribute('transform', `translate(${starfieldOffsetX}, ${starfieldOffsetY})`);
      }
      if (shouldMeasure) accumulatedPerformanceData.stars += (performance.now() - sectionStart);

      // Update date/time display position ONLY if it's visible
      if (isDateTimeVisible) {
          // Update orbit center drift direction periodically
          if (now - lastDateTimeOrbitCenterDirectionChangeTime > dateTimeOrbitCenterDirectionChangeInterval / gameSpeedMultiplier) { // Scale interval
              const angle = random(0, Math.PI * 2);
              dateTimeOrbitCenterVx = Math.cos(angle) * dateTimeOrbitCenterSpeedMax;
              dateTimeOrbitCenterVy = Math.sin(angle) * dateTimeOrbitCenterSpeedMax;
              lastDateTimeOrbitCenterDirectionChangeTime = now;
          }

          // Update orbit center position
          dateTimeOrbitCenterX += dateTimeOrbitCenterVx * scaledDeltaTime;
          dateTimeOrbitCenterY += dateTimeOrbitCenterVy * scaledDeltaTime;

          // Clamp orbit center within bounds, ensuring the entire orbit stays on screen
          // The orbit center must be at least dateTimeOrbitRadius from any edge.
          const minX = dateTimeOrbitRadius;
          const maxX = width - dateTimeOrbitRadius;
          const minY = dateTimeOrbitRadius;
          const maxY = height - dateTimeOrbitRadius;

          if (dateTimeOrbitCenterX < minX) {
              dateTimeOrbitCenterVx = Math.abs(dateTimeOrbitCenterVx); // Bounce right
              dateTimeOrbitCenterX = minX; // Clamp
          } else if (dateTimeOrbitCenterX > maxX) {
              dateTimeOrbitCenterVx = -Math.abs(dateTimeOrbitCenterVx); // Bounce left
              dateTimeOrbitCenterX = maxX; // Clamp
          }
          if (dateTimeOrbitCenterY < minY) {
              dateTimeOrbitCenterVy = Math.abs(dateTimeOrbitCenterVy); // Bounce down
              dateTimeOrbitCenterY = minY; // Clamp
          } else if (dateTimeOrbitCenterY > maxY) {
              dateTimeOrbitCenterVy = -Math.abs(dateTimeOrbitCenterVy); // Bounce up
              dateTimeOrbitCenterY = maxY; // Clamp
          }

          // Update orbital angle
          dateTimeOrbitAngle += dateTimeOrbitSpeed * scaledDeltaTime;
          if (dateTimeOrbitAngle > Math.PI * 2) dateTimeOrbitAngle -= Math.PI * 2; // Keep angle within 0 to 2PI

          // Calculate final position based on orbit center and orbital offset
          const orbitalX = dateTimeOrbitCenterX + dateTimeOrbitRadius * Math.cos(dateTimeOrbitAngle);
          const orbitalY = dateTimeOrbitCenterY + dateTimeOrbitRadius * Math.sin(dateTimeOrbitAngle);

          // Apply transform. The CSS already has translate(-50%, -50%) to center the div itself.
          // So, orbitalX and orbitalY are the desired center coordinates.
          dateTimeDisplay.style.transform = `translate(${orbitalX}px, ${orbitalY}px) translate(-50%, -50%)`;
      }

      // Update defenders
      if (shouldMeasure) sectionStart = performance.now();
      defenders.forEach(defender => defender.update(scaledDeltaTime)); // Pass scaledDeltaTime, renamed from satellites
      if (shouldMeasure) accumulatedPerformanceData.defenders += (performance.now() - sectionStart);

      // Update asteroids and check for removal
      if (shouldMeasure) sectionStart = performance.now();
      for (let i = asteroids.length - 1; i >= 0; i--) {
        const asteroid = asteroids[i];
        // If asteroid.update() returns true, it means it went off-screen horizontally and needs removal.
        // Asteroids are also removed from the array by their destroy() method (when health <= 0).
        // So, we remove here if update() signals removal.
        if (asteroid.update(scaledDeltaTime)) {
            // Remove its SVG element from DOM
            if (asteroid.element.parentNode) {
                gameplayLayer.removeChild(asteroid.element); // Remove from gameplay layer
            }
            // It's still good practice to clear the array since the asteroid object is being discarded.
            asteroid.activeCrackEffects = []; // Clear the array

            asteroids.splice(i, 1); // Remove from array
        }
      }
      if (shouldMeasure) accumulatedPerformanceData.asteroids += (performance.now() - sectionStart);

      // Maintain the number of asteroids (spawn off-screen if needed)
      while (asteroids.length < numInitialAsteroids) {
          spawnOffscreenAsteroid();
      }

      // Update UFOs
      if (shouldMeasure) sectionStart = performance.now();
      for (let i = ufos.length - 1; i >= 0; i--) {
        ufos[i].update(scaledDeltaTime); // Pass scaledDeltaTime
      }
      if (shouldMeasure) accumulatedPerformanceData.ufo += (performance.now() - sectionStart);

      // Update lasers and check for removal
      if (shouldMeasure) sectionStart = performance.now();
      for (let i = lasers.length - 1; i >= 0; i--) {
        const laser = lasers[i];
        
        // Update the laser's position and life.
        // This will also handle damage and setting life=0 if it's a user laser and hits its target.
        if (laser.update(scaledDeltaTime)) { // If update returns true, laser's life is up
          laser.remove(); // Return to pool
          lasers.splice(i, 1);
        }
      }
      if (shouldMeasure) accumulatedPerformanceData.lasers += (performance.now() - sectionStart);

      // Update nukes and check for removal
      if (shouldMeasure) sectionStart = performance.now();
      for (let i = nukes.length - 1; i >= 0; i--) {
          const nuke = nukes[i];
          if (nuke.update(scaledDeltaTime)) { // If update returns true, nuke's life is up
              nuke.remove(); // Return to pool
              nukes.splice(i, 1);
          }
      }
      if (shouldMeasure) accumulatedPerformanceData.nukes += (performance.now() - sectionStart);

      // Update fireballs and check for removal
      if (shouldMeasure) sectionStart = performance.now();
      for (let i = activeFireballs.length - 1; i >= 0; i--) {
          const fireball = activeFireballs[i];
          if (fireball.update()) { // If fireball is dead
              fireball.remove();
              activeFireballs.splice(i, 1);
          }
      }
      if (shouldMeasure) accumulatedPerformanceData.fireballs += (performance.now() - sectionStart);

      // Update particles (centralized animation)
      if (shouldMeasure) sectionStart = performance.now();
      for (let i = activeParticles.length - 1; i >= 0; i--) {
          const particle = activeParticles[i];
          if (particle.update(scaledDeltaTime)) { // If particle is dead
              particle.remove();
              activeParticles.splice(i, 1);
          }
      }
      if (shouldMeasure) accumulatedPerformanceData.particles += (performance.now() - sectionStart);

      // New: Aggregate particles
      if (shouldMeasure) sectionStart = performance.now();
      aggregateParticles();
      if (shouldMeasure) accumulatedPerformanceData.particles += (performance.now() - sectionStart); // Add aggregation time to particles category

      // Update exploding UFO parts (centralized animation)
      if (shouldMeasure) sectionStart = performance.now();
      for (let i = explodingUfoParts.length - 1; i >= 0; i--) {
          const part = explodingUfoParts[i];
          if (part.update(scaledDeltaTime)) { // If part is dead
              part.remove();
              explodingUfoParts.splice(i, 1);
          }
      }
      if (shouldMeasure) accumulatedPerformanceData.explodingUfoParts += (performance.now() - sectionStart);

      // Spawn new asteroids (off-screen)
      if (Date.now() - lastAsteroidSpawnTime > asteroidSpawnInterval / gameSpeedMultiplier) { // Scale interval
        spawnOffscreenAsteroid();
        lastAsteroidSpawnTime = Date.now();
      }

      // Spawn UFO
      if (Date.now() - lastUfoSpawnTime > ufoSpawnInterval / gameSpeedMultiplier) { // Scale interval
        spawnUFO();
        lastUfoSpawnTime = Date.now();
      }

      // Process UFO message queue
    /**
     * Processes the UFO message queue, making UFOs speak in sequence.
     */
    function processUfoMessageQueue() {
        if (currentSpeakingUFO) {
            // A UFO is currently speaking, wait for it to finish
            return;
        }

        if (ufoMessageQueue.length > 0) {
            currentSpeakingUFO = ufoMessageQueue.shift(); // Get the next UFO from the queue
            if (currentSpeakingUFO && currentSpeakingUFO.displayMessage) {
                currentSpeakingUFO.displayMessage(() => {
                    // Callback when the UFO finishes speaking
                    currentSpeakingUFO = null; // Clear the current speaking UFO
                    processUfoMessageQueue(); // Process the next in queue
                });
            } else {
                // If for some reason the UFO or its displayMessage method is invalid,
                // clear it and try the next one.
                currentSpeakingUFO = null;
                processUfoMessageQueue();
            }
        }
    }

      // Nuke availability logic
      if (now >= nukeNextAvailableTime) { // Nuke is ready
          nukeAvailable = true;
          nukeButton.innerHTML = 'Nuke'; // Use innerHTML for text and potential line break
          nukeButton.classList.add('nuke-ready-pulse'); // Add pulsation class
          nukeButton.disabled = false;
      } else { // Nuke is on cooldown
          nukeAvailable = false; // Ensure this is false
          // Calculate remaining game time for display
          const realTimeUntilNukeReady = nukeNextAvailableTime - now;
          const remainingGameTimeMs = realTimeUntilNukeReady * gameSpeedMultiplier; // Corrected scaling for display
          const remainingSeconds = Math.max(0, Math.ceil(remainingGameTimeMs / 1000)); 
          nukeButton.innerHTML = `Nuke<br>${remainingSeconds}s`; // Show game-time seconds below Nuke text
          nukeButton.classList.remove('nuke-ready-pulse'); // Remove pulsation class
          nukeButton.disabled = true;
      }

      // Optional: Gain nuke over time (if you want more than one)
      // if (nukeAvailable === false && now - lastNukeGainTime >= nukeGainInterval) {
      //     nukeAvailable = true;
      //     lastNukeGainTime = now;
      //     nukeButton.textContent = 'Nuke: Ready';
      //     nukeButton.classList.remove('bg-gray-900/50', 'text-gray-300', 'hover:bg-gray-800/70');
      //     nukeButton.classList.add('bg-red-800/50', 'text-red-200', 'hover:bg-red-700/70');
      //     nukeButton.disabled = false;
      // }

      // Accumulate overall update time for this frame (only when measuring)
      if (shouldMeasure) {
        accumulatedPerformanceData.overallUpdateTime += (performance.now() - frameStart);
        frameCounterForPerf++;
      }

      // Update and display performance stats periodically
      // Scaled PERF_UPDATE_INTERVAL by gameSpeedMultiplier for consistent display frequency
      if (isPerfStatsVisible && now - lastPerfStatsUpdateTime >= PERF_UPDATE_INTERVAL / gameSpeedMultiplier) {
          let perfHtml = '<h3>Perf (ms/frame avg over 5s)</h3>';
          if (frameCounterForPerf > 0) { // Avoid division by zero
              const avgOverallUpdateTime = accumulatedPerformanceData.overallUpdateTime / frameCounterForPerf;

              // Create a temporary object for displaying averages
              const currentAverages = {};
              let totalMeasuredLogicTime = 0; // Sum of all measured categories for the interval
              for (const key in accumulatedPerformanceData) {
                  if (key !== 'overallUpdateTime') { // Exclude overallUpdateTime from category sum
                      const avg = accumulatedPerformanceData[key] / frameCounterForPerf;
                      currentAverages[key] = avg;
                      totalMeasuredLogicTime += accumulatedPerformanceData[key]; // Sum raw accumulated values
                  }
              }
              const avgMeasuredLogicTime = totalMeasuredLogicTime / frameCounterForPerf;
              const avgUnmeasuredJsOverhead = avgOverallUpdateTime - avgMeasuredLogicTime;

              // Sort categories by their average time spent, descending
              const sortedCategories = Object.keys(currentAverages)
                  .sort((a, b) => currentAverages[b] - currentAverages[a]);

              let totalDomObjects = 0;
              sortedCategories.forEach(key => {
                  let count = 0;
                  // Get the count for each category
                  switch(key) {
                      case 'stars': count = stars.length; break;
                      case 'defenders': count = defenders.length; break;
                      case 'asteroids': count = asteroids.length; break;
                      case 'lasers': count = lasers.length; break;
                      case 'nukes': count = nukes.length; break;
                      case 'fireballs': count = activeFireballs.length; break;
                      case 'particles': count = activeParticles.length; break;
                      case 'explodingUfoParts': count = explodingUfoParts.length; break;
                      case 'ufo': count = ufos.length; break;
                  }
                  totalDomObjects += count;
                  perfHtml += `${key}: ${currentAverages[key].toFixed(2)} ms (${count})<br>`;
              });
              perfHtml += `Total DOM Objects: ${totalDomObjects}<br>`; // Add total DOM objects
              perfHtml += `---<br>`;
              perfHtml += `Total JS Update Time: ${avgOverallUpdateTime.toFixed(2)} ms<br>`;
              perfHtml += `Measured Logic Time: ${avgMeasuredLogicTime.toFixed(2)} ms<br>`;
              perfHtml += `Unmeasured JS Overhead: ${avgUnmeasuredJsOverhead.toFixed(2)} ms<br>`;
          } else {
              perfHtml += `No frames recorded in last ${PERF_UPDATE_INTERVAL / 1000}s`;
          }
          perfStatsDiv.innerHTML = perfHtml;

          // Reset accumulated data for the next interval
          for (const key in accumulatedPerformanceData) {
              accumulatedPerformanceData[key] = 0;
          }
          frameCounterForPerf = 0;
          lastPerfStatsUpdateTime = now;
      }

      requestAnimationFrame(update);
    }

    // --- Event Listeners ---

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.setAttribute('viewBox', `0 0 ${width} ${height}`);
      // Reset starfield translation on resize to avoid large offsets after dimension change
      starfieldOffsetX = 0;
      starfieldOffsetY = 0;
      if (starsScrollGroup) {
        starsScrollGroup.setAttribute('transform', `translate(0, 0)`);
      }
      if (starsLayerLeft && starsLayerUp && starsLayerUpLeft) {
        starsLayerLeft.setAttribute('transform', `translate(${-width}, 0)`);
        starsLayerUp.setAttribute('transform', `translate(0, ${-height})`);
        starsLayerUpLeft.setAttribute('transform', `translate(${-width}, ${-height})`);
      }
      // Reset orbit center to the new screen center on resize
      dateTimeOrbitCenterX = width / 2;
      dateTimeOrbitCenterY = height / 2;
      // Re-apply transform to ensure it's centered immediately
      dateTimeDisplay.style.transform = `translate(${dateTimeOrbitCenterX}px, ${dateTimeOrbitCenterY}px) translate(-50%, -50%)`;
    });

    canvas.addEventListener('click', async (event) => {
      // Initialize AudioContext on first user interaction to comply with browser autoplay policies
      // This call is now redundant here as a global listener handles it, but harmless.
      getAudioContext(); 

      // If paused, do not allow new lasers to be fired
      if (isPaused) return;

      const clickX = event.clientX;
      const clickY = event.clientY;

      // Calculate the angle from the center of the screen to the click point
      // This angle will be used to extend the laser's visual target
      const centerX = width / 2;
      const centerY = height / 2;
      const angleToClick = Math.atan2(clickY - centerY, clickX - centerX);

      // Calculate the new target point by extending the line from the center to the click point
      // by the overshoot distance. This makes the laser appear to go "through" the click.
      // The actual target for the laser's tip is the click point itself.
      const targetX = clickX;
      const targetY = clickY;

      // Define the four corner origins, now slightly off-screen
      const offset = 50 * SCALE_FACTOR; // Pixels to move off-screen
      const origins = [
        { x: -offset, y: -offset },             // Top-left
        { x: width + offset, y: -offset },         // Top-right
        { x: -offset, y: height + offset },        // Bottom-left
        { x: width + offset, y: height + offset }     // Bottom-right
      ];

      // Calculate the maximum distance any laser needs to travel
      let maxDistance = 0;
      origins.forEach(origin => {
        const distance = Math.hypot(targetX - origin.x, targetY - origin.y);
        if (distance > maxDistance) {
          maxDistance = distance;
        }
      });

      // Calculate a common growth duration for all user lasers based on the max distance
      // This duration is the *unscaled* time it would take at 100% speed.
      // Calculate a common collision time for all user lasers based on the max distance
      const commonCollisionTimeMs = Math.max(50, maxDistance / USER_LASER_SPEED_PX_PER_MS); // Minimum 50ms travel time
      const commonTotalVisualDurationMs = commonCollisionTimeMs + USER_LASER_POST_IMPACT_DURATION;

      origins.forEach(origin => {
        const angle = Math.atan2(targetY - origin.y, targetX - origin.x);
        // Use laser pool
        let laser = laserPool.pop();
        if (!laser) { // If pool is empty, create a new one
            laser = new Laser();
        }
        // Pass the actual target coordinates and the common durations
        laser.reset(origin.x, origin.y, angle, 'user', targetX, targetY, null, commonCollisionTimeMs, commonTotalVisualDurationMs);
        laser.element.style.display = ''; // Make visible
        laser.element.style.opacity = 1; // Ensure full opacity at start
        lasers.push(laser);
      });
      // Play user laser sound with spatial audio and an even wider pitch variation
      playSpatialSound(userLaserBuffer, event.clientX, 1.0, 1.0); // Fixed pitch for consistent descending sweep
    });

    // Hamburger menu event listeners
    hamburgerMenuIcon.addEventListener('click', () => {
        sideMenu.classList.toggle('open');
    });

    // Existing button event listeners (now inside the menu or bottom controls)
    qualityToggleBtn.addEventListener('click', cycleQuality);
    qualityModeToggleBtn.addEventListener('click', toggleQualityMode);
    muteToggleBtn.addEventListener('click', toggleMute);
    pauseToggleBtn.addEventListener('click', togglePause);
    dateTimeToggleBtn.addEventListener('click', toggleDateTimeDisplay);
    perfStatsToggleBtn.addEventListener('click', togglePerfStatsDisplay);
    if (ttsToggleBtn) {
        ttsToggleBtn.addEventListener('click', () => {
            ttsEnabled = !ttsEnabled;
            ttsToggleBtn.textContent = `TTS: ${ttsEnabled ? 'On' : 'Off'}`;
            if (!ttsEnabled && 'speechSynthesis' in window) { window.speechSynthesis.cancel(); }
        });
    }
    if (ttsVoiceSelect) {
        ttsVoiceSelect.addEventListener('change', (e) => {
            const uri = e.target.value;
            selectedVoiceURI = uri;
            if (ttsVoices && ttsVoices.length) {
                const found = ttsVoices.find(v => v.voiceURI === uri);
                ttsVoice = found || ttsVoice;
            }
        });
    }

    speedSlider.addEventListener('input', (event) => {
        const sliderValue = parseInt(event.target.value);
        gameSpeedMultiplier = sliderValue / 100;
        speedValueSpan.textContent = `${sliderValue}%`;

        // Update time-based properties for all active defenders
        const settings = qualitySettings[currentQualityLevel]; // Get current quality settings
        defenders.forEach(defender => {
            defender.fireInterval = random(settings.defenderFireInterval[0], settings.defenderFireInterval[1]) / gameSpeedMultiplier;
            defender.thrustCooldown = 500 / gameSpeedMultiplier;
            defender.rcsCooldown = 100 / gameSpeedMultiplier;
            defender.thrustOnDuration = 1000 * SCALE_FACTOR / gameSpeedMultiplier;
            defender.thrustOffDuration = 1000 * SCALE_FACTOR / gameSpeedMultiplier;
        });
    });

    // Defender count slider listener
    if (defenderCountSlider) {
        defenderCountSlider.value = numTargetDefenders; // Initial set
        defenderCountSlider.addEventListener('input', (e) => {
            numTargetDefenders = parseInt(e.target.value, 10);
            updateDefenderControls(); // Update all defender controls
            manageDefenders(); // Update defenders when slider changes
        });
    }

    // Defender count input field listener (now covers the main display)
    if (defenderCountInput) {
        defenderCountInput.value = numTargetDefenders; // Initial set
        defenderCountInput.addEventListener('change', (e) => { // Use 'change' event for text input
            let inputValue = parseInt(e.target.value, 10);
            if (isNaN(inputValue) || inputValue < 0) {
                inputValue = 0; // Default to 0 if invalid
            }
            numTargetDefenders = inputValue;
            updateDefenderControls(); // Update all defender controls
            manageDefenders(); // Update defenders when input changes
        });
    }

    // Initialize auto-quality sliders to current values and add listeners
    if (autoLowFpsSlider) {
        autoLowFpsSlider.value = AUTO_LOW_THRESHOLD_FPS;
        autoLowFpsValue.textContent = `${AUTO_LOW_THRESHOLD_FPS}`;
        autoLowFpsSlider.addEventListener('input', (e) => {
            AUTO_LOW_THRESHOLD_FPS = parseInt(e.target.value, 10);
            autoLowFpsValue.textContent = `${AUTO_LOW_THRESHOLD_FPS}`;
        });
    }
    if (autoLowStreakSlider) {
        autoLowStreakSlider.value = AUTO_LOW_STREAK_SECONDS;
        autoLowStreakValue.textContent = `${AUTO_LOW_STREAK_SECONDS}s`;
        autoLowStreakSlider.addEventListener('input', (e) => {
            AUTO_LOW_STREAK_SECONDS = parseInt(e.target.value, 10);
            autoLowStreakValue.textContent = `${AUTO_LOW_STREAK_SECONDS}s`;
        });
    }
    if (autoHighFpsSlider) {
        autoHighFpsSlider.value = AUTO_HIGH_THRESHOLD_FPS;
        autoHighFpsValue.textContent = `${AUTO_HIGH_THRESHOLD_FPS}`;
        autoHighFpsSlider.addEventListener('input', (e) => {
            AUTO_HIGH_THRESHOLD_FPS = parseInt(e.target.value, 10);
            autoHighFpsValue.textContent = `${AUTO_HIGH_THRESHOLD_FPS}`;
        });
    }
    if (autoHighStreakSlider) {
        autoHighStreakSlider.value = AUTO_HIGH_STREAK_SECONDS;
        autoHighStreakValue.textContent = `${AUTO_HIGH_STREAK_SECONDS}s`;
        autoHighStreakSlider.addEventListener('input', (e) => {
            AUTO_HIGH_STREAK_SECONDS = parseInt(e.target.value, 10);
            autoHighStreakValue.textContent = `${AUTO_HIGH_STREAK_SECONDS}s`;
        });
    }

    // Initialize quality button labels
    updateQualityButtonText();
    updateQualityModeButtonText();
    updateDefenderControls(); // Initialize defender controls to reflect numTargetDefenders
    // Initialize TTS voice list once available
    if ('speechSynthesis' in window) {
        window.speechSynthesis.onvoiceschanged = () => {
            populateTtsVoiceList();
        };
        // Try initial load as well (may be empty at first call)
        populateTtsVoiceList();
    } else if (ttsVoicesStatus) {
        ttsVoicesStatus.textContent = '0';
        if (ttsVoiceSelect) ttsVoiceSelect.disabled = true;
    }

    nukeButton.addEventListener('click', async (event) => { // Made async to await audio context resume
        // Don't fire if paused, not available, or one is already active
        if (isPaused || !nukeAvailable || nukes.length > 0) return;

        const ctx = getAudioContext();
        if (ctx.state === 'suspended') {
            try {
                await ctx.resume(); // Attempt to resume audio context on user gesture
            } catch (e) {
                console.error('Failed to resume AudioContext for nuke launch:', e);
                return; // If resume fails, don't proceed with sound
            }
        }

        // Nuke always fires to the center of the screen
        const targetX = width / 2;
        const targetY = height / 2;

        // Nuke always fires from the bottom center of the screen
        const startX = width / 2;
        const startY = height + 50 * SCALE_FACTOR; // Start slightly off-screen bottom

        let nuke = nukePool.pop();
        if (!nuke) {
            nuke = new Nuke();
        }
        nuke.reset(startX, startY, targetX, targetY);
        nukes.push(nuke);

        playSpatialSound(nukeLaunchBuffer, startX, 1.2); // Play nuke launch sound, louder
        
        nukeAvailable = false;
        // Scale the cooldown duration before adding it to the current time
        nukeNextAvailableTime = Date.now() + (nukeCooldown / gameSpeedMultiplier); // Set next available time, scaled
        nukeButton.textContent = 'Nuke'; // Keep text simple
        nukeButton.classList.remove('nuke-ready-pulse'); // Remove pulsation class
        nukeButton.disabled = true; // Disable immediately
    });

    // --- Main Setup ---
    window.onload = async function() {
      // Set the global game start time as early as possible
      gameStartTime = Date.now();

      // Create AudioContext (suspended is fine); resume happens on first user gesture
      getAudioContext();

      // Generate sound data URIs and decode into AudioBuffers
      const decodeAudio = async (dataUri) => {
        const response = await fetch(dataUri);
        const arrayBuffer = await response.arrayBuffer();
        return await audioCtx.decodeAudioData(arrayBuffer);
      };

      try {
        laserBuffer = await decodeAudio(generateToneSweep(150, 1200, 400)); // Defender laser: Higher pitch sweep
      } catch (e) { console.error("Failed to load laserBuffer:", e); }
      try {
        userLaserBuffer = await decodeAudio(generateHarmonicToneSweep(200, 1200, 400, [1, 1.25, 1.5])); // Further reduced duration for user laser
      } catch (e) { console.error("Failed to load userLaserBuffer:", e); }
      try {
        explosionBuffer = await decodeAudio(generateNoiseBurst(250, 1.5)); // Reduced duration for faster asteroid explosions
      } catch (e) { console.error("Failed to load explosionBuffer:", e); }
      try {
        ufoBuffer = await decodeAudio(generateHum(1000, 50)); // Low, sustained hum
      } catch (e) { console.error("Failed to load ufoBuffer:", e); }
      try {
        // UFO explosion howl: a longer, descending harmonic sweep
        ufoExplosionHowlBuffer = await decodeAudio(generateHarmonicToneSweep(125, 800, 100, [1, 1.5, 2.0])); // Doubled duration for UFO howl
        // Create reversed version for UFO warp-in sound
        ufoWarpInSoundBuffer = audioCtx.createBuffer(
            ufoExplosionHowlBuffer.numberOfChannels,
            ufoExplosionHowlBuffer.length,
            ufoExplosionHowlBuffer.sampleRate
        );
        for (let i = 0; i < ufoExplosionHowlBuffer.numberOfChannels; i++) {
            const originalChannelData = ufoExplosionHowlBuffer.getChannelData(i);
            const reversedChannelData = ufoWarpInSoundBuffer.getChannelData(i);
            for (let j = 0; j < originalChannelData.length; j++) {
                reversedChannelData[j] = originalChannelData[originalChannelData.length - 1 - j];
            }
        }
      } catch (e) { console.error("Failed to load ufoExplosionHowlBuffer or create ufoWarpInSoundBuffer:", e); }
      try {
        // Higher pitch, shorter, more impactful descending chord for nuke launch
        // Start high (800Hz), end lower (100Hz), duration 700ms, with a dissonant chord
        nukeLaunchBuffer = await decodeAudio(generateHarmonicToneSweep(700, 800, 100, [1, 1.122, 1.335, 1.5])); // Root, minor second, perfect fourth, perfect fifth (more dissonant)
      } catch (e) { console.error("Failed to load nukeLaunchBuffer:", e); }
      try {
        sparkSoundBuffer = await decodeAudio(generateSparkSound(200)); // Increased duration for more noticeable effect
      } catch (e) { console.error("Failed to load sparkSoundBuffer:", e); }
      try {
        aggregationSoundBuffer = await decodeAudio(generateSparkSound(50)); // A very short spark/fizz for aggregation
      } catch (e) { console.error("Failed to load aggregationSoundBuffer:", e); }

      // Get references to the pre-defined SVG layers
      const baseStarsLayer = document.getElementById('starsLayer');
      gameplayLayer = document.getElementById('gameplayLayer');
      effectsLayer = document.getElementById('effectsLayer');
      nukeFlashLayer = document.getElementById('nukeFlashLayer'); // New: Get reference to the nuke flash layer

      // Create a scroll group for stars and tile clones for seamless scrolling
      if (!starsScrollGroup) {
        starsScrollGroup = createSVGElement('g');
        starsScrollGroup.setAttribute('id', 'starsScrollGroup');
        // Insert scroll group in place of baseStarsLayer
        const svgRoot = baseStarsLayer.parentNode;
        svgRoot.insertBefore(starsScrollGroup, baseStarsLayer);
        // Move the base layer inside the scroll group and keep reference
        starsLayer = baseStarsLayer;
        starsScrollGroup.appendChild(starsLayer);
        // Create tiled clones containers
        starsLayerLeft = createSVGElement('g');
        starsLayerUp = createSVGElement('g');
        starsLayerUpLeft = createSVGElement('g');
        starsScrollGroup.appendChild(starsLayerLeft);
        starsScrollGroup.appendChild(starsLayerUp);
        starsScrollGroup.appendChild(starsLayerUpLeft);
      }

      // Initialize tiling transforms for clones
      starsLayerLeft.setAttribute('transform', `translate(${-width}, 0)`);
      starsLayerUp.setAttribute('transform', `translate(0, ${-height})`);
      starsLayerUpLeft.setAttribute('transform', `translate(${-width}, ${-height})`);

      // Pre-populate object pools
      for (let i = 0; i < MAX_LASERS; i++) {
          // Create a new Laser instance. Its constructor now handles creating the SVG elements
          // and setting them to hidden and off-screen.
          laserPool.push(new Laser()); 
      }
      for (let i = 0; i < MAX_NUKES; i++) { // Populate nuke pool
          nukePool.push(new Nuke());
      }
      for (let i = 0; i < MAX_FIREBALLS; i++) { // Populate fireball pool
          fireballPool.push(new FireballEffect());
      }
      for (let i = 0; i < MAX_PARTICLES; i++) {
          const particleElement = createSVGElement('circle');
          particleElement.style.display = 'none'; // Initially hidden
          particleElement.setAttribute('cx', -9999); // Move off-screen
          particleElement.setAttribute('cy', -9999); // Move off-screen
          // Do NOT append to effectsLayer here; append in createExplosion when activated
          particlePool.push(particleElement); // Store the element directly for particles
      }

      applyQualitySettings(); // Apply initial quality settings, which calls initStars()
      initDefenders(); // Renamed from initSatellites
      initAsteroids();

      // Initialize the full-screen nuke flash element (placed last to ensure it's on top)
      nukeFlashElement = createSVGElement('rect');
      nukeFlashElement.style.display = 'none'; // Initially hidden
      nukeFlashElement.style.pointerEvents = 'none'; // Allow clicks to pass through
      nukeFlashElement.setAttribute('x', 0);
      nukeFlashElement.setAttribute('y', 0);
      nukeFlashElement.setAttribute('width', width);
      nukeFlashElement.setAttribute('height', height);
      nukeFlashElement.setAttribute('fill', 'white');
      nukeFlashElement.style.opacity = 0; // Start transparent
      nukeFlashLayer.appendChild(nukeFlashElement); // Append to the new nuke flash layer

      // Initialize date/time display movement parameters
      dateTimeOrbitRadius = Math.min(width, height) * 0.2; // 20% of the smaller dimension
      dateTimeOrbitAngle = random(0, Math.PI * 2); // Start at a random point in orbit
      dateTimeOrbitCenterX = width / 2; // Start orbit center at screen center
      dateTimeOrbitCenterY = height / 2;
      lastDateTimeOrbitCenterDirectionChangeTime = Date.now();
      // Set initial random drift for the orbit center
      const initialAngle = random(0, Math.PI * 2);
      dateTimeOrbitCenterVx = Math.cos(initialAngle) * dateTimeOrbitCenterSpeedMax;
      dateTimeOrbitCenterVy = Math.sin(initialAngle) * dateTimeOrbitCenterSpeedMax;

      // Initial update for date/time display and set interval
      updateDateTimeDisplay(); // Populate content first

      // Calculate initial position for the clock
      const initialOrbitalX = dateTimeOrbitCenterX + dateTimeOrbitRadius * Math.cos(dateTimeOrbitAngle);
      const initialOrbitalY = dateTimeOrbitCenterY + dateTimeOrbitRadius * Math.sin(dateTimeOrbitAngle);
      dateTimeDisplay.style.transform = `translate(${initialOrbitalX}px, ${initialOrbitalY}px) translate(-50%, -50%)`;

      // Show the display if it's meant to be visible
      if (isDateTimeVisible) {
          dateTimeDisplay.style.display = 'block';
      }
      
      setInterval(updateDateTimeDisplay, 1000); // Update every second

      // Set initial lastUfoSpawnTime to ensure a 5-second delay before the first UFO spawns
      // This calculates a past time such that Date.now() - lastUfoSpawnTime will be (ufoSpawnInterval / gameSpeedMultiplier) - 5000
      // It will then take 5000ms for Date.now() to increase enough to trigger the first spawn.
      lastUfoSpawnTime = Date.now() - (ufoSpawnInterval / gameSpeedMultiplier) + 5000;

      // Start the animation loop
      requestAnimationFrame(update);
    };
  </script>
</body>
</html>
